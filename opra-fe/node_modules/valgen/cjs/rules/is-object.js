"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isObject = void 0;
const constants_js_1 = require("../constants.js");
const index_js_1 = require("../core/index.js");
/**
 * Validates object according to schema
 * Converts properties according to schema rules if coerce option is set to 'true'.
 * @validator isObject
 */
function isObject(schema, options) {
    const ctor = options?.ctor;
    const ctorName = options?.name || ctor?.name;
    const additionalFields = options?.additionalFields ?? !schema;
    const caseInSensitive = !!options?.caseInSensitive;
    const detectCircular = !!options?.detectCircular;
    const propertyRules = {};
    const propertyOptions = {};
    schema = schema || {};
    const schemaKeys = Object.keys(schema);
    for (const k of schemaKeys) {
        const n = schema[k];
        const key = caseInSensitive ? k.toLowerCase() : k;
        if (Array.isArray(n)) {
            if (!(0, index_js_1.isValidator)(n[0]))
                throw new TypeError(`Invalid tuple definition in validation schema (${k})`);
            propertyRules[key] = n[0];
            propertyOptions[key] = { as: k, ...n[1] };
        }
        else if ((0, index_js_1.isValidator)(n)) {
            propertyRules[key] = n;
            propertyOptions[key] = { as: k };
        }
        else
            throw new TypeError(`Invalid definition in validation schema (${k})`);
    }
    const _rule = (0, index_js_1.validator)('isObject', function (input, context, _this) {
        if (ctor && ctor[constants_js_1.preValidation])
            input = ctor[constants_js_1.preValidation](input, context, _this);
        if (typeof input === 'string' && context.coerce)
            input = JSON.parse(input);
        if (!(input && typeof input === 'object')) {
            context.fail(_this, `{{label}} must be an object`, input);
            return;
        }
        const keys = [...Object.keys(input), ...schemaKeys];
        const l = keys.length;
        let i = 0;
        let inputKey;
        let schemaKey;
        let v;
        let _propRule;
        const out = {};
        if (ctor)
            Object.setPrototypeOf(out, ctor.prototype);
        if (detectCircular) {
            context.circMap = context.circMap || new Map();
            if (context.circMap.has(input))
                return context.circMap.get(input);
            context.circMap.set(input, out);
        }
        if (context.root == null)
            context.root = context.root || ctorName || '';
        const location = context.location || '';
        const processedSchemaKeys = {};
        // Iterate object keys and perform rules
        for (i = 0; i < l; i++) {
            inputKey = keys[i];
            schemaKey = caseInSensitive ? inputKey.toLowerCase() : inputKey;
            v = input[inputKey];
            _propRule = propertyRules[schemaKey] ||
                ((0, index_js_1.isValidator)(additionalFields) ? additionalFields : undefined);
            if (_propRule) {
                if (processedSchemaKeys[schemaKey])
                    continue;
                processedSchemaKeys[schemaKey] = true;
                const subCtx = context.extend();
                subCtx.scope = input;
                subCtx.context = ctorName;
                subCtx.location = location + (location ? '.' : '') + schemaKey;
                subCtx.property = schemaKey;
                if (propertyOptions[schemaKey]?.label)
                    subCtx.label = propertyOptions[schemaKey]?.label;
                v = _propRule(v, subCtx);
            }
            else if (v !== undefined) {
                if (!additionalFields)
                    continue;
                if (additionalFields === 'error')
                    context.fail(_propRule, `${ctorName || 'Object'} has no field '${inputKey}' and does not accept additional fields`, v);
            }
            if (v !== undefined)
                out[propertyOptions[schemaKey]?.as || schemaKey] = v;
        }
        if (context.errors.length)
            return undefined;
        if (ctor && ctor[constants_js_1.postValidation]) {
            ctor[constants_js_1.postValidation](out, context, _this);
            return out;
        }
        return out;
    }, options);
    _rule.schema = schema;
    return _rule;
}
exports.isObject = isObject;
