"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHexadecimal = exports.isDecimal = exports.isAscii = exports.isAlphanumeric = exports.isAlpha = exports.isUppercase = exports.isLowercase = exports.isJWT = exports.isHexColor = exports.isHash = exports.isETHAddress = exports.isBtcAddress = exports.isVAT = exports.isISSN = exports.isFQDN = exports.isEAN = exports.isPassportNumber = exports.isIBAN = exports.isCreditCard = exports.isBIC = exports.isBase64 = exports.isURL = exports.isPort = exports.isMACAddress = exports.isIPRange = exports.isIP = exports.isMobilePhone = exports.isEmail = exports.isUUID = void 0;
const validatorJS = __importStar(require("validator"));
const index_js_1 = require("../core/index.js");
/**
 * Validates if value is an "UUID".
 * @validator isUUID
 */
function isUUID(version, options) {
    return (0, index_js_1.validator)('isUUID', function (input, context, _this) {
        if (input != null && typeof input === 'string' && validatorJS.isUUID(input, version))
            return input;
        context.fail(_this, `{{label}} is not a valid UUID${version ? ' v' + version : ''}`, input);
    }, options);
}
exports.isUUID = isUUID;
/**
 * Validates if value is a valid Email
 * @validator isEmail
 */
function isEmail(options) {
    return (0, index_js_1.validator)('isEmail', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isEmail(input, options))
            return input;
        context.fail(_this, `{{label}} is not a valid a EMail`, input);
    }, options);
}
exports.isEmail = isEmail;
/**
 * Validates if value is a valid Email
 * @validator isMobilePhone
 */
function isMobilePhone(options) {
    return (0, index_js_1.validator)('isMobilePhone', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isMobilePhone(input, options?.locale, options))
            return input;
        context.fail(_this, `{{label}} is not a valid a Mobile Phone Number`, input);
    }, options);
}
exports.isMobilePhone = isMobilePhone;
/**
 * Validates if value is an IP
 * @validator isIP
 */
function isIP(version, options) {
    return (0, index_js_1.validator)('isIP', function (input, context, _this) {
        if (input != null && typeof input === 'string' && validatorJS.isIP(input, version))
            return input;
        context.fail(_this, `{{label}} is not a valid IP${version ? ' v' + version : ''}`, input);
    }, options);
}
exports.isIP = isIP;
/**
 * Validates if value is an IP
 * @validator isUUID
 */
function isIPRange(version, options) {
    return (0, index_js_1.validator)('isIPRange', function (input, context, _this) {
        if (input != null && typeof input === 'string' && validatorJS.isIPRange(input, version))
            return input;
        context.fail(_this, `{{label}} is not a valid IP${version ? ' v' + version : ''} range`, input);
    }, options);
}
exports.isIPRange = isIPRange;
/**
 * Validates if value is an MACAddress
 * @validator isMACAddress
 */
function isMACAddress(options) {
    return (0, index_js_1.validator)('isMACAddress', function (input, context, _this) {
        if (input != null && typeof input === 'string' && validatorJS.isMACAddress(input, options))
            return input;
        context.fail(_this, `{{label}} is not a valid MAC address`, input);
    }, options);
}
exports.isMACAddress = isMACAddress;
/**
 * Validates if value is a port number
 * @validator isPort
 */
function isPort(options) {
    return (0, index_js_1.validator)('isPort', function (input, context, _this) {
        if (input != null && typeof input === 'string' && validatorJS.isPort(input))
            return input;
        context.fail(_this, `{{label}} is not a valid port number`, input);
    }, options);
}
exports.isPort = isPort;
/**
 * Validates if value is an MACAddress
 * @validator isURL
 */
function isURL(options) {
    return (0, index_js_1.validator)('isURL', function (input, context, _this) {
        if (input != null && typeof input === 'string' && validatorJS.isURL(input, options))
            return input;
        context.fail(_this, `{{label}} is not a valid URL`, input);
    }, options);
}
exports.isURL = isURL;
/**
 * Validates if value is a "Base64" string.
 * @validator isBase64
 */
function isBase64(options) {
    return (0, index_js_1.validator)('isBase64', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isBase64(input, options))
            return input;
        context.fail(_this, `{{label}} is not a valid a Base64 string`, input);
    }, options);
}
exports.isBase64 = isBase64;
/**
 * Validates if value is a BIC (Bank Identification Code) or SWIFT code
 * @validator isBIC
 */
function isBIC(options) {
    return (0, index_js_1.validator)('isBIC', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isBIC(input))
            return input;
        context.fail(_this, `{{label}}is not a valid a BIC (Bank Identification Code) or SWIFT code`, input);
    }, options);
}
exports.isBIC = isBIC;
/**
 * Validates if value is a "Base64" formatted string.
 * @validator isCreditCard
 */
function isCreditCard(options) {
    return (0, index_js_1.validator)('isCreditCard', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isCreditCard(input, options))
            return input;
        context.fail(_this, `{{label}} is not a valid Credit Card number`, input);
    }, options);
}
exports.isCreditCard = isCreditCard;
/**
 * Validates if value is an IBAN (International Bank Account Number)
 * @validator isEAN
 */
function isIBAN(options) {
    return (0, index_js_1.validator)('isIBAN', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isIBAN(input))
            return input;
        context.fail(_this, `{{label}} is not a valid IBAN (International Bank Account Number)`, input);
    }, options);
}
exports.isIBAN = isIBAN;
/**
 * Validates if value is an passport number
 * @validator isPassportNumber
 */
function isPassportNumber(countryCode, options) {
    return (0, index_js_1.validator)('isPassportNumber', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isPassportNumber(input, countryCode))
            return input;
        context.fail(_this, `{{label}} is not a valid ${countryCode} PassportNumber)`, input);
    }, options);
}
exports.isPassportNumber = isPassportNumber;
/**
 * Validates if value is an EAN (European Article Number)
 * @validator isEAN
 */
function isEAN(options) {
    return (0, index_js_1.validator)('isEAN', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isEAN(input))
            return input;
        context.fail(_this, `{{label}} is not a valid EAN (European Article Number)`, input);
    }, options);
}
exports.isEAN = isEAN;
/**
 * Validates if value is an FQDN
 * @validator isFQDN
 */
function isFQDN(options) {
    return (0, index_js_1.validator)('isFQDN', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isFQDN(input, options))
            return input;
        context.fail(_this, `{{label}} is not valid FQDN`, input);
    }, options);
}
exports.isFQDN = isFQDN;
/**
 * Validates if value is an ISSN
 * @validator isISSN
 */
function isISSN(options) {
    return (0, index_js_1.validator)('isISSN', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isISSN(input, options))
            return input;
        context.fail(_this, `{{label}} is not a valid ISSN`, input);
    }, options);
}
exports.isISSN = isISSN;
/**
 * Validates if value is an VAT number
 * @validator isVAT
 */
function isVAT(countryCode, options) {
    return (0, index_js_1.validator)('isVAT', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isVAT(input, countryCode))
            return input;
        context.fail(_this, `{{label}} is not a valid VAT number`, input);
    }, options);
}
exports.isVAT = isVAT;
/**
 * Validates if value is a BTC address.
 * @validator isBtcAddress
 */
function isBtcAddress(options) {
    return (0, index_js_1.validator)('isBtcAddress', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isBtcAddress(input))
            return input;
        context.fail(_this, `{{label}} is not a valid a BTC address`, input);
    }, options);
}
exports.isBtcAddress = isBtcAddress;
/**
 * Validates if value is a ETH (Ethereum) address.
 * @validator isBtcAddress
 */
function isETHAddress(options) {
    return (0, index_js_1.validator)('isETHAddress', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isEthereumAddress(input))
            return input;
        context.fail(_this, `{{label}} is not a valid a ETH (Ethereum) address`, input);
    }, options);
}
exports.isETHAddress = isETHAddress;
/**
 * Validates if value a hash of type algorithm
 * @validator isHash
 */
function isHash(algorithm, options) {
    return (0, index_js_1.validator)('isHash', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isHash(input, algorithm))
            return input;
        context.fail(_this, `{{label}} is not a valid ${algorithm} hash`, input);
    }, options);
}
exports.isHash = isHash;
/**
 * Validates if value is a Hex Color
 * @validator isHexColor
 */
function isHexColor(options) {
    return (0, index_js_1.validator)('isHexColor', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isHexColor(input))
            return input;
        context.fail(_this, `{{label}} is not a valid Hex Color`, input);
    }, options);
}
exports.isHexColor = isHexColor;
/**
 * Validates if value a valid JWT token
 * @validator isHash
 */
function isJWT(options) {
    return (0, index_js_1.validator)('isJWT', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isJWT(input))
            return input;
        context.fail(_this, `{{label}} is not a valid JWT token`, input);
    }, options);
}
exports.isJWT = isJWT;
/**
 * Validates if value a Lowercase string
 * @validator isLowercase
 */
function isLowercase(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isLowercase(input))
            return input;
        context.fail(_this, `{{label}} is not a lowercase string`, input);
    }, options);
}
exports.isLowercase = isLowercase;
/**
 * Validates if value a Uppercase string
 * @validator isUppercase
 */
function isUppercase(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isUppercase(input))
            return input;
        context.fail(_this, `{{label}} is not an uppercase string`, input);
    }, options);
}
exports.isUppercase = isUppercase;
/**
 * Check if the string contains only letters (a-zA-Z).
 * @validator isAlpha
 */
function isAlpha(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isAlpha(input))
            return input;
        context.fail(_this, `{{label}} is not an alpha string`, input);
    }, options);
}
exports.isAlpha = isAlpha;
/**
 * Check if the string contains only letters and numbers.
 * @validator isAlphanumeric
 */
function isAlphanumeric(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isAlphanumeric(input))
            return input;
        context.fail(_this, `{{label}} is not an alphanumeric string`, input);
    }, options);
}
exports.isAlphanumeric = isAlphanumeric;
/**
 * Check if the string contains ASCII chars only.
 * @validator isAscii
 */
function isAscii(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isAscii(input))
            return input;
        context.fail(_this, `{{label}} is not an ascii string`, input);
    }, options);
}
exports.isAscii = isAscii;
/**
 * Check if the string represents a decimal number,
 * such as `0.1`, `.3`, `1.1`, `1.00003`, `4.0` etc.
 * @validator isDecimal
 */
function isDecimal(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isDecimal(input))
            return input;
        context.fail(_this, `{{label}} is not an decimal number string`, input);
    }, options);
}
exports.isDecimal = isDecimal;
/**
 * Check if the string is a hexadecimal number.
 * @validator isHexadecimal
 */
function isHexadecimal(options) {
    return (0, index_js_1.validator)('isLowercase', function (input, context, _this) {
        if (typeof input === 'string' && validatorJS.isHexadecimal(input))
            return input;
        context.fail(_this, `{{label}} is not an hexadecimal string`, input);
    }, options);
}
exports.isHexadecimal = isHexadecimal;
