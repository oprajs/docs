/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import http, { OutgoingHttpHeaders } from 'http';
import { Duplex, Writable } from 'stream';
import type { HttpIncomingMessage } from './http-incoming-message.host.js';
export declare const kOutHeaders: unique symbol;
export declare const kOutTrailers: unique symbol;
declare global {
    interface Headers {
        keys(): IterableIterator<string>;
        entries(): IterableIterator<[string, any]>;
    }
}
export interface HttpOutgoingMessage extends Pick<http.ServerResponse, 'addTrailers' | 'getHeader' | 'getHeaders' | 'getHeaderNames' | 'removeHeader' | 'hasHeader' | 'headersSent' | 'statusCode' | 'statusMessage' | 'sendDate'>, Writable {
    req?: HttpIncomingMessage;
    appendHeader(name: string, value: string | readonly string[]): this;
    setHeader(name: string, value: number | string | readonly string[]): this;
}
export declare namespace HttpOutgoingMessageHost {
    interface Initiator {
        req?: HttpIncomingMessage;
        statusCode?: number;
        statusMessage?: string;
        headers?: OutgoingHttpHeaders | Headers | Map<string, any> | string[];
        chunkedEncoding?: boolean;
        sendDate?: boolean;
        strictContentLength?: boolean;
        body?: string | Iterable<any> | AsyncIterable<any> | Object;
    }
}
/**
 *
 * @class HttpOutgoingMessageHost
 */
export declare class HttpOutgoingMessageHost extends Duplex implements HttpOutgoingMessage {
    protected [kOutHeaders]: Record<string, any>;
    protected [kOutTrailers]: Record<string, any>;
    protected _headersSent: boolean;
    protected _httpVersionMajor?: number;
    protected _httpVersionMinor?: number;
    finished: boolean;
    req?: HttpIncomingMessage;
    statusCode: number;
    statusMessage: string;
    chunkedEncoding: boolean;
    sendDate: boolean;
    strictContentLength: boolean;
    body?: any;
    constructor(init?: HttpOutgoingMessageHost.Initiator);
    get httpVersionMajor(): number | undefined;
    get httpVersionMinor(): number | undefined;
    get headersSent(): boolean;
    appendHeader(name: string, value: number | string | readonly string[]): this;
    addTrailers(headers: OutgoingHttpHeaders | [string, string][] | readonly [string, string][]): void;
    setHeader(name: any, value: any): this;
    setHeaders(headers: Headers | Map<string, any> | Record<string, any>): this;
    getHeader(name: string): any;
    getHeaderNames(): string[];
    getRawHeaderNames(): any[];
    getHeaders(): OutgoingHttpHeaders;
    hasHeader(name: string): boolean;
    removeHeader(name: string): void;
    end(cb?: () => void): this;
    end(chunk: any, cb?: () => void): this;
    end(chunk: any, encoding: BufferEncoding, cb?: () => void): this;
    static from(init: HttpOutgoingMessageHost.Initiator): HttpOutgoingMessageHost;
}
