import './augmentation/18n.augmentation.js';
import path from 'path';
import { pascalCase } from 'putil-varhelpers';
import { AsyncEventEmitter } from 'strict-typed-events';
import { BadRequestError, Container, CrudResource, ForbiddenError, getStackFileName, I18n, Resource, translate } from '@opra/common';
import { Logger } from './services/logger.js';
const resourceInitialized = Symbol.for('opra.resource.initialized');
/**
 * @class PlatformAdapterHost
 */
export class PlatformAdapterHost extends AsyncEventEmitter {
    constructor() {
        super(...arguments);
        this._controllers = new Map();
    }
    get api() {
        return this._api;
    }
    get platform() {
        return this._platform;
    }
    get protocol() {
        return this._protocol;
    }
    get serviceName() {
        return this._serviceName;
    }
    get i18n() {
        return this._i18n;
    }
    async close() {
        const promises = [];
        for (const r of this._controllers.values()) {
            const onShutdown = r?.onShutdown;
            if (onShutdown)
                promises.push((async () => onShutdown.call(r.controller, r))());
        }
        await Promise.allSettled(promises);
        this._controllers.clear();
    }
    /**
     * Initializes the adapter
     */
    async init(api, options) {
        if (this._api)
            throw new Error(`Already initialized`);
        this._api = api;
        this._interceptors = [...(options?.interceptors || [])];
        this._logger = options?.logger && options.logger instanceof Logger
            ? options.logger
            : new Logger({ instance: options?.logger });
        // Assign events
        if (options?.on) {
            for (const [event, fn] of Object.entries(options.on)) {
                /* istanbul ignore next */
                if (typeof fn === 'function')
                    this.on(event, fn);
            }
        }
        // Make a safe service name
        this._serviceName = pascalCase((api.info.title || '').replace(/[^a-z0-9_ ]/ig, '')) || 'OpraService';
        if (!/^[a-z]/i.test(this._serviceName))
            this._serviceName = 'X' + this._serviceName;
        // Init I18n
        if (options?.i18n instanceof I18n)
            this._i18n = options.i18n;
        else if (typeof options?.i18n === 'function')
            this._i18n = await options.i18n();
        else
            this._i18n = await this._createI18n(options?.i18n);
        this._i18n = this._i18n || I18n.defaultInstance;
        if (!this._i18n.isInitialized)
            await this._i18n.init();
        // Initialize all resources
        await this.getController(this.api.root);
    }
    async getController(resource) {
        resource = typeof resource === 'object' && resource instanceof Resource
            ? resource : this.api.getResource(resource);
        let controller = this._controllers.get(resource);
        if (!controller) {
            controller = resource.controller;
            if (!controller && resource.ctor) {
                controller = new resource.ctor();
            }
            this._controllers.set(resource, controller);
        }
        if (controller && !controller[resourceInitialized]) {
            controller[resourceInitialized] = true;
            // Initialize controller
            if (typeof controller.onInit === 'function')
                await controller.onInit.call(controller);
            // Initialize sub resources of Container
            if (resource instanceof Container) {
                for (const r of resource.resources.values()) {
                    await this.getController(r);
                }
            }
        }
        return controller;
    }
    async getActionHandler(resource, name) {
        resource = typeof resource === 'object' && resource instanceof Resource
            ? resource
            : this.api.getResource(resource);
        const controller = await this.getController(resource);
        const endpoint = resource.actions.get(name);
        if (endpoint) {
            const handler = typeof controller[endpoint.name] === 'function' ? controller[endpoint.name] : undefined;
            if (handler)
                return { controller, endpoint, handler };
        }
        throw new BadRequestError({
            message: translate('error:ACTION_NOT_FOUND', { resource: resource.name, action: name }),
            severity: 'error',
            code: 'ACTION_NOT_FOUND'
        });
    }
    async getOperationHandler(resource, name) {
        resource = typeof resource === 'object' && resource instanceof Resource
            ? resource
            : this.api.getResource(resource);
        const controller = await this.getController(resource);
        const endpoint = resource instanceof CrudResource && resource.operations.get(name);
        if (endpoint) {
            const handler = typeof controller[endpoint.name] === 'function' ? controller[endpoint.name] : undefined;
            if (handler)
                return { controller, endpoint, handler };
        }
        throw new ForbiddenError({
            message: translate('error:OPERATION_FORBIDDEN', { resource: resource.name, operation: name }),
            severity: 'error',
            code: 'OPERATION_FORBIDDEN'
        });
    }
    async _createI18n(options) {
        const opts = {
            ...options,
        };
        delete opts.resourceDirs;
        const instance = I18n.createInstance(opts);
        await instance.init();
        await instance.loadResourceDir(path.resolve(getStackFileName(), '../../../i18n'));
        if (options?.resourceDirs)
            for (const dir of options.resourceDirs)
                await instance.loadResourceDir(dir);
        return instance;
    }
}
