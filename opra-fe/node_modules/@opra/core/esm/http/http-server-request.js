/*
  Some parts of this file contains codes from open source express library
  https://github.com/expressjs
 */
import accepts from 'accepts';
import fresh from 'fresh';
import parseRange from 'range-parser';
import typeIs from '@browsery/type-is';
import { isReadable, mergePrototype, OpraURL } from '@opra/common';
import { HttpIncomingMessageHost } from './impl/http-incoming-message.host.js';
function isHttpIncomingMessage(v) {
    return v && Array.isArray(v.rawHeaders) && isReadable(v);
}
export var HttpServerRequest;
(function (HttpServerRequest) {
    function from(instance) {
        if (!isHttpIncomingMessage(instance))
            instance = HttpIncomingMessageHost.from(instance);
        mergePrototype(instance, HttpServerRequestHost.prototype);
        const req = instance;
        req.baseUrl = req.baseUrl || '';
        req.parsedUrl = req.parsedUrl || new OpraURL(req.url);
        if (!req.searchParams)
            Object.defineProperty(req, 'searchParams', {
                get() {
                    return req.parsedUrl.searchParams;
                }
            });
        return req;
    }
    HttpServerRequest.from = from;
})(HttpServerRequest || (HttpServerRequest = {}));
class HttpServerRequestHost {
    constructor() {
        this.basePath = '/';
    }
    get protocol() {
        const proto = this.header('X-Forwarded-Proto') || 'http';
        const index = proto.indexOf(',');
        return index !== -1
            ? proto.substring(0, index).trim()
            : proto.trim();
    }
    get secure() {
        return this.protocol === 'https';
    }
    get hostname() {
        let host = this.get('X-Forwarded-Host');
        if (!host) {
            host = this.get('Host');
        }
        else if (host.indexOf(',') !== -1) {
            // Note: X-Forwarded-Host is normally only ever a
            //       single value, but this is to be safe.
            host = host.substring(0, host.indexOf(',')).trim();
        }
        if (!host)
            return;
        // IPv6 literal support
        const offset = host[0] === '['
            ? host.indexOf(']') + 1
            : 0;
        const index = host.indexOf(':', offset);
        return index !== -1
            ? host.substring(0, index)
            : host;
    }
    get fresh() {
        const method = this.method;
        // GET or HEAD for weak freshness validation only
        if ('GET' !== method && 'HEAD' !== method)
            return false;
        const status = this.res?.statusCode;
        // 2xx or 304 as per rfc2616 14.26
        if ((status >= 200 && status < 300) || 304 === status) {
            return fresh(this.headers, {
                'etag': this.res.getHeader('ETag'),
                'last-modified': this.res.getHeader('Last-Modified')
            });
        }
        return false;
    }
    get xhr() {
        const val = this.get('X-Requested-With') || '';
        return val.toLowerCase() === 'xmlhttprequest';
    }
    header(name) {
        name = name.toLowerCase();
        const headers = this.headers;
        switch (name) {
            case 'referer':
                return headers.referer || headers.referrer;
            case 'referrer':
                return headers.referrer || headers.referer;
            default:
                return headers[name];
        }
    }
    get(name) {
        return this.header(name);
    }
    accepts(...types) {
        const accept = accepts(this);
        return accept.types.call(accept, ...types);
    }
    acceptsCharsets(...charsets) {
        const accept = accepts(this);
        return accept.charsets.call(accept, ...charsets);
    }
    acceptsEncodings(...encoding) {
        const accept = accepts(this);
        // eslint-disable-next-line prefer-spread
        return accept.encodings.apply(accept, encoding);
    }
    acceptsLanguages(...lang) {
        const accept = accepts(this);
        // eslint-disable-next-line prefer-spread
        return accept.languages.apply(accept, lang);
    }
    is(type, ...otherTypes) {
        const types = Array.isArray(type) ? type : [type];
        if (otherTypes.length)
            types.push(...otherTypes);
        const contentType = this.header('content-type');
        return contentType ? typeIs.is(contentType, types) : null;
    }
    range(size, options) {
        const range = this.header('range');
        if (!range)
            return;
        return parseRange(size, range, options);
    }
}
