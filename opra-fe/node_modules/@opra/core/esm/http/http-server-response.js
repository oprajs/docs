/*
  Some parts of this file contains codes from open source express library
  https://github.com/expressjs
 */
import contentDisposition from 'content-disposition';
import contentType from 'content-type';
import cookie from 'cookie';
import cookieSignature from 'cookie-signature';
import encodeUrl from 'encodeurl';
import mime from 'mime-types';
import path from 'path';
import { toString } from 'putil-varhelpers';
import vary from 'vary';
import { HttpStatusCode, isStream, mergePrototype } from '@opra/common';
import { HttpOutgoingMessageHost } from './impl/http-outgoing-message.host.js';
const charsetRegExp = /;\s*charset\s*=/;
function isHttpIncomingMessage(v) {
    return v && typeof v.getHeaders === 'function' && isStream(v);
}
export var HttpServerResponse;
(function (HttpServerResponse) {
    function from(instance) {
        if (!isHttpIncomingMessage(instance))
            instance = new HttpOutgoingMessageHost(instance);
        mergePrototype(instance, HttpServerResponseHost.prototype);
        return instance;
    }
    HttpServerResponse.from = from;
})(HttpServerResponse || (HttpServerResponse = {}));
class HttpServerResponseHost {
    attachment(filename) {
        if (filename)
            this.contentType(path.extname(filename));
        this.setHeader('Content-Disposition', contentDisposition(filename));
        return this;
    }
    contentType(type) {
        const ct = type.indexOf('/') === -1
            ? mime.lookup(type)
            : type;
        this.setHeader('Content-Type', ct);
        return this;
    }
    setHeader(field, val) {
        const setHeader = Object.getPrototypeOf(this).setHeader;
        if (typeof field === 'object') {
            for (const [k, v] of Object.entries(field)) {
                this.setHeader(k, v);
            }
            return this;
        }
        const fieldLower = field.toLowerCase();
        let value = Array.isArray(val)
            ? val.map(String)
            : (val ? String(val) : '');
        // add charset to content-type
        if (fieldLower === 'content-type') {
            if (Array.isArray(value)) {
                throw new TypeError('Content-Type cannot be set to an Array');
            }
            if (!charsetRegExp.test(value)) {
                const charset = mime.charsets.lookup(value.split(';')[0]);
                if (charset)
                    value += '; charset=' + charset.toLowerCase();
            }
        }
        setHeader.call(this, field, value);
        return this;
    }
    clearCookie(name, options) {
        const opts = {
            expires: new Date(1),
            path: '/',
            ...options
        };
        return this.cookie(name, '', opts);
    }
    cookie(name, value, options) {
        const opts = { ...options };
        let val = typeof value === 'object'
            ? 'j:' + JSON.stringify(value)
            : String(value);
        if (opts.signed) {
            const secret = opts.secret || this.req?.secret;
            if (!secret)
                throw new Error('"secret" required for signed cookies');
            val = 's:' + cookieSignature.sign(val, secret);
        }
        if (opts.maxAge != null) {
            const maxAge = opts.maxAge - 0;
            if (!isNaN(maxAge)) {
                opts.expires = new Date(Date.now() + maxAge);
                opts.maxAge = Math.floor(maxAge / 1000);
            }
        }
        if (opts.path == null)
            opts.path = '/';
        this.appendHeader('Set-Cookie', cookie.serialize(name, String(val), opts));
        return this;
    }
    status(code) {
        this.statusCode = code;
        return this;
    }
    sendStatus(statusCode) {
        const body = HttpStatusCode[statusCode] || String(statusCode);
        this.statusCode = statusCode;
        this.contentType('txt');
        return this.send(body);
    }
    links(links) {
        let link = this.getHeader('Link') || '';
        if (link)
            link += ', ';
        this.setHeader('Link', link +
            Object.keys(links)
                .map(rel => '<' + links[rel] + '>; rel="' + rel + '"')
                .join(', '));
        return this;
    }
    location(url) {
        let loc = url;
        // "back" is an alias for the referrer
        if (url === 'back')
            loc = this.req?.get('Referrer') || '/';
        // set location
        return this.setHeader('Location', encodeUrl(loc));
    }
    redirect(arg0, arg1) {
        const address = String(arg1 || arg0);
        const status = typeof arg0 === 'number' ? arg0 : 302;
        // Set location header
        this.location(address);
        // Respond
        this.statusCode = status;
        this.end();
    }
    send(body) {
        let chunk = body;
        let encoding;
        const req = this.req;
        let ctype = toString(this.getHeader('Content-Type'));
        if (typeof chunk !== 'string') {
            if (chunk === null)
                chunk = '';
            else if (Buffer.isBuffer(chunk)) {
                if (!ctype)
                    this.contentType('bin');
            }
            else {
                ctype = 'json';
                chunk = JSON.stringify(chunk);
            }
        }
        // write strings in utf-8
        if (typeof chunk === 'string') {
            encoding = 'utf-8';
            this.setHeader('Content-Type', setCharset(ctype || 'txt', encoding));
        }
        // populate Content-Length
        let len = 0;
        if (chunk !== undefined) {
            if (Buffer.isBuffer(chunk)) {
                // get length of Buffer
                len = chunk.length;
            }
            else if (chunk.length < 1000) {
                // just calculate length when small chunk
                len = Buffer.byteLength(chunk, encoding);
            }
            else {
                // convert chunk to Buffer and calculate
                chunk = Buffer.from(chunk, encoding);
                encoding = undefined;
                len = chunk.length;
            }
            this.setHeader('Content-Length', len);
        }
        // freshness
        if (req?.fresh)
            this.statusCode = 304;
        // strip irrelevant headers
        if (204 === this.statusCode || 304 === this.statusCode) {
            this.removeHeader('Content-Type');
            this.removeHeader('Content-Length');
            this.removeHeader('Transfer-Encoding');
            chunk = '';
        }
        // alter headers for 205
        if (this.statusCode === 205) {
            this.setHeader('Content-Length', '0');
            this.removeHeader('Transfer-Encoding');
            chunk = '';
        }
        if (req?.method === 'HEAD') {
            // skip body for HEAD
            this.end();
        }
        else {
            // respond
            if (encoding)
                this.end(chunk, encoding);
            else
                this.end(chunk);
        }
        return this;
    }
    vary(field) {
        vary(this, field);
        return this;
    }
}
function setCharset(type, charset) {
    if (!(type && charset))
        return type;
    // parse type
    const parsed = contentType.parse(type);
    // set charset
    parsed.parameters.charset = charset;
    // format type
    return contentType.format(parsed);
}
