"use strict";
/*
  This file contains code blocks from open source NodeJs project
  https://github.com/nodejs/
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpIncomingMessageHost = exports.kTrailersDistinct = exports.kTrailers = exports.kHeadersDistinct = exports.kHeaders = exports.CRLF = void 0;
const stream_1 = require("stream");
const http_parser_1 = require("@browsery/http-parser");
const common_1 = require("@opra/common");
const concat_readable_js_1 = require("../helpers/concat-readable.js");
const convert_to_headers_js_1 = require("../helpers/convert-to-headers.js");
const convert_to_raw_headers_js_1 = require("../helpers/convert-to-raw-headers.js");
exports.CRLF = Buffer.from('\r\n');
exports.kHeaders = Symbol.for('kHeaders');
exports.kHeadersDistinct = Symbol.for('kHeadersDistinct');
exports.kTrailers = Symbol.for('kTrailers');
exports.kTrailersDistinct = Symbol.for('kTrailersDistinct');
/**
 *
 * @class HttpIncomingMessageHost
 */
class HttpIncomingMessageHost extends stream_1.Duplex {
    constructor(init) {
        super();
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.complete = false;
        this.joinDuplicateHeaders = false;
        if (init) {
            this.complete = true;
            this.httpVersionMajor = init.httpVersionMajor || 1;
            this.httpVersionMinor = init.httpVersionMinor || 0;
            this.method = (init.method || 'GET').toUpperCase();
            this.url = init.url || '';
            if (init.body != null) {
                if (Buffer.isBuffer(init.body))
                    this.body = init.body;
                else if (typeof init.body === 'string')
                    this.body = Buffer.from(init.body, 'utf-8');
                else
                    this.body = Buffer.from(JSON.stringify(init.body), 'utf-8');
            }
            if (init.headers)
                this.rawHeaders = Array.isArray(init.headers) ? init.headers : (0, convert_to_raw_headers_js_1.convertToRawHeaders)(init.headers);
            if (init.trailers)
                this.rawTrailers = Array.isArray(init.trailers) ? init.trailers : (0, convert_to_raw_headers_js_1.convertToRawHeaders)(init.trailers);
            this.ip = init.ip || '';
            this.ips = init.ips || (this.ip ? [this.ip] : []);
            if (this.body && !this.headers['content-length'])
                this.headers['content-length'] = String(this.body.length);
        }
    }
    get httpVersion() {
        return this.httpVersionMajor
            ? this.httpVersionMajor + '.' + this.httpVersionMinor
            : '';
    }
    get headers() {
        if (!this[exports.kHeaders])
            this[exports.kHeaders] = (0, convert_to_headers_js_1.convertToHeaders)(this.rawHeaders, {}, this.joinDuplicateHeaders);
        return this[exports.kHeaders];
    }
    set headers(headers) {
        this[exports.kHeaders] = headers;
    }
    get headersDistinct() {
        if (!this[exports.kHeadersDistinct])
            this[exports.kHeadersDistinct] = (0, convert_to_headers_js_1.convertToHeadersDistinct)(this.rawHeaders, {});
        return this[exports.kHeadersDistinct];
    }
    get trailers() {
        if (!this[exports.kTrailers])
            this[exports.kTrailers] = (0, convert_to_headers_js_1.convertToHeaders)(this.rawTrailers, {}, this.joinDuplicateHeaders);
        return this[exports.kTrailers];
    }
    set trailers(trailers) {
        this[exports.kTrailers] = trailers;
    }
    get trailersDistinct() {
        if (!this[exports.kTrailersDistinct])
            this[exports.kTrailersDistinct] = (0, convert_to_headers_js_1.convertToHeadersDistinct)(this.rawTrailers, {});
        return this[exports.kTrailersDistinct];
    }
    _read(size) {
        if (!this.body) {
            this.push(null);
            return;
        }
        if (!this._readStream) {
            if ((0, common_1.isIterable)(this.body) || (0, common_1.isAsyncIterable)(this.body))
                this._readStream = stream_1.Readable.from(this.body);
            else if (typeof this.body === 'string') {
                this._readStream = stream_1.Readable.from(Buffer.from(this.body, 'utf-8'));
            }
            else
                this._readStream = stream_1.Readable.from(Buffer.from(JSON.stringify(this.body), 'utf-8'));
        }
        const chunk = this._readStream.read(size);
        this.push(chunk);
        // this.push(null);s
    }
    _write(chunk, encoding, callback) {
        const error = this._httpParser?.execute(chunk);
        if (error && typeof error === 'object')
            callback(error);
        else
            callback();
    }
    static from(iterable) {
        if (typeof iterable === 'object' && !((0, common_1.isIterable)(iterable) || (0, common_1.isAsyncIterable)(iterable)))
            return new HttpIncomingMessageHost(iterable);
        const msg = new HttpIncomingMessageHost();
        const parser = msg._httpParser = new http_parser_1.HTTPParser(http_parser_1.HTTPParser.REQUEST);
        let bodyChunks;
        parser[http_parser_1.HTTPParser.kOnHeadersComplete] = (info) => {
            msg.httpVersionMajor = info.versionMajor;
            msg.httpVersionMinor = info.versionMinor;
            msg.rawHeaders = info.headers;
            msg.method = http_parser_1.HTTPParser.methods[info.method];
            msg.url = info.url;
        };
        parser[http_parser_1.HTTPParser.kOnHeaders] = (trailers) => {
            msg.rawTrailers = trailers;
        };
        parser[http_parser_1.HTTPParser.kOnBody] = (chunk, offset, length) => {
            bodyChunks = bodyChunks || [];
            bodyChunks.push(chunk.subarray(offset, offset + length));
        };
        parser[http_parser_1.HTTPParser.kOnMessageComplete] = () => {
            msg.complete = true;
            if (bodyChunks)
                msg.body = Buffer.concat(bodyChunks);
        };
        const readable = (0, concat_readable_js_1.concatReadable)(stream_1.Readable.from(iterable), stream_1.Readable.from(exports.CRLF));
        msg.once('finish', () => parser.finish());
        readable.pipe(msg);
        return msg;
    }
    static async fromAsync(iterable) {
        return new Promise((resolve, reject) => {
            const msg = this.from(iterable);
            msg.once('finish', () => resolve(msg));
            msg.once('error', (error) => reject(error));
        });
    }
}
exports.HttpIncomingMessageHost = HttpIncomingMessageHost;
