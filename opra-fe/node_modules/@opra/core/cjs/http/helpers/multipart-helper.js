"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultipartIterator = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const formidable_1 = tslib_1.__importDefault(require("formidable"));
const promises_1 = tslib_1.__importDefault(require("fs/promises"));
class MultipartIterator extends events_1.EventEmitter {
    constructor(options) {
        super();
        this._cancelled = false;
        this._items = [];
        this._stack = [];
        this.setMaxListeners(1000);
        const form = this._form = (0, formidable_1.default)({
            ...options,
            filter: (part) => {
                return !this._cancelled && (!options?.filter || options.filter(part));
            }
        });
        form.once('error', () => {
            this._cancelled = true;
            if (this.listenerCount('error') > 0)
                this.emit('error');
        });
        form.on('field', (field, value) => {
            const item = { field, value };
            this._items.push(item);
            this._stack.push(item);
            this.emit('item', item);
        });
        form.on('file', (field, file) => {
            const item = { field, file };
            this._items.push(item);
            this._stack.push(item);
            this.emit('item', item);
        });
    }
    get items() {
        return this._items;
    }
    getNext() {
        if (!this._form.ended)
            this.resume();
        return new Promise((resolve, reject) => {
            if (this._stack.length)
                return resolve(this._stack.shift());
            if (this._form.ended)
                return resolve(undefined);
            this.once('item', () => resolve(this._stack.shift()));
            this.once('error', (e) => reject(e));
        });
    }
    getAll() {
        if (this._form.ended)
            return Promise.resolve([...this._items]);
        this.resume();
        return new Promise((resolve, reject) => {
            this._form.once('error', reject);
            this._form.once('end', () => {
                resolve([...this._items]);
            });
        });
    }
    cancel() {
        this._cancelled = true;
        if (this._form.req)
            this.resume();
    }
    resume() {
        if (this._form.req)
            this._form.resume();
    }
    pause() {
        if (this._form.req)
            this._form.pause();
    }
    async deleteFiles() {
        const promises = [];
        this._items
            .forEach(item => {
            if (!item.file)
                return;
            const file = item.file;
            promises.push(new Promise(resolve => {
                if (file._writeStream.closed)
                    return resolve();
                file._writeStream.once('close', resolve);
            }).then(() => {
                return promises_1.default.unlink(file.filepath);
            }).then(() => {
                return 0;
            }));
        });
        return Promise.allSettled(promises);
    }
    static async create(incoming, options) {
        const out = new MultipartIterator(options);
        await out._form.parse(incoming);
        return out;
    }
}
exports.MultipartIterator = MultipartIterator;
