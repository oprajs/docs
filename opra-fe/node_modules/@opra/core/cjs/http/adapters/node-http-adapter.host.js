"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHttpAdapterHost = void 0;
const tslib_1 = require("tslib");
const http_1 = tslib_1.__importDefault(require("http"));
const common_1 = require("@opra/common");
const http_adapter_host_js_1 = require("../http-adapter-host.js");
const http_server_request_js_1 = require("../http-server-request.js");
const http_server_response_js_1 = require("../http-server-response.js");
/**
 * @class NodeHttpAdapterHost
 */
class NodeHttpAdapterHost extends http_adapter_host_js_1.HttpAdapterHost {
    constructor() {
        super(...arguments);
        this._platform = 'http';
    }
    get basePath() {
        return this._basePath;
    }
    get server() {
        return this._server;
    }
    async close() {
        await super.close();
        if (this.server.listening)
            await new Promise((resolve, reject) => {
                this.server.close((err) => {
                    if (err)
                        return reject(err);
                    resolve();
                });
            });
    }
    async init(api, options) {
        await super.init(api, options);
        this._basePath = new common_1.OpraURLPath(options?.basePath);
        this._server = http_1.default.createServer((incomingMessage, serverResponse) => this._serverListener(incomingMessage, serverResponse));
    }
    _serverListener(incomingMessage, serverResponse) {
        const originalUrl = incomingMessage.url;
        const parsedUrl = new common_1.OpraURL(originalUrl);
        const relativePath = common_1.OpraURLPath.relative(parsedUrl.path, this.basePath);
        if (!relativePath) {
            serverResponse.statusCode = common_1.HttpStatusCode.NOT_FOUND;
            serverResponse.statusMessage = common_1.HttpStatusMessages[common_1.HttpStatusCode.NOT_FOUND];
            serverResponse.end();
            return;
        }
        parsedUrl.path = relativePath;
        incomingMessage.originalUrl = originalUrl;
        incomingMessage.baseUrl = this.basePath.toString();
        incomingMessage.parsedUrl = parsedUrl;
        Object.defineProperty(incomingMessage, 'searchParams', {
            get() {
                return incomingMessage.parsedUrl.searchParams;
            }
        });
        const req = http_server_request_js_1.HttpServerRequest.from(incomingMessage);
        const res = http_server_response_js_1.HttpServerResponse.from(serverResponse);
        this.handleHttp(req, res)
            .catch((e) => this._logger.fatal(e));
    }
    static async create(api, options) {
        const adapter = new NodeHttpAdapterHost();
        await adapter.init(api, options);
        return adapter;
    }
}
exports.NodeHttpAdapterHost = NodeHttpAdapterHost;
