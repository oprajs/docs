"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpAdapterHost = void 0;
const tslib_1 = require("tslib");
const promises_1 = tslib_1.__importDefault(require("fs/promises"));
const os_1 = tslib_1.__importDefault(require("os"));
const valgen_1 = require("valgen");
const common_1 = require("@opra/common");
const execution_context_host_js_1 = require("../execution-context.host.js");
const platform_adapter_host_js_1 = require("../platform-adapter.host.js");
const request_host_js_1 = require("../request.host.js");
const request_context_js_1 = require("../request-context.js");
const response_host_js_1 = require("../response.host.js");
const json_body_loader_js_1 = require("./helpers/json-body-loader.js");
const multipart_helper_js_1 = require("./helpers/multipart-helper.js");
/**
 *
 * @class HttpAdapterHost
 */
class HttpAdapterHost extends platform_adapter_host_js_1.PlatformAdapterHost {
    constructor() {
        super(...arguments);
        this._protocol = 'http';
        this._tempDir = os_1.default.tmpdir();
    }
    /**
     * Main http request handler
     * @param incoming
     * @param outgoing
     * @protected
     */
    async handleHttp(incoming, outgoing) {
        const context = new execution_context_host_js_1.ExecutionContextHost(this.api, this.platform, { http: { incoming, outgoing } });
        try {
            /* istanbul ignore next */
            if (!this._api)
                throw new common_1.InternalServerError(`${Object.getPrototypeOf(this).constructor.name} has not been initialized yet`);
            outgoing.setHeader(common_1.HttpHeaderCodes.X_Opra_Version, common_1.OpraSchema.SpecVersion);
            // Expose headers if cors enabled
            if (outgoing.getHeader(common_1.HttpHeaderCodes.Access_Control_Allow_Origin)) {
                // Expose X-Opra-* headers
                outgoing.appendHeader(common_1.HttpHeaderCodes.Access_Control_Expose_Headers, Object.values(common_1.HttpHeaderCodes)
                    .filter(k => k.toLowerCase().startsWith('x-opra-')));
            }
            const { parsedUrl } = incoming;
            if (!parsedUrl.path.length) {
                if (incoming.method === 'GET') {
                    outgoing.setHeader('content-type', 'application/json');
                    outgoing.end(JSON.stringify(this.api.exportSchema({ webSafe: true })));
                    return;
                }
                // Process Batch
                if (incoming.method === 'POST' && incoming.headers['content-type'] === 'multipart/mixed') {
                    // todo Process Batch
                }
                throw new common_1.BadRequestError();
            }
            let i = 0;
            let requestProcessed = false;
            const next = async () => {
                const interceptor = this._interceptors[i++];
                if (interceptor) {
                    await interceptor(context, next);
                    await next();
                }
                else if (!requestProcessed) {
                    requestProcessed = true;
                    await this.handleExecution(context);
                }
            };
            await next();
        }
        catch (error) {
            if (!outgoing.writableEnded)
                await this.sendErrorResponse(context, [error]);
        }
        finally {
            await context.emitAsync('finish');
        }
    }
    async handleExecution(executionContext) {
        // Parse incoming message and create Request object
        let request;
        try {
            request = await this.parseRequest(executionContext);
        }
        catch (e) {
            if (e instanceof common_1.OpraException)
                throw e;
            const errors = e.issues.map(issue => new common_1.BadRequestError({
                message: issue.message,
                code: 'REQUEST_VALIDATION',
                details: {
                    ...issue,
                    message: undefined
                }
            }));
            return this.sendErrorResponse(executionContext, errors);
        }
        try {
            const { outgoing } = executionContext.switchToHttp();
            const response = new response_host_js_1.ResponseHost({ http: outgoing });
            const context = request_context_js_1.RequestContext.from(executionContext, this.api, request, response);
            await this.executeRequest(context);
            await this.sendResponse(context);
        }
        catch (e) {
            if (e instanceof common_1.OpraException)
                throw e;
            if (e instanceof valgen_1.ValidationError) {
                throw new common_1.InternalServerError({
                    message: (0, common_1.translate)('error:RESPONSE_VALIDATION,'),
                    code: 'RESPONSE_VALIDATION',
                    details: e.issues
                }, e);
            }
            throw new common_1.InternalServerError(e);
        }
    }
    async parseRequest(executionContext) {
        const { incoming } = executionContext.switchToHttp();
        const parsedUrl = new common_1.OpraURL(incoming.url);
        let i = 0;
        let p;
        let resource = this.api.root;
        let request;
        // Walk through container
        while (resource instanceof common_1.Container && i < parsedUrl.path.length) {
            p = parsedUrl.path[i];
            const r = resource.resources.get(p.resource);
            if (r) {
                resource = r;
                if (resource instanceof common_1.Container) {
                    i++;
                }
                else
                    break;
            }
            else
                break;
        }
        const urlPath = i > 0 ? parsedUrl.path.slice(i) : parsedUrl.path;
        const searchParams = parsedUrl.searchParams;
        // If there is one more element in the path it may be an action
        if (resource instanceof common_1.Container) {
            if (urlPath.length === 1 && resource.actions.has(urlPath[0].resource)) {
                request = await this._parseRequestAction(executionContext, resource, urlPath, searchParams);
                if (request)
                    return request;
            }
        }
        else if (urlPath.length === 2 && resource.actions.has(urlPath[1].resource)) {
            request = await this._parseRequestAction(executionContext, resource, urlPath.slice(1), searchParams);
            if (request)
                return request;
        }
        if (resource instanceof common_1.Storage)
            request = await this._parseRequestStorage(executionContext, resource, urlPath.slice(1), searchParams);
        else if (urlPath.length === 1) { // Collection and Singleton resources should be last element in path
            if (resource instanceof common_1.Collection)
                request = await this._parseRequestCollection(executionContext, resource, urlPath, searchParams);
            else if (resource instanceof common_1.Singleton)
                request = await this._parseRequestSingleton(executionContext, resource, urlPath, searchParams);
        }
        if (request)
            return request;
        const path = parsedUrl.path.toString();
        throw new common_1.BadRequestError({
            message: 'No resource or endpoint found at ' + path,
            details: { path }
        });
    }
    async _parseRequestAction(executionContext, resource, urlPath, searchParams) {
        const p = urlPath[0];
        const { controller, endpoint, handler } = await this.getActionHandler(resource, p.resource);
        const { incoming } = executionContext.switchToHttp();
        const contentId = incoming.headers['content-id'];
        const params = this.parseParameters(endpoint.parameters, searchParams);
        return new request_host_js_1.RequestHost({
            endpoint,
            controller,
            handler,
            http: incoming,
            contentId,
            params
        });
    }
    async _parseRequestCollection(executionContext, resource, urlPath, searchParams) {
        const { incoming } = executionContext.switchToHttp();
        if ((incoming.method === 'POST' || incoming.method === 'PATCH') && !incoming.is('json'))
            throw new common_1.BadRequestError({ message: 'Unsupported Content-Type' });
        const contentId = incoming.headers['content-id'];
        const p = urlPath[0];
        switch (incoming.method) {
            case 'POST': {
                if (p.key == null) {
                    const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'create');
                    const jsonReader = (0, json_body_loader_js_1.jsonBodyLoader)({
                        limit: endpoint.options.inputMaxContentSize
                    }, endpoint);
                    let data = await jsonReader(incoming);
                    data = endpoint.decodeInput(data, { coerce: true });
                    const params = this.parseParameters(endpoint.parameters, searchParams);
                    return new request_host_js_1.RequestHost({
                        endpoint,
                        controller,
                        handler,
                        http: incoming,
                        contentId,
                        data,
                        params: {
                            ...params,
                            pick: params.pick && resource.normalizeFieldNames(params.pick),
                            omit: params.omit && resource.normalizeFieldNames(params.omit),
                            include: params.include && resource.normalizeFieldNames(params.include)
                        }
                    });
                }
                break;
            }
            case 'DELETE': {
                if (p.key != null) {
                    const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'delete');
                    const params = this.parseParameters(endpoint.parameters, searchParams);
                    return new request_host_js_1.RequestHost({
                        endpoint,
                        controller,
                        handler,
                        http: incoming,
                        contentId,
                        key: resource.parseKeyValue(p.key),
                        params
                    });
                }
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'deleteMany');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    params: {
                        ...params,
                        filter: params.filter && resource.normalizeFilter(params.filter)
                    }
                });
            }
            case 'GET': {
                if (p.key != null) {
                    const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'get');
                    const params = this.parseParameters(endpoint.parameters, searchParams);
                    return new request_host_js_1.RequestHost({
                        endpoint,
                        controller,
                        handler,
                        http: incoming,
                        contentId,
                        key: resource.parseKeyValue(p.key),
                        params: {
                            ...params,
                            pick: params.pick && resource.normalizeFieldNames(params.pick),
                            omit: params.omit && resource.normalizeFieldNames(params.omit),
                            include: params.include && resource.normalizeFieldNames(params.include)
                        }
                    });
                }
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'findMany');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    params: {
                        ...params,
                        pick: params.pick && resource.normalizeFieldNames(params.pick),
                        omit: params.omit && resource.normalizeFieldNames(params.omit),
                        include: params.include && resource.normalizeFieldNames(params.include),
                        sort: params.sort && resource.normalizeSortFields(params.sort),
                        filter: params.filter && resource.normalizeFilter(params.filter)
                    }
                });
            }
            case 'PATCH': {
                if (p.key != null) {
                    const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'update');
                    const jsonReader = (0, json_body_loader_js_1.jsonBodyLoader)({
                        limit: endpoint.options.inputMaxContentSize
                    }, endpoint);
                    let data = await jsonReader(incoming);
                    data = endpoint.decodeInput(data, { coerce: true, partial: true });
                    const params = this.parseParameters(endpoint.parameters, searchParams);
                    return new request_host_js_1.RequestHost({
                        endpoint,
                        controller,
                        handler,
                        http: incoming,
                        contentId,
                        key: resource.parseKeyValue(p.key),
                        data,
                        params: {
                            ...params,
                            pick: params.pick && resource.normalizeFieldNames(params.pick),
                            omit: params.omit && resource.normalizeFieldNames(params.omit),
                            include: params.include && resource.normalizeFieldNames(params.include),
                        }
                    });
                }
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'updateMany');
                const jsonReader = (0, json_body_loader_js_1.jsonBodyLoader)({
                    limit: endpoint.options.inputMaxContentSize
                }, endpoint);
                let data = await jsonReader(incoming);
                data = endpoint.decodeInput(data, { coerce: true, partial: true });
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    data,
                    params: {
                        ...params,
                        filter: params.filter && resource.normalizeFilter(params.filter)
                    }
                });
            }
        }
        throw new common_1.MethodNotAllowedError({
            message: `Collection resource doesn't accept http "${incoming.method}" method`
        });
    }
    async _parseRequestSingleton(executionContext, resource, urlPath, searchParams) {
        const { incoming } = executionContext.switchToHttp();
        if ((incoming.method === 'POST' || incoming.method === 'PATCH') && !incoming.is('json'))
            throw new common_1.BadRequestError({ message: 'Unsupported Content-Type' });
        const contentId = incoming.headers['content-id'];
        switch (incoming.method) {
            case 'POST': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'create');
                const jsonReader = (0, json_body_loader_js_1.jsonBodyLoader)({
                    limit: endpoint.options.inputMaxContentSize
                }, endpoint);
                let data = await jsonReader(incoming);
                data = endpoint.decodeInput(data, { coerce: true });
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    data,
                    params: {
                        ...params,
                        pick: params.pick && resource.normalizeFieldNames(params.pick),
                        omit: params.omit && resource.normalizeFieldNames(params.omit),
                        include: params.include && resource.normalizeFieldNames(params.include)
                    }
                });
            }
            case 'DELETE': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'delete');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    params
                });
            }
            case 'GET': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'get');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    params: {
                        ...params,
                        pick: params.pick && resource.normalizeFieldNames(params.pick),
                        omit: params.omit && resource.normalizeFieldNames(params.omit),
                        include: params.include && resource.normalizeFieldNames(params.include)
                    }
                });
            }
            case 'PATCH': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'update');
                const jsonReader = (0, json_body_loader_js_1.jsonBodyLoader)({
                    limit: endpoint.options.inputMaxContentSize
                }, endpoint);
                let data = await jsonReader(incoming);
                data = endpoint.decodeInput(data, { coerce: true, partial: true });
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    data,
                    params: {
                        ...params,
                        pick: params.pick && resource.normalizeFieldNames(params.pick),
                        omit: params.omit && resource.normalizeFieldNames(params.omit),
                        include: params.include && resource.normalizeFieldNames(params.include),
                    }
                });
            }
        }
        throw new common_1.MethodNotAllowedError({
            message: `Singleton resource doesn't accept http "${incoming.method}" method`
        });
    }
    async _parseRequestStorage(executionContext, resource, urlPath, searchParams) {
        const { incoming } = executionContext.switchToHttp();
        const contentId = incoming.headers['content-id'];
        switch (incoming.method) {
            case 'GET': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'get');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    path: urlPath.toString().substring(1),
                    params
                });
            }
            case 'DELETE': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'delete');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    path: urlPath.toString().substring(1),
                    params
                });
            }
            case 'POST': {
                const { controller, endpoint, handler } = await this.getOperationHandler(resource, 'post');
                const params = this.parseParameters(endpoint.parameters, searchParams);
                await promises_1.default.mkdir(this._tempDir, { recursive: true });
                const multipartIterator = await multipart_helper_js_1.MultipartIterator.create(incoming, {
                    ...endpoint.options,
                    filename: () => this.serviceName + '_p' + process.pid +
                        't' + String(Date.now()).substring(8) + 'r' + (0, common_1.uid)(12)
                });
                multipartIterator.pause();
                // Add an hook to clean up files after request finished
                executionContext.on('finish', async () => {
                    multipartIterator.cancel();
                    await multipartIterator.deleteFiles().catch(() => void 0);
                });
                return new request_host_js_1.RequestHost({
                    endpoint,
                    controller,
                    handler,
                    http: incoming,
                    contentId,
                    parts: multipartIterator,
                    path: urlPath.toString().substring(1),
                    params
                });
            }
        }
        throw new common_1.MethodNotAllowedError({
            message: `Storage resource doesn't accept http "${incoming.method}" method`
        });
    }
    parseParameters(paramDefs, searchParams) {
        const out = {};
        const onFail = (issue) => {
            issue.message = `Parameter parse error. ` + issue.message;
            issue.location = '@parameters';
            return issue;
        };
        // Parse known parameters
        for (const [k, prm] of paramDefs.entries()) {
            const decode = prm.getDecoder();
            let v = searchParams?.getAll(k);
            try {
                if (!v.length && prm.default != null)
                    v = [prm.default];
                if (!prm.isArray) {
                    v = v[0];
                    v = decode(v, { coerce: true, label: k, onFail });
                }
                else {
                    v = v.map(x => decode(x, { coerce: true, label: k })).flat();
                    if (!v.length)
                        v = undefined;
                }
                if (v !== undefined)
                    out[k] = v;
            }
            catch (e) {
                e.message = `Error parsing parameter ${k}. ` + e.message;
                throw e;
            }
        }
        // Add unknown parameters
        if (searchParams) {
            for (const k of searchParams.keys()) {
                let v = searchParams.getAll(k);
                if (v.length < 2)
                    v = v[0];
                if (!paramDefs.has(k))
                    out[k] = v;
            }
        }
        return out;
    }
    async executeRequest(context) {
        const { request } = context;
        const { response } = context;
        const { endpoint, resource, handler } = request;
        // Call endpoint handler method
        let value;
        try {
            value = await handler.call(request.controller, context);
            if (response.value == null)
                response.value = value;
            // Normalize response value
            if (endpoint.kind === 'operation') {
                if (resource instanceof common_1.Collection || resource instanceof common_1.Singleton || resource instanceof common_1.Storage) {
                    const operationName = endpoint.name;
                    if (operationName === 'delete' || operationName === 'deleteMany' || operationName === 'updateMany') {
                        let affected = 0;
                        if (typeof value === 'number')
                            affected = value;
                        else if (typeof value === 'boolean')
                            affected = value ? 1 : 0;
                        else if (typeof value === 'object')
                            affected = value.affected || value.affectedRows ||
                                (operationName === 'updateMany' ? value.updated : value.deleted);
                        response.value = affected;
                        return;
                    }
                    if (resource instanceof common_1.Collection || resource instanceof common_1.Singleton) {
                        // "get" and "update" endpoints must return the entity instance, otherwise it means resource not found
                        if (value == null && (operationName === 'get' || operationName === 'update'))
                            throw new common_1.ResourceNotAvailableError(resource.name, request.key);
                        // "findMany" endpoint should return array of entity instances
                        if (operationName === 'findMany')
                            value = (value == null ? [] : Array.isArray(value) ? value : [value]);
                        else
                            value = value == null ? {} : Array.isArray(value) ? value[0] : value;
                    }
                    value = endpoint.encodeReturning(value, { coerce: true });
                    response.value = value;
                    return;
                }
            }
            if (response.value)
                response.value = endpoint.encodeReturning(response.value, { coerce: true });
        }
        catch (error) {
            response.errors.push(error);
        }
    }
    async sendResponse(context) {
        const { request, response } = context;
        const { endpoint, resource } = request;
        const outgoing = response.switchToHttp();
        if (response.errors?.length || (outgoing.statusCode >= 400 && outgoing.statusCode <= 599))
            return this.sendErrorResponse(context, response.errors || []);
        // if response redirected we do not send any response
        if (outgoing.statusCode >= 300 && outgoing.statusCode < 400) {
            outgoing.end();
            return;
        }
        let contentType = String(outgoing.getHeader('content-type') || '');
        let returnType = endpoint.returnType;
        if (endpoint.kind === 'action' && !contentType && endpoint.returnMime && response.value) {
            contentType = endpoint.returnMime;
            outgoing.setHeader('Content-Type', contentType);
        }
        // OperationResult response
        if ((returnType || endpoint.kind === 'operation') &&
            !(resource instanceof common_1.Storage && endpoint.name === 'get')) {
            const incoming = context.switchToHttp().incoming;
            const apiUrl = new common_1.OpraURL(incoming.baseUrl, incoming.protocol + '://' + incoming.get('host')).toString();
            const body = new common_1.OperationResult({
                context: '',
                contextUrl: ''
            });
            const operationName = endpoint.kind === 'operation' ? endpoint.name : '';
            if (operationName === 'delete' || operationName === 'deleteMany' || operationName === 'updateMany') {
                body.affected = response.value;
                returnType = undefined;
            }
            else {
                outgoing.statusCode = outgoing.statusCode || common_1.HttpStatusCode.OK;
                if (operationName === 'create')
                    outgoing.statusCode = 201;
                if (operationName === 'update' || operationName === 'create') {
                    body.affected = response.value ? 1 : 0;
                }
                if (operationName === 'findMany') {
                    body.count = response.value.length;
                    body.totalMatches = response.totalMatches;
                }
            }
            if (returnType) {
                if (response.value == null)
                    throw new common_1.InternalServerError(`"${request.endpoint.name}" endpoint should return value`);
                if (!returnType.isEmbedded) {
                    const ns = this.api.getDataTypeNs(returnType);
                    // const isOpraSpec = returnType.document.url?.startsWith('https://oprajs.com/spec/v1.0')
                    body.type = (ns ? ns + ':' : '') + returnType.name;
                    body.typeUrl =
                        (ns
                            ? new common_1.OpraURL('/#/types/' + returnType.name, returnType.document.url || 'http://tempuri.org').toString()
                            : apiUrl + '/#/types/' + returnType.name);
                }
                else
                    body.typeUrl = body.contextUrl + '/type';
                if (response.value instanceof common_1.OperationResult) {
                    Object.assign(body, response.value);
                }
                else
                    body.payload = response.value;
                body.payload = this.i18n.deep(body.payload);
            }
            body.context = endpoint.getFullPath(false);
            body.contextUrl = apiUrl + '/#' + endpoint.getFullPath(true);
            outgoing.setHeader(common_1.HttpHeaderCodes.Content_Type, 'application/opra+json; charset=utf-8');
            outgoing.send(JSON.stringify(body));
            outgoing.end();
            return;
        }
        outgoing.statusCode = outgoing.statusCode || common_1.HttpStatusCode.OK;
        if (response.value != null) {
            if (typeof response.value === 'string') {
                if (!contentType)
                    outgoing.setHeader('content-type', 'text/plain');
                outgoing.send(response.value);
            }
            else if (Buffer.isBuffer(response.value) || (0, common_1.isReadable)(response.value)) {
                if (!contentType)
                    outgoing.setHeader('content-type', 'application/octet-stream');
                outgoing.send(response.value);
            }
            else {
                outgoing.setHeader('content-type', 'application/json; charset=utf-8');
                outgoing.send(JSON.stringify(response.value));
            }
        }
        outgoing.end();
    }
    async sendErrorResponse(context, errors) {
        const { outgoing } = context.switchToHttp();
        if (outgoing.headersSent) {
            outgoing.end();
            return;
        }
        if (!errors.length)
            errors.push((0, common_1.wrapException)({ status: outgoing.statusCode || 500 }));
        errors.forEach(x => {
            if (x instanceof common_1.OpraException) {
                switch (x.severity) {
                    case "fatal":
                        this._logger.fatal(x);
                        break;
                    case "warning":
                        this._logger.warn(x);
                        break;
                    default:
                        this._logger.error(x);
                }
            }
            else
                this._logger.fatal(x);
        });
        const wrappedErrors = errors.map(common_1.wrapException);
        // Sort errors from fatal to info
        wrappedErrors.sort((a, b) => {
            const i = common_1.IssueSeverity.Keys.indexOf(a.severity) - common_1.IssueSeverity.Keys.indexOf(b.severity);
            if (i === 0)
                return b.status - a.status;
            return i;
        });
        let status = outgoing.statusCode || 0;
        if (!status || status < Number(common_1.HttpStatusCode.BAD_REQUEST)) {
            status = wrappedErrors[0].status;
            if (status < Number(common_1.HttpStatusCode.BAD_REQUEST))
                status = common_1.HttpStatusCode.INTERNAL_SERVER_ERROR;
        }
        outgoing.statusCode = status;
        const body = new common_1.OperationResult({
            errors: wrappedErrors.map(x => this._i18n.deep(x.toJSON()))
        });
        outgoing.setHeader(common_1.HttpHeaderCodes.Content_Type, 'application/opra+json; charset=utf-8');
        outgoing.setHeader(common_1.HttpHeaderCodes.Cache_Control, 'no-cache');
        outgoing.setHeader(common_1.HttpHeaderCodes.Pragma, 'no-cache');
        outgoing.setHeader(common_1.HttpHeaderCodes.Expires, '-1');
        outgoing.setHeader(common_1.HttpHeaderCodes.X_Opra_Version, common_1.OpraSchema.SpecVersion);
        outgoing.send(JSON.stringify(body));
        outgoing.end();
    }
}
exports.HttpAdapterHost = HttpAdapterHost;
