"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const tslib_1 = require("tslib");
const antlr4_1 = require("@browsery/antlr4");
const OpraFilterLexer_js_1 = tslib_1.__importDefault(require("./antlr/OpraFilterLexer.js"));
const OpraFilterParser_js_1 = tslib_1.__importDefault(require("./antlr/OpraFilterParser.js"));
const errors_js_1 = require("./errors.js");
const filter_tree_visitor_js_1 = require("./filter-tree-visitor.js");
const opra_error_listener_js_1 = require("./opra-error-listener.js");
function parse(text, visitor) {
    const chars = new antlr4_1.CharStream(text);
    const lexer = new OpraFilterLexer_js_1.default(chars);
    const tokenStream = new antlr4_1.CommonTokenStream(lexer);
    const parser = new OpraFilterParser_js_1.default(tokenStream);
    parser.buildParseTrees = true;
    const errors = [];
    const errorListener = new opra_error_listener_js_1.OpraErrorListener(errors);
    lexer.removeErrorListeners();
    lexer.addErrorListener(errorListener);
    parser.removeErrorListeners();
    parser.addErrorListener(errorListener);
    const tree = parser.root();
    if (errors.length) {
        const errMsgs = [];
        for (const err of errors) {
            errMsgs.push(err.message +
                (text.includes('\n')
                    ? (' at ' + 'line: ' + err.line + ' column: ' + err.column)
                    : (' at ' + ' column: ' + err.column)));
        }
        const e = new errors_js_1.SyntaxError(errMsgs.join('\n'));
        e.errors = errors;
        throw e;
    }
    visitor = visitor || new filter_tree_visitor_js_1.FilterTreeVisitor();
    return visitor.visit(tree);
}
exports.parse = parse;
