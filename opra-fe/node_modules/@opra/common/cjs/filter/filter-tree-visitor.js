"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterTreeVisitor = void 0;
const tslib_1 = require("tslib");
const antlr4_1 = tslib_1.__importDefault(require("@browsery/antlr4"));
const OpraFilterParser_js_1 = require("./antlr/OpraFilterParser.js");
const index_js_1 = require("./ast/index.js");
const external_constant_js_1 = require("./ast/terms/external-constant.js");
const utils_js_1 = require("./utils.js");
// Fix: antlr4 d.ts files are invalid
const ParseTreeVisitor = antlr4_1.default.tree.ParseTreeVisitor;
class FilterTreeVisitor extends ParseTreeVisitor {
    constructor(options) {
        super();
        this._timeZone = options?.timeZone;
    }
    visitChildren(node) {
        const result = super.visitChildren(node);
        if (Array.isArray(result) && result.length < 2)
            return result[0];
        return result ?? node.getText();
    }
    defaultResult() {
        return undefined;
    }
    visitRoot(ctx) {
        return this.visit(ctx.expression());
    }
    visitParenthesizedExpression(ctx) {
        const expression = this.visit(ctx.parenthesizedItem());
        return new index_js_1.ParenthesizedExpression(expression);
    }
    visitParenthesizedItem(ctx) {
        return this.visit(ctx.expression());
    }
    visitNegativeExpression(ctx) {
        const expression = this.visit(ctx.expression());
        return new index_js_1.NegativeExpression(expression);
    }
    visitComparisonExpression(ctx) {
        return new index_js_1.ComparisonExpression({
            op: ctx.comparisonOperator().getText(),
            left: this.visit(ctx.comparisonLeft()),
            right: this.visit(ctx.comparisonRight())
        });
    }
    visitLogicalExpression(ctx) {
        const items = [];
        const wrapChildren = (arr, op) => {
            for (const c of arr) {
                if (c instanceof OpraFilterParser_js_1.LogicalExpressionContext && c.logicalOperator().getText() === op) {
                    wrapChildren(c.expression_list(), c.logicalOperator().getText());
                    continue;
                }
                const o = this.visit(c);
                items.push(o);
            }
        };
        wrapChildren(ctx.expression_list(), ctx.logicalOperator().getText());
        return new index_js_1.LogicalExpression({
            op: ctx.logicalOperator().getText(),
            items
        });
    }
    visitQualifiedIdentifier(ctx) {
        return new index_js_1.QualifiedIdentifier(ctx.getText());
    }
    visitExternalConstant(ctx) {
        return new external_constant_js_1.ExternalConstant(ctx.identifier().getText());
    }
    visitNullLiteral() {
        return new index_js_1.NullLiteral();
    }
    visitBooleanLiteral(ctx) {
        return new index_js_1.BooleanLiteral(ctx.getText() === 'true');
    }
    visitNumberLiteral(ctx) {
        return new index_js_1.NumberLiteral(ctx.getText());
    }
    visitStringLiteral(ctx) {
        return new index_js_1.StringLiteral((0, utils_js_1.unquoteFilterString)(ctx.getText()));
    }
    visitInfinityLiteral() {
        return new index_js_1.NumberLiteral(Infinity);
    }
    visitDateLiteral(ctx) {
        return new index_js_1.DateLiteral((0, utils_js_1.unquoteFilterString)(ctx.getText()));
    }
    visitDateTimeLiteral(ctx) {
        return new index_js_1.DateLiteral((0, utils_js_1.unquoteFilterString)(ctx.getText()));
    }
    visitTimeLiteral(ctx) {
        return new index_js_1.TimeLiteral((0, utils_js_1.unquoteFilterString)(ctx.getText()));
    }
    visitArrayValue(ctx) {
        return new index_js_1.ArrayExpression(ctx.value_list().map(child => this.visit(child)));
    }
}
exports.FilterTreeVisitor = FilterTreeVisitor;
