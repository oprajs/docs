"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$arithmetic = exports.$paren = exports.$notILike = exports.$ilike = exports.$notLike = exports.$like = exports.$notIn = exports.$in = exports.$lte = exports.$lt = exports.$gte = exports.$gt = exports.$ne = exports.$eq = exports.$field = exports.$array = exports.$number = exports.$time = exports.$date = exports.$and = exports.$or = void 0;
const index_js_1 = require("./ast/index.js");
function $or(...items) {
    return new index_js_1.LogicalExpression({ op: 'or', items });
}
exports.$or = $or;
function $and(...items) {
    return new index_js_1.LogicalExpression({ op: 'and', items });
}
exports.$and = $and;
function $date(v) {
    return new index_js_1.DateLiteral(v);
}
exports.$date = $date;
function $time(v) {
    return new index_js_1.TimeLiteral(v);
}
exports.$time = $time;
function $number(v) {
    return new index_js_1.NumberLiteral(v);
}
exports.$number = $number;
function $array(...items) {
    return new index_js_1.ArrayExpression(items.map(wrapEntryValue));
}
exports.$array = $array;
function $field(v) {
    return new index_js_1.QualifiedIdentifier(v);
}
exports.$field = $field;
function $eq(left, right) {
    return comparisonExpression('=', left, right);
}
exports.$eq = $eq;
function $ne(left, right) {
    return comparisonExpression('!=', left, right);
}
exports.$ne = $ne;
function $gt(left, right) {
    return comparisonExpression('>', left, right);
}
exports.$gt = $gt;
function $gte(left, right) {
    return comparisonExpression('>=', left, right);
}
exports.$gte = $gte;
function $lt(left, right) {
    return comparisonExpression('<', left, right);
}
exports.$lt = $lt;
function $lte(left, right) {
    return comparisonExpression('<=', left, right);
}
exports.$lte = $lte;
function $in(left, right) {
    return comparisonExpression('in', left, right);
}
exports.$in = $in;
function $notIn(left, right) {
    return comparisonExpression('!in', left, right);
}
exports.$notIn = $notIn;
function $like(left, right) {
    return comparisonExpression('like', left, right);
}
exports.$like = $like;
function $notLike(left, right) {
    return comparisonExpression('!like', left, right);
}
exports.$notLike = $notLike;
function $ilike(left, right) {
    return comparisonExpression('ilike', left, right);
}
exports.$ilike = $ilike;
function $notILike(left, right) {
    return comparisonExpression('!ilike', left, right);
}
exports.$notILike = $notILike;
function $paren(expression) {
    return new index_js_1.ParenthesizedExpression(expression);
}
exports.$paren = $paren;
function $arithmetic(n) {
    const exp = new index_js_1.ArithmeticExpression();
    exp.add = (expression) => {
        exp.append('+', _wrapEntryValue(expression));
        return exp;
    };
    exp.sub = (expression) => {
        exp.append('-', _wrapEntryValue(expression));
        return exp;
    };
    exp.mul = (expression) => {
        exp.append('*', _wrapEntryValue(expression));
        return exp;
    };
    exp.div = (expression) => {
        exp.append('/', _wrapEntryValue(expression));
        return exp;
    };
    exp.append('+', wrapEntryValue(n));
    return exp;
}
exports.$arithmetic = $arithmetic;
function comparisonExpression(op, left, right) {
    const lex = wrapEntryValue(left);
    const rex = wrapEntryValue(right);
    return new index_js_1.ComparisonExpression({ op, left: lex, right: rex });
}
const wrapEntryValue = (v) => {
    return Array.isArray(v)
        ? $array(...v.map(_wrapEntryValue))
        : _wrapEntryValue(v);
};
const _wrapEntryValue = (v) => {
    if (v instanceof index_js_1.Expression)
        return v;
    if (typeof v === 'boolean')
        return new index_js_1.BooleanLiteral(v);
    if (typeof v === 'number' || typeof v === 'bigint')
        return new index_js_1.NumberLiteral(v);
    if (v == null)
        return new index_js_1.NullLiteral();
    if (v instanceof Date)
        return new index_js_1.DateLiteral(v);
    return new index_js_1.StringLiteral('' + v);
};
