"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeDocumentFactory = void 0;
const valgen_1 = require("valgen");
const index_js_1 = require("../../helpers/index.js");
const index_js_2 = require("../../schema/index.js");
const constants_js_1 = require("../constants.js");
const index_js_3 = require("../data-type/builtin/index.js");
const complex_type_js_1 = require("../data-type/complex-type.js");
const enum_type_js_1 = require("../data-type/enum-type.js");
const mapped_type_js_1 = require("../data-type/mapped-type.js");
const mixin_type_js_1 = require("../data-type/mixin-type.js");
const simple_type_js_1 = require("../data-type/simple-type.js");
const type_document_js_1 = require("../type-document.js");
/**
 * @class TypeDocumentFactory
 */
class TypeDocumentFactory {
    constructor() {
        this.typeQueue = new index_js_1.ResponsiveMap();
        this.circularRefs = new Map();
        this.curPath = [];
        this.cache = new Map();
    }
    /**
     * Creates ApiDocument instance from given schema object
     */
    static async createDocument(init) {
        const factory = new TypeDocumentFactory();
        const document = factory.document = new type_document_js_1.TypeDocument();
        await factory.initDocument(init);
        return document;
    }
    /**
     * Downloads schema from the given URL and creates the document instance   * @param url
     */
    static async createDocumentFromUrl(url) {
        const factory = new TypeDocumentFactory();
        const document = factory.document = new type_document_js_1.TypeDocument();
        await factory.initDocumentFromUrl(url);
        return document;
    }
    async initDocument(init) {
        init.version = init.version || index_js_2.OpraSchema.SpecVersion;
        this.document.url = init.url;
        if (init.info)
            Object.assign(this.document.info, init.info);
        if (!init?.noBuiltinTypes) {
            const builtinDocument = await this.createBuiltinTypeDocument();
            this.document.references.set('opra', builtinDocument);
        }
        if (init.references)
            await this.addReferences(init.references);
        if (init.types) {
            this.curPath.push('Types->');
            // Add type sources into typeQueue
            if (Array.isArray(init.types)) {
                let i = 0;
                for (const thunk of init.types) {
                    const metadata = Reflect.getMetadata(constants_js_1.DATATYPE_METADATA, thunk) || thunk[constants_js_1.DATATYPE_METADATA];
                    if (!(metadata && metadata.name))
                        throw new TypeError(`Metadata information not found at types[${i++}] "${String(thunk)}"`);
                    this.typeQueue.set(metadata.name, thunk);
                }
            }
            else
                for (const [name, schema] of Object.entries(init.types)) {
                    this.typeQueue.set(name, { ...schema, name });
                }
            // Create type instances
            for (const thunk of this.typeQueue.values()) {
                await this.importDataType(thunk);
            }
            this.document.types.sort();
            this.curPath.pop();
        }
        this.document.invalidate();
        return this.document;
    }
    async initDocumentFromUrl(url) {
        const resp = await fetch(url, { method: 'GET' });
        const init = await resp.json();
        if (!init)
            throw new TypeError(`Invalid response returned from url: ${url}`);
        return await this.initDocument({ ...init, url });
    }
    async createBuiltinTypeDocument() {
        const init = {
            version: index_js_2.OpraSchema.SpecVersion,
            url: 'https://oprajs.com/spec/v1.0',
            info: {
                version: index_js_2.OpraSchema.SpecVersion,
                title: 'Opra built-in types',
                license: {
                    url: 'https://github.com/oprajs/opra/blob/main/LICENSE',
                    name: 'MIT'
                }
            },
            types: [index_js_3.AnyType, index_js_3.Base64Type, index_js_3.BigintType, index_js_3.BooleanType,
                index_js_3.DateType, index_js_3.EmailType, index_js_3.IntegerType, index_js_3.NullType, index_js_3.NumberType, index_js_3.ObjectIdType,
                index_js_3.ObjectType, index_js_3.ApproxDateType, index_js_3.ApproxDatetimeType,
                index_js_3.StringType, index_js_3.DatetimeType, index_js_3.TimeType, index_js_3.UrlType, index_js_3.UuidType
            ]
        };
        const factory = new TypeDocumentFactory();
        factory.document = new type_document_js_1.TypeDocument();
        return await factory.initDocument({ ...init, noBuiltinTypes: true });
    }
    async addReferences(references) {
        const { document } = this;
        let ns;
        let r;
        for ([ns, r] of Object.entries(references)) {
            r = await r;
            if (typeof r === 'string') {
                document.references.set(ns, await this.initDocumentFromUrl(r));
            }
            else if (r instanceof type_document_js_1.TypeDocument)
                document.references.set(ns, r);
            else if (typeof r === 'object') {
                document.references.set(ns, await this.initDocument(r));
            }
            else
                throw new TypeError(`Invalid document reference (${ns}) in schema`);
        }
    }
    async importDataType(thunk) {
        thunk = await (0, index_js_1.resolveThunk)(thunk);
        let name = '';
        // let schema: OpraSchema.DataType | undefined;
        let ctor;
        if (typeof thunk === 'string') {
            name = thunk;
            thunk = this.typeQueue.get(name);
        }
        let initArguments;
        if (typeof thunk === 'function') {
            const metadata = Reflect.getMetadata(constants_js_1.DATATYPE_METADATA, thunk);
            if (!metadata) {
                // Check if is an internal type class like String, Number etc
                const dataType = this.document.getDataType(thunk, true);
                if (dataType)
                    return dataType;
                throw new TypeError(`Class "${thunk.name}" doesn't have a valid DataType metadata`);
            }
            name = metadata.embedded ? undefined : metadata.name;
            initArguments = (0, index_js_1.cloneObject)(metadata);
            ctor = thunk;
        }
        else if (typeof thunk === 'object') {
            if (index_js_2.OpraSchema.isDataType(thunk)) {
                name = thunk.name;
                ctor = thunk.ctor || ctor;
                initArguments = (0, index_js_1.cloneObject)(thunk);
            }
            else {
                // It should be an enum object
                const metadata = thunk[constants_js_1.DATATYPE_METADATA];
                if (!metadata)
                    throw new TypeError(`No EnumType metadata found for object ${JSON.stringify(thunk).substring(0, 20)}...`);
                name = metadata.embedded ? undefined : metadata.name;
                initArguments = (0, index_js_1.cloneObject)(metadata);
                initArguments.enumObject = thunk;
            }
        }
        ctor = ctor ?? (initArguments && ((0, index_js_1.isConstructor)(initArguments.ctor)) ? initArguments.ctor : undefined);
        if (name) {
            if (this.circularRefs.has(name.toLowerCase()))
                throw new TypeError('Circular reference detected');
            const dataType = this.document.getDataType(name, true);
            if (dataType)
                return dataType;
            this.curPath.push('/' + name);
            this.circularRefs.set(name, 1);
        }
        if (ctor) {
            if (this.circularRefs.has(ctor))
                throw new TypeError('Circular reference detected');
            const dataType = this.document.getDataType(ctor, true);
            if (dataType)
                return dataType;
            this.circularRefs.set(ctor, 1);
        }
        try {
            if (!initArguments)
                throw new TypeError(`No DataType schema determined`);
            // Create an empty DataType instance and add in to document.
            // This will help us for circular dependent data types
            const instance = this.createDataTypeInstance(initArguments.kind, name);
            if (name)
                this.document.types.set(name, instance);
            await this.prepareDataTypeInitArguments(initArguments, ctor);
            if (initArguments.kind === 'ComplexType') {
                if (typeof initArguments.additionalFields === 'function')
                    initArguments.additionalFields = await this.importDataType(initArguments.additionalFields);
                complex_type_js_1.ComplexType.apply(instance, [this.document, initArguments]);
            }
            else if (initArguments.kind === 'SimpleType')
                simple_type_js_1.SimpleType.apply(instance, [this.document, initArguments]);
            else if (initArguments.kind === 'EnumType')
                enum_type_js_1.EnumType.apply(instance, [this.document, initArguments]);
            else if (initArguments.kind === 'MappedType')
                mapped_type_js_1.MappedType.apply(instance, [this.document, initArguments]);
            else if (initArguments.kind === 'MixinType')
                mixin_type_js_1.MixinType.apply(instance, [this.document, initArguments]);
            else
                throw new TypeError(`Invalid data type schema: ${String(initArguments)}`);
            return instance;
        }
        finally {
            if (name) {
                this.curPath.pop();
                this.circularRefs.delete(name.toLowerCase());
            }
            if (ctor)
                this.circularRefs.delete(ctor);
        }
    }
    async prepareDataTypeInitArguments(schema, ctor) {
        const initArguments = schema;
        // Import extending class first
        if (initArguments.kind === 'SimpleType' || initArguments.kind === 'ComplexType' ||
            initArguments.kind === 'EnumType') {
            if (ctor) {
                const baseClass = Object.getPrototypeOf(ctor.prototype).constructor;
                const baseMeta = Reflect.getMetadata(constants_js_1.DATATYPE_METADATA, baseClass);
                if (baseMeta) {
                    initArguments.base = await this.importDataType(baseClass);
                }
            }
            else if (initArguments.base) {
                initArguments.base = await this.importDataType(initArguments.base);
            }
        }
        if (initArguments.kind === 'SimpleType' && ctor) {
            if (typeof ctor.prototype.decode === 'function')
                initArguments.decoder = initArguments.name
                    ? (0, valgen_1.validator)(initArguments.name, ctor.prototype.decode) : (0, valgen_1.validator)(ctor.prototype.decode);
            if (typeof ctor.prototype.encode === 'function')
                initArguments.decoder = initArguments.name
                    ? (0, valgen_1.validator)(initArguments.name, ctor.prototype.encode) : (0, valgen_1.validator)(ctor.prototype.encode);
            return;
        }
        if (initArguments.kind === 'ComplexType') {
            initArguments.ctor = ctor;
            if (initArguments.fields) {
                const srcFields = initArguments.fields;
                const trgFields = initArguments.fields = {};
                for (const [fieldName, o] of Object.entries(srcFields)) {
                    try {
                        this.curPath.push('.' + fieldName);
                        const srcMeta = typeof o === 'string' ? { type: o } : o;
                        const fieldInit = trgFields[fieldName] = {
                            ...srcMeta,
                            name: fieldName
                        };
                        if (srcMeta.enum) {
                            const enumObject = srcMeta.enum;
                            delete srcMeta.enum;
                            if (enumObject[constants_js_1.DATATYPE_METADATA]) {
                                fieldInit.type = await this.importDataType(enumObject);
                            }
                            else {
                                const enumMeta = (0, enum_type_js_1.EnumType)(enumObject, { name: '' });
                                fieldInit.type = await this.importDataType({ ...enumMeta, kind: 'EnumType', base: undefined });
                            }
                        }
                        else {
                            if (srcMeta.isArray && !srcMeta.type)
                                throw new TypeError(`"type" must be defined explicitly for array properties`);
                            fieldInit.type = await this.importDataType(srcMeta.type || srcMeta.designType || 'any');
                        }
                        this.curPath.pop();
                    }
                    catch (e) {
                        e.message = `Error in resource "${initArguments.name}.${fieldName}". ` + e.message;
                        throw e;
                    }
                }
            }
        }
        if (initArguments.kind === 'MappedType') {
            const dataType = await this.importDataType(initArguments.base);
            // istanbul ignore next
            if (!(dataType instanceof complex_type_js_1.ComplexType))
                throw new TypeError('MappedType.type property must address to a ComplexType');
            initArguments.base = dataType;
        }
        if (initArguments.kind === 'MixinType') {
            const oldTypes = initArguments.types;
            initArguments.types = [];
            for (const type of oldTypes)
                initArguments.types.push(await this.importDataType(type));
        }
        return initArguments;
    }
    createDataTypeInstance(kind, name) {
        const dataType = {
            document: this.document,
            kind,
            name
        };
        switch (kind) {
            case index_js_2.OpraSchema.ComplexType.Kind:
                Object.setPrototypeOf(dataType, complex_type_js_1.ComplexType.prototype);
                break;
            case index_js_2.OpraSchema.EnumType.Kind:
                Object.setPrototypeOf(dataType, enum_type_js_1.EnumType.prototype);
                break;
            case index_js_2.OpraSchema.MappedType.Kind:
                Object.setPrototypeOf(dataType, mapped_type_js_1.MappedType.prototype);
                break;
            case index_js_2.OpraSchema.SimpleType.Kind:
                Object.setPrototypeOf(dataType, simple_type_js_1.SimpleType.prototype);
                break;
            case index_js_2.OpraSchema.MixinType.Kind:
                Object.setPrototypeOf(dataType, mixin_type_js_1.MixinType.prototype);
                break;
            default:
                throw new TypeError(`Unknown DataType kind (${kind})`);
        }
        return dataType;
    }
}
exports.TypeDocumentFactory = TypeDocumentFactory;
TypeDocumentFactory.designTypeMap = new Map();
