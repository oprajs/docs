"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappedType = exports.PartialType = exports.OmitType = exports.PickType = void 0;
const tslib_1 = require("tslib");
require("reflect-metadata");
const putil_merge_1 = tslib_1.__importDefault(require("putil-merge"));
const index_js_1 = require("../../helpers/index.js");
const index_js_2 = require("../../schema/index.js");
const constants_js_1 = require("../constants.js");
const mapped_type_class_js_1 = require("./mapped-type-class.js");
/**
 *
 */
function PickType(classRef, keys) {
    return (0, exports.MappedType)(classRef, { pick: keys });
}
exports.PickType = PickType;
/**
 *
 */
function OmitType(classRef, keys) {
    return (0, exports.MappedType)(classRef, { omit: keys });
}
exports.OmitType = OmitType;
/**
 *
 */
function PartialType(classRef, keys) {
    return (0, exports.MappedType)(classRef, { partial: keys || true });
}
exports.PartialType = PartialType;
/**
 * @class MappedType
 */
exports.MappedType = function (...args) {
    // Constructor
    if (this) {
        const [document, init] = args;
        (0, putil_merge_1.default)(this, new mapped_type_class_js_1.MappedTypeClass(document, init), { descriptor: true });
        return;
    }
    // MappedType helper
    const [mappedSource, options] = args;
    const isInheritedPredicate = (0, mapped_type_class_js_1.getIsInheritedPredicateFn)(options.pick, options.omit);
    class MappedClass {
        constructor() {
            (0, index_js_1.inheritPropertyInitializers)(this, mappedSource, isInheritedPredicate);
        }
    }
    (0, index_js_1.mergePrototype)(MappedClass.prototype, mappedSource.prototype);
    // const mappedTypeMetadata: MappedType.TypeMapping[] = [];
    const m = Reflect.getOwnMetadata(constants_js_1.DATATYPE_METADATA, mappedSource);
    if (!m)
        throw new TypeError(`Class "${mappedSource}" doesn't have datatype metadata information`);
    if (!(m.kind === index_js_2.OpraSchema.ComplexType.Kind || m.kind === index_js_2.OpraSchema.MappedType.Kind || m.kind === index_js_2.OpraSchema.MixinType.Kind))
        throw new TypeError(`Class "${mappedSource}" is not a ${index_js_2.OpraSchema.ComplexType.Kind}`);
    const metadata = {
        kind: 'MappedType',
        base: mappedSource
    };
    if (options.pick)
        metadata.pick = options.pick;
    if (options.omit)
        metadata.omit = options.omit;
    if (options.partial)
        metadata.partial = options.partial;
    Reflect.defineMetadata(constants_js_1.DATATYPE_METADATA, metadata, MappedClass);
    exports.MappedType._applyMixin(MappedClass, mappedSource, {
        ...options,
        isInheritedPredicate
    });
    return MappedClass;
};
exports.MappedType.prototype = mapped_type_class_js_1.MappedTypeClass.prototype;
exports.MappedType._applyMixin = () => void 0;
