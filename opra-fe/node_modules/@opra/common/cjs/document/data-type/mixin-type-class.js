"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MixinTypeClass = void 0;
const index_js_1 = require("../../schema/index.js");
const complex_type_js_1 = require("./complex-type.js");
const mapped_type_js_1 = require("./mapped-type.js");
class MixinTypeClass extends complex_type_js_1.ComplexType {
    constructor(document, init) {
        super(document, init);
        this.kind = index_js_1.OpraSchema.MixinType.Kind;
        const own = this.own;
        own.types = [];
        const MixinType = Object.getPrototypeOf(this).constructor;
        for (const base of init.types) {
            if (!(base instanceof complex_type_js_1.ComplexType || base instanceof MixinType || base instanceof mapped_type_js_1.MappedType))
                throw new TypeError(`${index_js_1.OpraSchema.MixinType.Kind} shall contain ${index_js_1.OpraSchema.ComplexType.Kind}, ` +
                    `${index_js_1.OpraSchema.MixinType.Kind} of ${index_js_1.OpraSchema.MappedType.Kind} types.`);
            own.types.push(base);
            if (base.additionalFields === true && this.additionalFields !== true) {
                // @ts-ignore
                this.additionalFields = true;
            }
            else if (base.additionalFields === 'error' && !this.additionalFields) {
                // @ts-ignore
                this.additionalFields = 'error';
            }
            this.fields.setAll(base.fields);
        }
        this.types = [...own.types];
    }
    // @ts-ignore
    exportSchema() {
        const out = super.exportSchema();
        out.types = this.own.types.map(t => t.name ? t.name : t.exportSchema());
        return out;
    }
}
exports.MixinTypeClass = MixinTypeClass;
