"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnumType = void 0;
const tslib_1 = require("tslib");
require("reflect-metadata");
const putil_merge_1 = tslib_1.__importDefault(require("putil-merge"));
const index_js_1 = require("../../helpers/index.js");
const index_js_2 = require("../../schema/index.js");
const constants_js_1 = require("../constants.js");
const enum_type_class_js_1 = require("./enum-type-class.js");
/**
 * @class EnumType
 */
exports.EnumType = function (...args) {
    // Injector
    if (!this) {
        const [enumSource, options] = args;
        let values = {};
        if (Array.isArray(enumSource)) {
            values = {};
            enumSource.forEach(k => {
                const description = options?.meanings?.[k];
                values[k] = (0, index_js_1.omitUndefined)({ description });
            });
        }
        else {
            Object.keys(enumSource).forEach(k => {
                const description = options?.meanings?.[k];
                values[enumSource[k]] = (0, index_js_1.omitUndefined)({ key: k, description });
            });
        }
        const metadata = {
            kind: index_js_2.OpraSchema.EnumType.Kind,
            values,
            base: options?.base,
            name: options?.name,
            description: options?.description
        };
        Object.defineProperty(enumSource, constants_js_1.DATATYPE_METADATA, {
            value: metadata,
            enumerable: false,
            configurable: true,
            writable: true
        });
        return metadata;
    }
    // Constructor
    const [document, init] = args;
    (0, putil_merge_1.default)(this, new enum_type_class_js_1.EnumTypeClass(document, init), { descriptor: true });
    return;
};
exports.EnumType.prototype = enum_type_class_js_1.EnumTypeClass.prototype;
