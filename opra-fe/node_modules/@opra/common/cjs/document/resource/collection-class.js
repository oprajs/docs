"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionClass = void 0;
const valgen_1 = require("valgen");
const index_js_1 = require("../../exception/index.js");
const index_js_2 = require("../../filter/index.js");
const index_js_3 = require("../../i18n/index.js");
const index_js_4 = require("../../schema/index.js");
const constants_js_1 = require("../constants.js");
const simple_type_js_1 = require("../data-type/simple-type.js");
const crud_resource_js_1 = require("./crud-resource.js");
class CollectionClass extends crud_resource_js_1.CrudResource {
    constructor(parent, init) {
        super(parent, init);
        this.kind = index_js_4.OpraSchema.Collection.Kind;
        const dataType = this.type = init.type;
        // Validate key fields
        this.primaryKey = init.primaryKey
            ? (Array.isArray(init.primaryKey) ? init.primaryKey : [init.primaryKey])
            : [];
        if (!this.primaryKey.length)
            throw new TypeError(`You must provide primaryKey for Collection resource ("${this.name}")`);
        this.primaryKey.forEach(f => {
            const field = dataType.getField(f);
            if (!(field?.type instanceof simple_type_js_1.SimpleType))
                throw new TypeError(`Only Simple type allowed for primary keys but "${f}" is a ${field.type.kind}`);
        });
        // ------------------
        let endpoint = this.operations.get('create');
        if (endpoint) {
            // endpoint.defineParameter('metadata', {enum: MetadataMode, isBuiltin: true, default: 'minimal'});
            endpoint.defineParameter('pick', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('omit', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('include', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.decodeInput = this.type.generateCodec('decode', {
                partial: false,
                pick: endpoint.options.inputPickFields,
                omit: endpoint.options.inputOmitFields,
                operation: 'write',
                overwriteFields: endpoint.inputOverwriteFields
            });
            endpoint.returnType = this.type;
            endpoint.encodeReturning = endpoint.returnType.generateCodec('encode', {
                partial: true,
                pick: endpoint.options.outputPickFields,
                omit: endpoint.options.outputOmitFields,
                operation: 'read',
                overwriteFields: endpoint.outputOverwriteFields
            });
        }
        // ------------------
        endpoint = this.operations.get('deleteMany');
        if (endpoint) {
            // endpoint.defineParameter('metadata', {enum: MetadataMode, isBuiltin: true});
            endpoint.defineParameter('filter', { type: 'string', isBuiltin: true });
        }
        // ------------------
        endpoint = this.operations.get('get');
        if (endpoint) {
            // endpoint.defineParameter('metadata', {enum: MetadataMode, isBuiltin: true, default: 'minimal'});
            endpoint.defineParameter('pick', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('omit', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('include', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.returnType = this.type;
            endpoint.encodeReturning = endpoint.returnType.generateCodec('encode', {
                partial: true,
                pick: endpoint.options.outputPickFields,
                omit: endpoint.options.outputOmitFields,
                operation: 'read',
                overwriteFields: endpoint.outputOverwriteFields
            });
        }
        // ------------------
        endpoint = this.operations.get('findMany');
        if (endpoint) {
            // endpoint.defineParameter('metadata', {enum: MetadataMode, isBuiltin: true, default: 'minimal'});
            endpoint.defineParameter('pick', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('omit', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('include', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('sort', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('filter', { type: 'string', isBuiltin: true });
            endpoint.defineParameter('limit', { type: 'integer', isBuiltin: true });
            endpoint.defineParameter('skip', { type: 'integer', isBuiltin: true });
            endpoint.defineParameter('distinct', { type: 'boolean', isBuiltin: true });
            endpoint.defineParameter('count', { type: 'boolean', isBuiltin: true });
            endpoint.returnType = this.type;
            endpoint.encodeReturning = valgen_1.vg.isArray(this.type.generateCodec('encode', {
                partial: true,
                pick: endpoint.options.outputPickFields,
                omit: endpoint.options.outputOmitFields,
                operation: 'read',
                overwriteFields: endpoint.outputOverwriteFields
            }));
        }
        // ------------------
        endpoint = this.operations.get('update');
        if (endpoint) {
            // endpoint.defineParameter('metadata', {enum: MetadataMode, isBuiltin: true, default: 'minimal'});
            endpoint.defineParameter('pick', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('omit', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.defineParameter('include', { type: 'string', isArray: true, isBuiltin: true });
            endpoint.decodeInput = this.type.generateCodec('decode', {
                partial: true,
                pick: endpoint.options.inputPickFields,
                omit: endpoint.options.inputOmitFields,
                operation: 'write',
                overwriteFields: endpoint.inputOverwriteFields
            });
            endpoint.returnType = this.type;
            endpoint.encodeReturning = endpoint.returnType.generateCodec('encode', {
                partial: true,
                pick: endpoint.options.outputPickFields,
                omit: endpoint.options.outputOmitFields,
                operation: 'read',
                overwriteFields: endpoint.outputOverwriteFields
            });
        }
        // ------------------
        endpoint = this.operations.get('updateMany');
        if (endpoint) {
            // endpoint.defineParameter('metadata', {enum: MetadataMode, isBuiltin: true, default: 'minimal'});
            endpoint.defineParameter('filter', { type: 'string', isBuiltin: true });
            endpoint.decodeInput = this.type.generateCodec('decode', {
                partial: true,
                pick: endpoint.options.inputPickFields,
                omit: endpoint.options.inputOmitFields,
                operation: 'write',
                overwriteFields: endpoint.inputOverwriteFields
            });
        }
    }
    exportSchema(options) {
        return {
            ...super.exportSchema(options),
            type: this.type.name || 'object',
            ...{
                primaryKey: this.primaryKey
            }
        };
    }
    parseKeyValue(value) {
        if (!this.primaryKey?.length)
            return;
        const dataType = this.type;
        if (this.primaryKey.length > 1) {
            // Build primary key/value mapped object
            const obj = Array.isArray(value)
                ? this.primaryKey.reduce((o, k, i) => {
                    o[k] = value[i];
                    return obj;
                }, {})
                : value;
            // decode values
            for (const [k, v] of Object.entries(obj)) {
                const el = dataType.getField(k);
                if (el.type instanceof simple_type_js_1.SimpleType) {
                    try {
                        obj[k] = el.type.decode(v, { coerce: true });
                    }
                    catch (e) {
                        e.message = `The key value for field "${el.name}" is not valid. ` + e.message;
                    }
                }
                if (obj[k] == null)
                    throw new TypeError(`You must provide value of primary field(s) (${k})`);
            }
        }
        else {
            const primaryKey = this.primaryKey[0];
            if (typeof value === 'object')
                value = value[primaryKey];
            const el = dataType.getField(primaryKey);
            let result;
            if (value != null && el.type instanceof simple_type_js_1.SimpleType) {
                try {
                    result = el.type.decode(value, { coerce: true });
                }
                catch (e) {
                    e.message = `The key value is not valid. ` + e.message;
                }
            }
            if (result == null)
                throw new TypeError(`You must provide value of primary field(s) (${primaryKey})`);
            return result;
        }
    }
    normalizeFieldNames(fields, allowSortSigns) {
        return this.type.normalizeFieldNames(fields, allowSortSigns);
    }
    normalizeSortFields(fields) {
        const normalized = this.type.normalizeFieldNames(fields, true);
        if (!normalized)
            return;
        const findManyOp = this.getOperation('findMany');
        const sortFields = findManyOp && findManyOp.options.sortFields;
        (Array.isArray(normalized) ? normalized : [normalized]).forEach(field => {
            const m = constants_js_1.SORT_FIELD_PATTERN.exec(field);
            if (m && !sortFields?.find(x => x === m[2]))
                throw new index_js_1.BadRequestError({
                    message: (0, index_js_3.translate)('error:UNACCEPTED_SORT_FIELD', { field }),
                });
        });
        return normalized;
    }
    normalizeFilter(filter) {
        if (!filter)
            return;
        const ast = typeof filter === 'string' ? index_js_2.OpraFilter.parse(filter) : filter;
        if (ast instanceof index_js_2.OpraFilter.ComparisonExpression) {
            this.normalizeFilter(ast.left);
            if (!(ast.left instanceof index_js_2.OpraFilter.QualifiedIdentifier && ast.left.field))
                throw new TypeError(`Invalid filter query. Left side should be a data field.`);
            // Check if filtering accepted for given field
            const findManyOp = this.getOperation('findMany');
            const fieldLower = ast.left.value.toLowerCase();
            const filterDef = (findManyOp && findManyOp.options.filters || [])
                .find(f => f.field.toLowerCase() === fieldLower);
            if (!filterDef) {
                throw new index_js_1.BadRequestError({
                    message: (0, index_js_3.translate)('error:UNACCEPTED_FILTER_FIELD', { field: ast.left.value }),
                });
            }
            // Check if filtering endpoint accepted for given field
            if (filterDef.operators && !filterDef.operators.includes(ast.op))
                throw new index_js_1.BadRequestError({
                    message: (0, index_js_3.translate)('error:UNACCEPTED_FILTER_OPERATION', { field: ast.left.value }),
                });
            this.normalizeFilter(ast.right);
            return ast;
        }
        if (ast instanceof index_js_2.OpraFilter.LogicalExpression) {
            ast.items.forEach(item => this.normalizeFilter(item));
            return ast;
        }
        if (ast instanceof index_js_2.OpraFilter.ArithmeticExpression) {
            ast.items.forEach(item => this.normalizeFilter(item.expression));
            return ast;
        }
        if (ast instanceof index_js_2.OpraFilter.ArrayExpression) {
            ast.items.forEach(item => this.normalizeFilter(item));
            return ast;
        }
        if (ast instanceof index_js_2.OpraFilter.ParenthesizedExpression) {
            this.normalizeFilter(ast.expression);
            return ast;
        }
        if (ast instanceof index_js_2.OpraFilter.QualifiedIdentifier) {
            const normalizedFieldPath = this.type.normalizeFieldNames(ast.value)?.join('.');
            ast.field = this.type.getField(normalizedFieldPath);
            ast.dataType = ast.field?.type || this.document.getDataType('any');
            ast.value = normalizedFieldPath;
            return ast;
        }
        return ast;
    }
}
exports.CollectionClass = CollectionClass;
