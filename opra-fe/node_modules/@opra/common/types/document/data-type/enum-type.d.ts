import 'reflect-metadata';
import { StrictOmit } from 'ts-gems';
import { OpraSchema } from '../../schema/index.js';
import type { ApiDocument } from '../api-document.js';
import { DataType } from './data-type.js';
import { EnumTypeClass } from './enum-type-class.js';
export interface EnumTypeConstructor {
    new (document: ApiDocument, init?: EnumType.InitArguments): EnumType;
    <T extends EnumType.EnumObject | EnumType.EnumArray>(target: T, options: EnumType.Options<T>): EnumType.Metadata;
}
export interface EnumType extends EnumTypeClass {
}
/**
 * @class EnumType
 */
export declare const EnumType: EnumTypeConstructor;
export declare namespace EnumType {
    type EnumObject = Record<string, OpraSchema.EnumType.Value>;
    type EnumArray = readonly string[];
    interface Metadata extends StrictOmit<OpraSchema.EnumType, 'base'> {
        name?: string;
        base?: EnumObject | string;
    }
    interface InitArguments extends DataType.InitArguments, Pick<OpraSchema.EnumType, 'base'> {
        enumObject?: object;
        base?: EnumType;
        values: Record<OpraSchema.EnumType.Value, OpraSchema.EnumType.ValueInfo>;
    }
    interface Options<T, Keys extends (string | number | symbol) = T extends readonly any[] ? T[number] : keyof T> extends DataType.DecoratorOptions {
        name: string;
        base?: EnumObject;
        meanings?: Record<Keys, string>;
    }
}
