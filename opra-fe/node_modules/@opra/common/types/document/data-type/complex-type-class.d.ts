import { RequiredSome, Type } from 'ts-gems';
import { IsObject } from 'valgen';
import { ResponsiveMap } from '../../helpers/index.js';
import { OpraSchema } from '../../schema/index.js';
import type { ApiDocument } from '../api-document.js';
import type { ComplexType } from './complex-type.js';
import { DataType } from './data-type.js';
import { ApiField } from './field.js';
import type { MappedType } from './mapped-type.js';
import type { MixinType } from './mixin-type.js';
/**
 * @class ComplexType
 */
export declare class ComplexTypeClass extends DataType {
    readonly kind: OpraSchema.DataType.Kind;
    readonly ctor: Type;
    readonly base?: ComplexType | MixinType | MappedType;
    readonly own: ComplexType.OwnProperties;
    readonly fields: ResponsiveMap<ApiField>;
    readonly abstract?: boolean;
    readonly additionalFields?: boolean | DataType | 'error';
    constructor(document: ApiDocument, init: ComplexType.InitArguments);
    findField(nameOrPath: string): ApiField | undefined;
    getField(nameOrPath: string): ApiField;
    iteratePath(path: string, silent?: boolean): IterableIterator<[string, ApiField | undefined, string]>;
    normalizeFieldNames(fieldNames: string | string[], allowSortSigns?: boolean): string[] | undefined;
    exportSchema(options?: {
        webSafe?: boolean;
    }): any;
    isTypeOf(t: Type | Function): boolean;
    extendsFrom(t: string | Type | DataType): boolean;
    generateCodec<T extends Object = any>(codec: 'decode' | 'encode', options?: DataType.GenerateCodecOptions): IsObject.Validator<T>;
    generateCodecSchema(codec: 'decode' | 'encode', options?: DataType.GenerateCodecOptions): IsObject.Schema;
    protected _generateCodecSchema(codec: 'decode' | 'encode', options?: RequiredSome<DataType.GenerateCodecOptions, 'pick' | 'omit'>): IsObject.Schema;
    protected _buildOverwriteFieldsTree(obj: Record<string, DataType.OverrideFieldsConfig>): Record<string, DataType.OverrideFieldsConfig>;
}
