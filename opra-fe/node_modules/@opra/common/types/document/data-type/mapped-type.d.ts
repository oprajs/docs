import 'reflect-metadata';
import { Class, StrictOmit, Type } from 'ts-gems';
import { OpraSchema } from '../../schema/index.js';
import type { ApiDocument } from '../api-document.js';
import { ComplexType } from './complex-type.js';
import { MappedTypeClass } from './mapped-type-class.js';
/**
 *
 */
export declare function PickType<T extends any[], I1, S1, K extends keyof I1>(classRef: Class<T, I1, S1>, keys: readonly K[]): Class<T, Pick<I1, K>> & Omit<Pick<S1, keyof typeof classRef>, 'prototype' | 'constructor'>;
/**
 *
 */
export declare function OmitType<T extends any[], I1, S1, K extends keyof I1>(classRef: Class<T, I1, S1>, keys: readonly K[]): Class<T, Omit<I1, K>> & Omit<Pick<S1, keyof typeof classRef>, 'prototype' | 'constructor'>;
/**
 *
 */
export declare function PartialType<T extends any[], I1, S1, K extends keyof I1>(classRef: Class<T, I1, S1>, keys?: readonly K[]): Class<T, Omit<I1, K>> & Omit<Pick<S1, keyof typeof classRef>, 'prototype' | 'constructor'>;
/**
 * Type definition of MappedType constructor type
 * @type MappedTypeConstructor
 */
export interface MappedTypeConstructor {
    prototype: MappedType;
    new (document: ApiDocument, init: MappedType.InitArguments): MappedType;
    <T extends any[], I1, S1, PickKey extends keyof I1, OmitKey extends keyof I1, PartialKey extends keyof I1>(resource: Class<T, I1, S1>, options: {
        pickKeys?: readonly PickKey[];
        omitKeys?: readonly OmitKey[];
        partialKeys?: readonly PartialKey[];
    }): Class<T, Omit<Pick<I1, PickKey>, OmitKey>>;
    _applyMixin(targetType: Type, sourceType: Type, options: MappedType.Options<any> & {
        isInheritedPredicate: (fieldName: string) => boolean;
    }): void;
}
/**
 * @class MappedType
 */
export declare const MappedType: MappedTypeConstructor;
/**
 * Type definition of MappedType prototype
 * @type MappedType
 */
export interface MappedType extends MappedTypeClass {
}
/**
 * @namespace MappedType
 */
export declare namespace MappedType {
    interface InitArguments extends ComplexType.InitArguments, Pick<OpraSchema.MappedType, 'pick' | 'omit' | 'partial'> {
    }
    interface Metadata extends StrictOmit<ComplexType.Metadata, 'kind' | 'base' | 'name'>, Pick<OpraSchema.MappedType, 'pick' | 'omit' | 'partial'> {
        kind: OpraSchema.MappedType.Kind;
        base: Type;
    }
    interface OwnProperties extends ComplexType.OwnProperties, Pick<OpraSchema.MappedType, 'pick' | 'omit' | 'partial'> {
    }
    interface Options<T, K = keyof T> {
        pick?: readonly K[];
        omit?: readonly K[];
        partial?: readonly K[] | boolean;
    }
}
