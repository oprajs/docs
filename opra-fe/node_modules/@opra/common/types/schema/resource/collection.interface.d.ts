import { StrictOmit } from 'ts-gems';
import type { OpraFilter } from '../../filter/index.js';
import type { DataType } from '../data-type/data-type.interface.js';
import type { Field } from '../data-type/field.interface';
import type { Endpoint } from './endpoint.interface.js';
import type { ResourceBase } from './resource.interface.js';
export interface Collection extends StrictOmit<ResourceBase, 'kind'> {
    kind: Collection.Kind;
    type: DataType.Name;
    primaryKey: Field.Name | Field.Name[];
    operations?: Collection.Operations;
}
export declare namespace Collection {
    const Kind = "Collection";
    type Kind = 'Collection';
    interface Operations {
        create?: Operations.Create;
        delete?: Operations.Delete;
        deleteMany?: Operations.DeleteMany;
        findMany?: Operations.FindMany;
        get?: Operations.Get;
        update?: Operations.Update;
        updateMany?: Operations.UpdateMany;
    }
    namespace Operations {
        type Create = Endpoint<_InputOptions & _OutputOptions>;
        type Delete = Endpoint;
        type DeleteMany = Endpoint<_FilterOption>;
        type Get = Endpoint & _OutputOptions;
        type FindMany = Endpoint<_FilterOption & _OutputOptions & {
            sortFields?: string[];
            defaultSort?: string[];
        }>;
        type Update = Endpoint<_InputOptions & _OutputOptions>;
        type UpdateMany = Endpoint<_FilterOption & _InputOptions & _OutputOptions>;
    }
}
interface _FilterOption {
    filters?: {
        field: Field.QualifiedName;
        operators?: OpraFilter.ComparisonOperator[];
        notes?: string;
    }[];
}
interface _InputOptions {
    inputMaxContentSize?: number | string;
    inputPick?: Field.QualifiedName[];
    inputOmit?: Field.QualifiedName[];
    inputOverwriteFields?: Record<string, Field>;
}
interface _OutputOptions {
    outputPick?: Field.QualifiedName[];
    outputOmit?: Field.QualifiedName[];
}
export {};
