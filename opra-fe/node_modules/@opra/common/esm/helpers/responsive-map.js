var _a, _b, _c, _d;
function isMap(v) {
    return v && typeof v.forEach === 'function';
}
const kKeyMap = Symbol.for('kKeyMap');
const kKeyOrder = Symbol.for('kKeyOrder');
const kWellKnownKeys = Symbol.for('kWellKnownKeys');
const kOptions = Symbol.for('kOptions');
/**
 * A Map implementation that supports case-insensitivity and ordered keys
 */
export class ResponsiveMap extends Map {
    constructor(init, options) {
        super();
        this[_a] = new Map();
        this[_b] = [];
        this[_c] = new Map();
        this[_d] = { caseSensitive: false };
        this[kOptions].caseSensitive = !!options?.caseSensitive;
        if (options?.wellKnownKeys)
            options.wellKnownKeys.forEach(k => this[kWellKnownKeys].set(k.toLowerCase(), k));
        if (init)
            this.setAll(init);
    }
    clear() {
        super.clear();
        this[kKeyMap].clear();
        this[kKeyOrder] = [];
    }
    get(key) {
        const orgKey = this._getOriginalKey(key);
        return super.get(orgKey);
    }
    has(key) {
        return this[kKeyMap].has(this._getStoringKey(key));
    }
    set(key, value) {
        key = this._getOriginalKey(key);
        this[kKeyMap].set(this._getStoringKey(key), key);
        if (!this[kKeyOrder].includes(key))
            this[kKeyOrder].push(key);
        return super.set(key, value);
    }
    setAll(source) {
        if (isMap(source))
            source.forEach((v, k) => this.set(k, v));
        else
            Object.keys(source).forEach(k => this.set(k, source[k]));
        return this;
    }
    keys() {
        return [...this[kKeyOrder]][Symbol.iterator]();
    }
    values() {
        let i = -1;
        const arr = [...this[kKeyOrder]];
        const map = this;
        return {
            [Symbol.iterator]() {
                return this;
            },
            next() {
                i++;
                return {
                    done: i >= arr.length,
                    value: map.get(arr[i])
                };
            }
        };
    }
    entries() {
        let i = -1;
        const arr = [...this[kKeyOrder]];
        const map = this;
        return {
            [Symbol.iterator]() {
                return this;
            },
            next() {
                i++;
                return {
                    done: i >= arr.length,
                    value: [arr[i], map.get(arr[i])]
                };
            }
        };
    }
    delete(key) {
        const orgKey = this._getOriginalKey(key);
        const k = this._getStoringKey(key);
        this[kKeyMap].delete(k);
        const i = this[kKeyOrder].indexOf(orgKey);
        if (i >= 0)
            this[kKeyOrder].splice(i, 1);
        return super.delete(orgKey);
    }
    sort(compareFn) {
        if (compareFn)
            this[kKeyOrder].sort(compareFn);
        else if (this[kOptions].caseSensitive)
            this[kKeyOrder].sort();
        else
            this[kKeyOrder].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        return this;
    }
    getProxy(handler) {
        const _this = this;
        const finalHandler = {
            get(target, p, receiver) {
                if (typeof p === 'string')
                    return _this.get(p);
                return Reflect.get(target, p, receiver);
            },
            set(target, p, newValue, receiver) {
                if (typeof p === 'string') {
                    _this.set(p, newValue);
                    return true;
                }
                return Reflect.set(target, p, newValue, receiver);
            },
            has(target, p) {
                if (typeof p === 'string')
                    return _this.has(p);
                return Reflect.has(target, p);
            },
            ownKeys() {
                return Array.from(_this.keys()).map(x => x.toLowerCase());
            },
            getPrototypeOf() {
                return Object.prototype;
            },
            defineProperty(target, property, attributes) {
                if (typeof property === 'string') {
                    _this.set(property, attributes.value);
                    return true;
                }
                return false;
            },
            deleteProperty(target, p) {
                if (typeof p === 'string')
                    return _this.delete(p);
                return false;
            },
            getOwnPropertyDescriptor(target, key) {
                if (typeof key === 'string') {
                    const value = finalHandler.get(target, key);
                    return { configurable: true, enumerable: true, writable: true, value };
                }
            },
            ...handler
        };
        return new Proxy({}, finalHandler);
    }
    toObject() {
        return Object.keys(this.keys()).reduce((trg, k) => {
            trg[k] = this.get(k);
            return trg;
        }, {});
    }
    [(_a = kKeyMap, _b = kKeyOrder, _c = kWellKnownKeys, _d = kOptions, Symbol.iterator)]() {
        return this.entries();
    }
    _getOriginalKey(key) {
        if (!key || this[kOptions].caseSensitive)
            return key;
        return this[kKeyMap].get(key.toLowerCase()) ??
            (this[kWellKnownKeys].get(key.toLowerCase()) ?? key);
    }
    _getStoringKey(key) {
        if (this[kOptions].caseSensitive)
            return key;
        return key.toLowerCase();
    }
}
