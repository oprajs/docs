import antlr4 from '@browsery/antlr4';
import { LogicalExpressionContext, } from './antlr/OpraFilterParser.js';
import { ArrayExpression, BooleanLiteral, ComparisonExpression, DateLiteral, LogicalExpression, NegativeExpression, NullLiteral, NumberLiteral, ParenthesizedExpression, QualifiedIdentifier, StringLiteral, TimeLiteral } from './ast/index.js';
import { ExternalConstant } from './ast/terms/external-constant.js';
import { unquoteFilterString } from './utils.js';
// Fix: antlr4 d.ts files are invalid
const ParseTreeVisitor = antlr4.tree.ParseTreeVisitor;
export class FilterTreeVisitor extends ParseTreeVisitor {
    constructor(options) {
        super();
        this._timeZone = options?.timeZone;
    }
    visitChildren(node) {
        const result = super.visitChildren(node);
        if (Array.isArray(result) && result.length < 2)
            return result[0];
        return result ?? node.getText();
    }
    defaultResult() {
        return undefined;
    }
    visitRoot(ctx) {
        return this.visit(ctx.expression());
    }
    visitParenthesizedExpression(ctx) {
        const expression = this.visit(ctx.parenthesizedItem());
        return new ParenthesizedExpression(expression);
    }
    visitParenthesizedItem(ctx) {
        return this.visit(ctx.expression());
    }
    visitNegativeExpression(ctx) {
        const expression = this.visit(ctx.expression());
        return new NegativeExpression(expression);
    }
    visitComparisonExpression(ctx) {
        return new ComparisonExpression({
            op: ctx.comparisonOperator().getText(),
            left: this.visit(ctx.comparisonLeft()),
            right: this.visit(ctx.comparisonRight())
        });
    }
    visitLogicalExpression(ctx) {
        const items = [];
        const wrapChildren = (arr, op) => {
            for (const c of arr) {
                if (c instanceof LogicalExpressionContext && c.logicalOperator().getText() === op) {
                    wrapChildren(c.expression_list(), c.logicalOperator().getText());
                    continue;
                }
                const o = this.visit(c);
                items.push(o);
            }
        };
        wrapChildren(ctx.expression_list(), ctx.logicalOperator().getText());
        return new LogicalExpression({
            op: ctx.logicalOperator().getText(),
            items
        });
    }
    visitQualifiedIdentifier(ctx) {
        return new QualifiedIdentifier(ctx.getText());
    }
    visitExternalConstant(ctx) {
        return new ExternalConstant(ctx.identifier().getText());
    }
    visitNullLiteral() {
        return new NullLiteral();
    }
    visitBooleanLiteral(ctx) {
        return new BooleanLiteral(ctx.getText() === 'true');
    }
    visitNumberLiteral(ctx) {
        return new NumberLiteral(ctx.getText());
    }
    visitStringLiteral(ctx) {
        return new StringLiteral(unquoteFilterString(ctx.getText()));
    }
    visitInfinityLiteral() {
        return new NumberLiteral(Infinity);
    }
    visitDateLiteral(ctx) {
        return new DateLiteral(unquoteFilterString(ctx.getText()));
    }
    visitDateTimeLiteral(ctx) {
        return new DateLiteral(unquoteFilterString(ctx.getText()));
    }
    visitTimeLiteral(ctx) {
        return new TimeLiteral(unquoteFilterString(ctx.getText()));
    }
    visitArrayValue(ctx) {
        return new ArrayExpression(ctx.value_list().map(child => this.visit(child)));
    }
}
