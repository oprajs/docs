import { vg } from 'valgen';
import { DataType } from '../data-type/data-type.js';
import { ApiField } from '../data-type/field.js';
import { Endpoint } from './endpoint.js';
/**
 *
 * @class CrudOperation
 */
export class CrudOperation extends Endpoint {
    constructor(resource, name, init) {
        super(resource, name, init);
        this.resource = resource;
        this.name = name;
        this.kind = 'operation';
        this.decodeInput = vg.isAny();
        this.encodeReturning = vg.isAny();
        if (init.returnType)
            this.returnType = init.returnType instanceof DataType
                ? init.returnType : this.resource.document.getDataType(init.returnType);
        this.encodeReturning = this.returnType?.generateCodec('encode', { operation: 'read', partial: true }) || vg.isAny();
        this.inputOverwriteFields = init.options?.inputOverwriteFields;
        this.outputOverwriteFields = init.options?.outputOverwriteFields;
    }
    exportSchema(options) {
        const schema = super.exportSchema(options);
        if (this.returnType)
            schema.returnType = this.returnType.name && !this.returnType.isEmbedded ?
                this.returnType.name : this.returnType.exportSchema(options);
        if (this.inputOverwriteFields) {
            const trg = schema.options.inputOverwriteFields = {};
            Object.keys(this.inputOverwriteFields)
                .forEach(([k, o]) => {
                trg[k] = ApiField.prototype.exportSchema.call(o, options);
            });
        }
        if (this.outputOverwriteFields) {
            const trg = schema.options.outputOverwriteFields = {};
            Object.keys(this.outputOverwriteFields)
                .forEach(([k, o]) => {
                trg[k] = ApiField.prototype.exportSchema.call(o, options);
            });
        }
        return schema;
    }
}
