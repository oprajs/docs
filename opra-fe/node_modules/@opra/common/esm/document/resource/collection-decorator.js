import { omitUndefined } from '../../helpers/index.js';
import { OpraSchema } from '../../schema/index.js';
import { createActionDecorator } from './action-decorator.js';
import { createOperationDecorator } from './crud-operation-decorator.js';
import { ResourceDecorator } from './resource-decorator.js';
const operationProperties = ['create', 'delete', 'deleteMany', 'get', 'findMany', 'update', 'updateMany'];
export function CollectionDecorator(type, options) {
    return ResourceDecorator(OpraSchema.Collection.Kind, { ...options, type });
}
Object.assign(CollectionDecorator, ResourceDecorator);
/*
 * Action PropertyDecorator
 */
(function (CollectionDecorator) {
    /**
     * Action PropertyDecorator
     */
    function Action(options) {
        const list = [];
        return createActionDecorator(options, operationProperties, list);
    }
    CollectionDecorator.Action = Action;
    function Create(options) {
        const list = [];
        const decorator = createOperationDecorator('create', options, list);
        decorator.InputMaxContentSize = (sizeInBytes) => {
            list.push(operationMeta => operationMeta.options.inputMaxContentSize = sizeInBytes);
            return decorator;
        };
        decorator.InputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.inputPickFields = fields);
            return decorator;
        };
        decorator.InputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.inputOmitFields = fields);
            return decorator;
        };
        decorator.InputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.inputOverwriteFields = fields);
            return decorator;
        };
        decorator.OutputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputPickFields = fields);
            return decorator;
        };
        decorator.OutputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputOmitFields = fields);
            return decorator;
        };
        decorator.OutputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.outputOverwriteFields = fields);
            return decorator;
        };
        return decorator;
    }
    CollectionDecorator.Create = Create;
    function Delete(options) {
        const list = [];
        return createOperationDecorator('delete', options, list);
    }
    CollectionDecorator.Delete = Delete;
    function DeleteMany(options) {
        const list = [];
        const decorator = createOperationDecorator('deleteMany', options, list);
        decorator.Filter = (field, operators, notes) => {
            if (typeof operators === 'string')
                operators = operators.split(/\s*[,| ]\s*/)
                    .filter(s => s);
            list.push(operationMeta => {
                operationMeta.options.filters = operationMeta.options.filters || [];
                operationMeta.options.filters.push(omitUndefined({ field, operators, notes }));
            });
            return decorator;
        };
        return decorator;
    }
    CollectionDecorator.DeleteMany = DeleteMany;
    function Get(options) {
        const list = [];
        const decorator = createOperationDecorator('get', options, list);
        decorator.OutputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputPickFields = fields);
            return decorator;
        };
        decorator.OutputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputOmitFields = fields);
            return decorator;
        };
        decorator.OutputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.outputOverwriteFields = fields);
            return decorator;
        };
        return decorator;
    }
    CollectionDecorator.Get = Get;
    function FindMany(options) {
        const list = [];
        const decorator = createOperationDecorator('findMany', options, list);
        decorator.SortFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.sortFields = fields);
            return decorator;
        };
        decorator.DefaultSort = (...fields) => {
            list.push(operationMeta => operationMeta.options.defaultSort = fields);
            return decorator;
        };
        decorator.Filter = (field, operators, notes) => {
            if (typeof operators === 'string')
                operators = operators.split(/\s*[,| ]\s*/);
            list.push(operationMeta => {
                operationMeta.options.filters = operationMeta.options.filters || [];
                operationMeta.options.filters.push(omitUndefined({ field, operators, notes }));
            });
            return decorator;
        };
        decorator.OutputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputPickFields = fields);
            return decorator;
        };
        decorator.OutputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputOmitFields = fields);
            return decorator;
        };
        decorator.OutputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.outputOverwriteFields = fields);
            return decorator;
        };
        return decorator;
    }
    CollectionDecorator.FindMany = FindMany;
})(CollectionDecorator || (CollectionDecorator = {}));
/*
 * Update PropertyDecorator
 */
(function (CollectionDecorator) {
    function Update(options) {
        const list = [];
        const decorator = createOperationDecorator('update', options, list);
        decorator.InputMaxContentSize = (sizeInBytes) => {
            list.push(operationMeta => operationMeta.options.inputMaxContentSize = sizeInBytes);
            return decorator;
        };
        decorator.InputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.inputPickFields = fields);
            return decorator;
        };
        decorator.InputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.inputOmitFields = fields);
            return decorator;
        };
        decorator.InputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.inputOverwriteFields = fields);
            return decorator;
        };
        decorator.OutputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputPickFields = fields);
            return decorator;
        };
        decorator.OutputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.outputOmitFields = fields);
            return decorator;
        };
        decorator.OutputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.outputOverwriteFields = fields);
            return decorator;
        };
        return decorator;
    }
    CollectionDecorator.Update = Update;
})(CollectionDecorator || (CollectionDecorator = {}));
/*
 * UpdateMany PropertyDecorator
 */
(function (CollectionDecorator) {
    function UpdateMany(arg0) {
        const list = [];
        const options = typeof arg0 === 'string' ? { description: arg0 } : { ...arg0 };
        const decorator = createOperationDecorator('updateMany', options, list);
        decorator.InputMaxContentSize = (sizeInBytes) => {
            list.push(operationMeta => operationMeta.options.inputMaxContentSize = sizeInBytes);
            return decorator;
        };
        decorator.InputPickFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.inputPickFields = fields);
            return decorator;
        };
        decorator.InputOmitFields = (...fields) => {
            list.push(operationMeta => operationMeta.options.inputOmitFields = fields);
            return decorator;
        };
        decorator.InputOverwriteFields = (fields) => {
            list.push(operationMeta => operationMeta.options.inputOverwriteFields = fields);
            return decorator;
        };
        decorator.Filter = (field, operators, notes) => {
            if (typeof operators === 'string')
                operators = operators.split(/\s*[,| ]\s*/);
            list.push(operationMeta => {
                operationMeta.options.filters = operationMeta.options.filters || [];
                operationMeta.options.filters.push(omitUndefined({ field, operators, notes }));
            });
            return decorator;
        };
        return decorator;
    }
    CollectionDecorator.UpdateMany = UpdateMany;
})(CollectionDecorator || (CollectionDecorator = {}));
