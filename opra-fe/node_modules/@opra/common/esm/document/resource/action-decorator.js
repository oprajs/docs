import { RESOURCE_METADATA } from '../constants.js';
export function createActionDecorator(options, bannedProperties, list) {
    const decorator = ((target, propertyKey) => {
        if (typeof propertyKey === 'string' && bannedProperties.includes(propertyKey))
            throw new TypeError(`The "${propertyKey}" property is reserved for "${propertyKey}" operations and cannot be used as an action'`);
        const resourceMetadata = (Reflect.getOwnMetadata(RESOURCE_METADATA, target.constructor) || {});
        resourceMetadata.actions = resourceMetadata.actions || {};
        const actionMeta = { ...options };
        resourceMetadata.actions[propertyKey] = actionMeta;
        for (const fn of list)
            fn(actionMeta);
        Reflect.defineMetadata(RESOURCE_METADATA, resourceMetadata, target.constructor);
    });
    decorator.Parameter = (name, arg0) => {
        const parameterOptions = typeof arg0 === 'string' || typeof arg0 === 'function' ? { type: arg0 } : { ...arg0 };
        list.push((operationMeta) => {
            operationMeta.parameters = operationMeta.parameters || {};
            operationMeta.parameters[name] = { ...parameterOptions };
        });
        return decorator;
    };
    decorator.Returns = (t) => {
        list.push((actionMetadata) => {
            actionMetadata.returnType = t;
        });
        return decorator;
    };
    return decorator;
}
