import { NotAcceptableError, NotFoundError } from '../exception/index.js';
import { ResponsiveMap } from '../helpers/index.js';
import { OpraSchema } from '../schema/index.js';
import { DATATYPE_METADATA, NAMESPACE_PATTERN } from './constants.js';
import { ComplexType } from './data-type/complex-type.js';
import { DataType } from './data-type/data-type.js';
import { EnumType } from './data-type/enum-type.js';
import { DocumentBase } from './document-base.js';
export class TypeDocument extends DocumentBase {
    constructor() {
        super();
        this._designCtorMap = new Map();
        this._typeIndex = new Map();
        this._typeNsMap = new Map();
        this.references = new ResponsiveMap();
        this.types = new ResponsiveMap();
        const BigIntConstructor = Object.getPrototypeOf(BigInt(0)).constructor;
        const BufferConstructor = Object.getPrototypeOf(Buffer.from([]));
        this._designCtorMap.set(String, 'string');
        this._designCtorMap.set(Number, 'number');
        this._designCtorMap.set(Boolean, 'boolean');
        this._designCtorMap.set(Object, 'any');
        this._designCtorMap.set(Date, 'datetime');
        this._designCtorMap.set(BigIntConstructor, 'bigint');
        this._designCtorMap.set(ArrayBuffer, 'base64');
        this._designCtorMap.set(SharedArrayBuffer, 'base64');
        this._designCtorMap.set(BufferConstructor, 'base64');
    }
    /**
     *
     */
    getDataType(arg0, silent) {
        // Convert design ctor to type name (String -> 'string')
        if (typeof arg0 === 'function') {
            const x = this._designCtorMap.get(arg0);
            if (x)
                arg0 = x;
        }
        // Try to get instance from cache
        const t = typeof arg0 === 'string'
            ? this._typeIndex.get(arg0.toLowerCase())
            : this._typeIndex.get(arg0);
        if (t)
            return t;
        // Determine name
        let name;
        if (typeof arg0 === 'string')
            name = arg0;
        else if (arg0 instanceof DataType)
            name = arg0.name || '';
        else {
            const metadata = typeof arg0 === 'function'
                ? Reflect.getMetadata(DATATYPE_METADATA, arg0) : arg0?.[DATATYPE_METADATA];
            if (!metadata) {
                /* istanbul ignore next */
                if (!silent)
                    throw new TypeError('Invalid argument');
                return;
            }
            name = metadata.name;
        }
        // If cached as null, it means "not found" before
        if (t === null) {
            if (silent)
                return;
            throw new Error(`Data type "${name}" does not exists`);
        }
        let dataType;
        let ns = '';
        if (typeof arg0 === 'string' && arg0) {
            const m = NAMESPACE_PATTERN.exec(arg0);
            if (!m)
                throw new TypeError(`Invalid data type name "${name}"`);
            // If given string has namespace pattern (ns:type_name)
            if (m[2]) {
                ns = m[1];
                const ref = this.references.get(ns);
                if (!ref) {
                    if (silent)
                        return;
                    throw new Error(`No referenced document found for given namespace "${m[1]}"`);
                }
                dataType = ref.getDataType(m[2], silent);
            }
            else {
                // Get instance from own types
                dataType = this.types.get(arg0);
                // if not found, search in references (from last to first)
                if (!dataType) {
                    const references = Array.from(this.references.keys()).reverse();
                    for (const refNs of references) {
                        const ref = this.references.get(refNs);
                        dataType = ref.getDataType(name, true);
                        if (dataType) {
                            ns = refNs;
                            break;
                        }
                    }
                }
            }
        }
        else {
            const types = Array.from(this.types.values()).reverse();
            for (const dt of types) {
                if (dt === arg0 ||
                    ((dt instanceof ComplexType || dt instanceof EnumType) && dt.isTypeOf(arg0))) {
                    dataType = dt;
                    break;
                }
            }
            // if not found, search in references (from last to first)
            if (!dataType) {
                const references = Array.from(this.references.keys()).reverse();
                for (const refNs of references) {
                    const ref = this.references.get(refNs);
                    dataType = ref.getDataType(arg0, true);
                    if (dataType) {
                        ns = refNs;
                        break;
                    }
                }
            }
        }
        if (dataType) {
            this._typeIndex.set(arg0, dataType);
            if (ns)
                this._typeNsMap.set(dataType, ns);
            return dataType;
        }
        if (!silent)
            throw new NotFoundError(`Data type "${name}" does not exists`);
        return;
        /* istanbul ignore next */
        if (!silent)
            throw new TypeError('Invalid argument');
    }
    /**
     *
     */
    getDataTypeNs(arg0, silent) {
        const dt = this.getDataType(arg0, silent);
        if (dt)
            return this._typeNsMap.get(dt);
    }
    getComplexType(nameOrCtor, silent) {
        if (nameOrCtor === Object)
            nameOrCtor = 'object';
        const t = this.getDataType(nameOrCtor, silent);
        if (t) {
            if (t && t.kind === OpraSchema.ComplexType.Kind)
                return t;
            throw new NotAcceptableError(`Data type "${t.name}" is not a ComplexType`);
        }
    }
    getSimpleType(nameOrCtor, silent) {
        const t = this.getDataType(nameOrCtor, silent);
        if (t) {
            if (t && t.kind === OpraSchema.SimpleType.Kind)
                return t;
            throw new NotAcceptableError(`Data type "${t.name || t}" is not a SimpleType`);
        }
    }
    getEnumType(nameOrCtor, silent) {
        const t = this.getDataType(nameOrCtor);
        if (!t && silent)
            return;
        if (t && t.kind === OpraSchema.EnumType.Kind)
            return t;
        throw new NotAcceptableError(`Data type "${t.name || t}" is not a EnumType`);
    }
    /**
     * Export as Opra schema definition object
     */
    exportSchema(options) {
        const schema = super.exportSchema();
        if (this.references.size) {
            const references = {};
            let i = 0;
            for (const [ns, r] of this.references.entries()) {
                if (ns.toLowerCase() === 'opra')
                    continue;
                references[ns] = r.exportSchema(options);
                i++;
            }
            if (i)
                schema.references = references;
        }
        if (this.types.size) {
            const types = schema.types = {};
            for (const [name, r] of this.types.entries()) {
                types[name] = r.exportSchema(options);
            }
        }
        return schema;
    }
    invalidate() {
        this._typeIndex.clear();
        this._typeNsMap.clear();
    }
}
