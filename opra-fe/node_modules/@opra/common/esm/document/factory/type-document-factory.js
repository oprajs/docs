import { validator } from 'valgen';
import { cloneObject, isConstructor, resolveThunk, ResponsiveMap } from '../../helpers/index.js';
import { OpraSchema } from '../../schema/index.js';
import { DATATYPE_METADATA } from '../constants.js';
import { AnyType, ApproxDatetimeType, ApproxDateType, Base64Type, BigintType, BooleanType, DatetimeType, DateType, EmailType, IntegerType, NullType, NumberType, ObjectIdType, ObjectType, StringType, TimeType, UrlType, UuidType } from '../data-type/builtin/index.js';
import { ComplexType } from '../data-type/complex-type.js';
import { EnumType } from '../data-type/enum-type.js';
import { MappedType } from '../data-type/mapped-type.js';
import { MixinType } from '../data-type/mixin-type.js';
import { SimpleType } from '../data-type/simple-type.js';
import { TypeDocument } from '../type-document.js';
/**
 * @class TypeDocumentFactory
 */
export class TypeDocumentFactory {
    constructor() {
        this.typeQueue = new ResponsiveMap();
        this.circularRefs = new Map();
        this.curPath = [];
        this.cache = new Map();
    }
    /**
     * Creates ApiDocument instance from given schema object
     */
    static async createDocument(init) {
        const factory = new TypeDocumentFactory();
        const document = factory.document = new TypeDocument();
        await factory.initDocument(init);
        return document;
    }
    /**
     * Downloads schema from the given URL and creates the document instance   * @param url
     */
    static async createDocumentFromUrl(url) {
        const factory = new TypeDocumentFactory();
        const document = factory.document = new TypeDocument();
        await factory.initDocumentFromUrl(url);
        return document;
    }
    async initDocument(init) {
        init.version = init.version || OpraSchema.SpecVersion;
        this.document.url = init.url;
        if (init.info)
            Object.assign(this.document.info, init.info);
        if (!init?.noBuiltinTypes) {
            const builtinDocument = await this.createBuiltinTypeDocument();
            this.document.references.set('opra', builtinDocument);
        }
        if (init.references)
            await this.addReferences(init.references);
        if (init.types) {
            this.curPath.push('Types->');
            // Add type sources into typeQueue
            if (Array.isArray(init.types)) {
                let i = 0;
                for (const thunk of init.types) {
                    const metadata = Reflect.getMetadata(DATATYPE_METADATA, thunk) || thunk[DATATYPE_METADATA];
                    if (!(metadata && metadata.name))
                        throw new TypeError(`Metadata information not found at types[${i++}] "${String(thunk)}"`);
                    this.typeQueue.set(metadata.name, thunk);
                }
            }
            else
                for (const [name, schema] of Object.entries(init.types)) {
                    this.typeQueue.set(name, { ...schema, name });
                }
            // Create type instances
            for (const thunk of this.typeQueue.values()) {
                await this.importDataType(thunk);
            }
            this.document.types.sort();
            this.curPath.pop();
        }
        this.document.invalidate();
        return this.document;
    }
    async initDocumentFromUrl(url) {
        const resp = await fetch(url, { method: 'GET' });
        const init = await resp.json();
        if (!init)
            throw new TypeError(`Invalid response returned from url: ${url}`);
        return await this.initDocument({ ...init, url });
    }
    async createBuiltinTypeDocument() {
        const init = {
            version: OpraSchema.SpecVersion,
            url: 'https://oprajs.com/spec/v1.0',
            info: {
                version: OpraSchema.SpecVersion,
                title: 'Opra built-in types',
                license: {
                    url: 'https://github.com/oprajs/opra/blob/main/LICENSE',
                    name: 'MIT'
                }
            },
            types: [AnyType, Base64Type, BigintType, BooleanType,
                DateType, EmailType, IntegerType, NullType, NumberType, ObjectIdType,
                ObjectType, ApproxDateType, ApproxDatetimeType,
                StringType, DatetimeType, TimeType, UrlType, UuidType
            ]
        };
        const factory = new TypeDocumentFactory();
        factory.document = new TypeDocument();
        return await factory.initDocument({ ...init, noBuiltinTypes: true });
    }
    async addReferences(references) {
        const { document } = this;
        let ns;
        let r;
        for ([ns, r] of Object.entries(references)) {
            r = await r;
            if (typeof r === 'string') {
                document.references.set(ns, await this.initDocumentFromUrl(r));
            }
            else if (r instanceof TypeDocument)
                document.references.set(ns, r);
            else if (typeof r === 'object') {
                document.references.set(ns, await this.initDocument(r));
            }
            else
                throw new TypeError(`Invalid document reference (${ns}) in schema`);
        }
    }
    async importDataType(thunk) {
        thunk = await resolveThunk(thunk);
        let name = '';
        // let schema: OpraSchema.DataType | undefined;
        let ctor;
        if (typeof thunk === 'string') {
            name = thunk;
            thunk = this.typeQueue.get(name);
        }
        let initArguments;
        if (typeof thunk === 'function') {
            const metadata = Reflect.getMetadata(DATATYPE_METADATA, thunk);
            if (!metadata) {
                // Check if is an internal type class like String, Number etc
                const dataType = this.document.getDataType(thunk, true);
                if (dataType)
                    return dataType;
                throw new TypeError(`Class "${thunk.name}" doesn't have a valid DataType metadata`);
            }
            name = metadata.embedded ? undefined : metadata.name;
            initArguments = cloneObject(metadata);
            ctor = thunk;
        }
        else if (typeof thunk === 'object') {
            if (OpraSchema.isDataType(thunk)) {
                name = thunk.name;
                ctor = thunk.ctor || ctor;
                initArguments = cloneObject(thunk);
            }
            else {
                // It should be an enum object
                const metadata = thunk[DATATYPE_METADATA];
                if (!metadata)
                    throw new TypeError(`No EnumType metadata found for object ${JSON.stringify(thunk).substring(0, 20)}...`);
                name = metadata.embedded ? undefined : metadata.name;
                initArguments = cloneObject(metadata);
                initArguments.enumObject = thunk;
            }
        }
        ctor = ctor ?? (initArguments && (isConstructor(initArguments.ctor)) ? initArguments.ctor : undefined);
        if (name) {
            if (this.circularRefs.has(name.toLowerCase()))
                throw new TypeError('Circular reference detected');
            const dataType = this.document.getDataType(name, true);
            if (dataType)
                return dataType;
            this.curPath.push('/' + name);
            this.circularRefs.set(name, 1);
        }
        if (ctor) {
            if (this.circularRefs.has(ctor))
                throw new TypeError('Circular reference detected');
            const dataType = this.document.getDataType(ctor, true);
            if (dataType)
                return dataType;
            this.circularRefs.set(ctor, 1);
        }
        try {
            if (!initArguments)
                throw new TypeError(`No DataType schema determined`);
            // Create an empty DataType instance and add in to document.
            // This will help us for circular dependent data types
            const instance = this.createDataTypeInstance(initArguments.kind, name);
            if (name)
                this.document.types.set(name, instance);
            await this.prepareDataTypeInitArguments(initArguments, ctor);
            if (initArguments.kind === 'ComplexType') {
                if (typeof initArguments.additionalFields === 'function')
                    initArguments.additionalFields = await this.importDataType(initArguments.additionalFields);
                ComplexType.apply(instance, [this.document, initArguments]);
            }
            else if (initArguments.kind === 'SimpleType')
                SimpleType.apply(instance, [this.document, initArguments]);
            else if (initArguments.kind === 'EnumType')
                EnumType.apply(instance, [this.document, initArguments]);
            else if (initArguments.kind === 'MappedType')
                MappedType.apply(instance, [this.document, initArguments]);
            else if (initArguments.kind === 'MixinType')
                MixinType.apply(instance, [this.document, initArguments]);
            else
                throw new TypeError(`Invalid data type schema: ${String(initArguments)}`);
            return instance;
        }
        finally {
            if (name) {
                this.curPath.pop();
                this.circularRefs.delete(name.toLowerCase());
            }
            if (ctor)
                this.circularRefs.delete(ctor);
        }
    }
    async prepareDataTypeInitArguments(schema, ctor) {
        const initArguments = schema;
        // Import extending class first
        if (initArguments.kind === 'SimpleType' || initArguments.kind === 'ComplexType' ||
            initArguments.kind === 'EnumType') {
            if (ctor) {
                const baseClass = Object.getPrototypeOf(ctor.prototype).constructor;
                const baseMeta = Reflect.getMetadata(DATATYPE_METADATA, baseClass);
                if (baseMeta) {
                    initArguments.base = await this.importDataType(baseClass);
                }
            }
            else if (initArguments.base) {
                initArguments.base = await this.importDataType(initArguments.base);
            }
        }
        if (initArguments.kind === 'SimpleType' && ctor) {
            if (typeof ctor.prototype.decode === 'function')
                initArguments.decoder = initArguments.name
                    ? validator(initArguments.name, ctor.prototype.decode) : validator(ctor.prototype.decode);
            if (typeof ctor.prototype.encode === 'function')
                initArguments.decoder = initArguments.name
                    ? validator(initArguments.name, ctor.prototype.encode) : validator(ctor.prototype.encode);
            return;
        }
        if (initArguments.kind === 'ComplexType') {
            initArguments.ctor = ctor;
            if (initArguments.fields) {
                const srcFields = initArguments.fields;
                const trgFields = initArguments.fields = {};
                for (const [fieldName, o] of Object.entries(srcFields)) {
                    try {
                        this.curPath.push('.' + fieldName);
                        const srcMeta = typeof o === 'string' ? { type: o } : o;
                        const fieldInit = trgFields[fieldName] = {
                            ...srcMeta,
                            name: fieldName
                        };
                        if (srcMeta.enum) {
                            const enumObject = srcMeta.enum;
                            delete srcMeta.enum;
                            if (enumObject[DATATYPE_METADATA]) {
                                fieldInit.type = await this.importDataType(enumObject);
                            }
                            else {
                                const enumMeta = EnumType(enumObject, { name: '' });
                                fieldInit.type = await this.importDataType({ ...enumMeta, kind: 'EnumType', base: undefined });
                            }
                        }
                        else {
                            if (srcMeta.isArray && !srcMeta.type)
                                throw new TypeError(`"type" must be defined explicitly for array properties`);
                            fieldInit.type = await this.importDataType(srcMeta.type || srcMeta.designType || 'any');
                        }
                        this.curPath.pop();
                    }
                    catch (e) {
                        e.message = `Error in resource "${initArguments.name}.${fieldName}". ` + e.message;
                        throw e;
                    }
                }
            }
        }
        if (initArguments.kind === 'MappedType') {
            const dataType = await this.importDataType(initArguments.base);
            // istanbul ignore next
            if (!(dataType instanceof ComplexType))
                throw new TypeError('MappedType.type property must address to a ComplexType');
            initArguments.base = dataType;
        }
        if (initArguments.kind === 'MixinType') {
            const oldTypes = initArguments.types;
            initArguments.types = [];
            for (const type of oldTypes)
                initArguments.types.push(await this.importDataType(type));
        }
        return initArguments;
    }
    createDataTypeInstance(kind, name) {
        const dataType = {
            document: this.document,
            kind,
            name
        };
        switch (kind) {
            case OpraSchema.ComplexType.Kind:
                Object.setPrototypeOf(dataType, ComplexType.prototype);
                break;
            case OpraSchema.EnumType.Kind:
                Object.setPrototypeOf(dataType, EnumType.prototype);
                break;
            case OpraSchema.MappedType.Kind:
                Object.setPrototypeOf(dataType, MappedType.prototype);
                break;
            case OpraSchema.SimpleType.Kind:
                Object.setPrototypeOf(dataType, SimpleType.prototype);
                break;
            case OpraSchema.MixinType.Kind:
                Object.setPrototypeOf(dataType, MixinType.prototype);
                break;
            default:
                throw new TypeError(`Unknown DataType kind (${kind})`);
        }
        return dataType;
    }
}
TypeDocumentFactory.designTypeMap = new Map();
