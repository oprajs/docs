import { cloneObject, resolveThunk, ResponsiveMap } from '../../helpers/index.js';
import { OpraSchema } from '../../schema/index.js';
import { ApiDocument } from '../api-document.js';
import { RESOURCE_METADATA } from '../constants.js';
import { ComplexType } from '../data-type/complex-type.js';
import { EnumType } from '../data-type/enum-type.js';
import { Collection } from '../resource/collection.js';
import { Container } from '../resource/container.js';
import { Singleton } from '../resource/singleton.js';
import { Storage } from '../resource/storage.js';
import { TypeDocumentFactory } from './type-document-factory.js';
/**
 * @class ApiDocumentFactory
 */
export class ApiDocumentFactory extends TypeDocumentFactory {
    constructor() {
        super(...arguments);
        this.resourceQueue = new ResponsiveMap();
    }
    /**
     * Creates ApiDocument instance from given schema object
     * @param init
     */
    static async createDocument(init) {
        const factory = new ApiDocumentFactory();
        const document = factory.document = new ApiDocument();
        await factory.initDocument(init);
        return document;
    }
    /**
     * Downloads schema from the given URL and creates the document instance   * @param url
     */
    static async createDocumentFromUrl(url) {
        const factory = new ApiDocumentFactory();
        const document = factory.document = new ApiDocument();
        await factory.initDocumentFromUrl(url);
        return document;
    }
    async initDocument(init) {
        await super.initDocument(init);
        const processContainer = async (container, containerInit) => {
            if (!containerInit.resources)
                return;
            if (Array.isArray(containerInit.resources)) {
                for (const thunk of containerInit.resources) {
                    const initArguments = await this.importResourceInstance(thunk);
                    container.resources.set(initArguments.name, await this.createResource(container, initArguments));
                }
            }
            else
                for (const [name, schema] of Object.entries(containerInit.resources)) {
                    const initArguments = await this.importResourceSchema(name, schema);
                    container.resources.set(initArguments.name, await this.createResource(container, initArguments));
                }
            container.resources.sort();
        };
        if (init.root) {
            this.curPath.push('/root');
            await processContainer(this.document.root, init.root);
            this.curPath.pop();
            this.document.invalidate();
        }
        return this.document;
    }
    async importResourceSchema(name, schema) {
        const convertEndpoints = async (source) => {
            if (!source)
                return;
            const output = {};
            for (const [endpointName, endpointSchema] of Object.entries(source)) {
                /* istanbul ignore next */
                if (!endpointSchema)
                    continue;
                const outputEndpoint = output[endpointName] = { ...endpointSchema };
                let parameters;
                // Resolve lazy type
                if (endpointSchema.returnType) {
                    outputEndpoint.returnType = await this.importDataType(endpointSchema.returnType);
                }
                if (endpointSchema.parameters) {
                    parameters = outputEndpoint.parameters = {};
                    for (const [kP, oP] of Object.entries(endpointSchema.parameters)) {
                        if (oP.enum) {
                            oP.type = EnumType(oP.enum, { name: kP + 'Enum' });
                        }
                        parameters[kP] = {
                            ...oP,
                            type: await this.importDataType(oP.type || 'any')
                        };
                    }
                }
            }
            return output;
        };
        if (schema.kind === 'Collection') {
            return {
                ...schema,
                kind: schema.kind,
                name,
                type: await this.importDataType(schema.type),
                actions: await convertEndpoints(schema.actions),
                operations: await convertEndpoints(schema.operations),
            };
        }
        else if (schema.kind === 'Singleton') {
            return {
                ...schema,
                kind: schema.kind,
                name,
                type: await this.importDataType(schema.type),
                actions: await convertEndpoints(schema.actions),
                operations: await convertEndpoints(schema.operations),
            };
        }
        else if (schema.kind === 'Storage') {
            return {
                ...schema,
                name,
                actions: await convertEndpoints(schema.actions),
                operations: await convertEndpoints(schema.operations),
            };
        }
        else if (schema.kind === 'Container') {
            const resources = [];
            if (schema.resources) {
                for (const [k, o] of Object.entries(schema.resources)) {
                    const rinit = await this.importResourceSchema(k, o);
                    resources.push(rinit);
                }
            }
            return {
                ...schema,
                name,
                resources,
                actions: await convertEndpoints(schema.actions)
            };
        }
        throw new TypeError(`Can not import resource schema (${schema.kind})`);
    }
    async importResourceInstance(thunk) {
        thunk = await resolveThunk(thunk);
        let ctor;
        let metadata;
        let instance;
        if (typeof thunk === 'function') {
            ctor = thunk;
        }
        else {
            ctor = Object.getPrototypeOf(thunk).constructor;
            instance = thunk;
            if (!Reflect.hasMetadata(RESOURCE_METADATA, ctor) &&
                OpraSchema.isResource(thunk) && typeof thunk.controller === 'object') {
                ctor = Object.getPrototypeOf(thunk.controller).constructor;
                metadata = thunk;
                instance = thunk.controller;
            }
        }
        metadata = metadata || Reflect.getMetadata(RESOURCE_METADATA, ctor);
        if (!metadata && OpraSchema.isResource(metadata))
            throw new TypeError(`Class "${ctor.name}" doesn't have a valid Resource metadata`);
        const convertEndpoints = async (source) => {
            if (!source)
                return;
            const output = {};
            for (const [kA, oA] of Object.entries(source)) {
                const o = output[kA] = { ...oA };
                // Resolve lazy type
                if (oA.returnType) {
                    o.returnType = await this.importDataType(oA.returnType);
                }
                if (oA.parameters) {
                    const parameters = o.parameters = {};
                    for (const [kP, oP] of Object.entries(oA.parameters)) {
                        if (oP.enum) {
                            oP.type = EnumType(oP.enum, { name: kP + 'Enum' });
                        }
                        parameters[kP] = {
                            ...oP,
                            type: await this.importDataType(oP.type || 'any')
                        };
                    }
                }
                if (oA.options?.inputOverwriteFields) {
                    const inputOverwriteFields = {};
                    for (const [kP, oP] of Object.entries(oA.options.inputOverwriteFields)) {
                        if (oP.enum) {
                            oP.type = EnumType(oP.enum, { name: kP + 'Enum' });
                        }
                        inputOverwriteFields[kP] = { ...oP, };
                        if (oP.type)
                            inputOverwriteFields[kP].type = await this.importDataType(oP.type);
                    }
                    o.options.inputOverwriteFields = inputOverwriteFields;
                }
                if (oA.options?.outputOverwriteFields) {
                    const outputOverwriteFields = {};
                    for (const [kP, oP] of Object.entries(oA.options.outputOverwriteFields)) {
                        if (oP.enum) {
                            oP.type = EnumType(oP.enum, { name: kP + 'Enum' });
                        }
                        outputOverwriteFields[kP] = { ...oP };
                        if (oP.type)
                            outputOverwriteFields[kP].type = await this.importDataType(oP.type);
                    }
                    o.options.outputOverwriteFields = outputOverwriteFields;
                }
            }
            return output;
        };
        // Clone metadata to prevent changing its contents
        const initArguments = cloneObject(metadata);
        initArguments.controller = instance;
        initArguments.ctor = ctor;
        if (initArguments.actions)
            initArguments.actions = await convertEndpoints(initArguments.actions);
        if (initArguments.kind === 'Collection' || initArguments.kind === 'Singleton') {
            const dataType = await this.importDataType((metadata).type);
            if (!dataType)
                throw new TypeError(`Unable to determine data type of "${initArguments.name}" resource`);
            if (!(dataType instanceof ComplexType))
                throw new TypeError(`Data type of "${initArguments.name}" resource is not a ComplexType`);
            initArguments.type = dataType;
            if (initArguments.operations)
                initArguments.operations = await convertEndpoints(initArguments.operations);
        }
        else if (initArguments.kind === 'Container') {
            const oldResources = initArguments.resources;
            if (Array.isArray(oldResources)) {
                initArguments.resources = [];
                for (const t of oldResources) {
                    const rinit = await this.importResourceInstance(t);
                    initArguments.resources.push(rinit);
                }
            }
        }
        return initArguments;
    }
    async createResource(container, initArguments) {
        if (initArguments.kind === 'Collection')
            return new Collection(container, initArguments);
        if (initArguments.kind === 'Singleton')
            return new Singleton(container, initArguments);
        if (initArguments.kind === 'Storage')
            return new Storage(container, initArguments);
        if (initArguments.kind === 'Container') {
            const newContainer = new Container(container, { ...initArguments, resources: undefined });
            if (initArguments.resources) {
                for (const r of initArguments.resources) {
                    const res = await this.createResource(newContainer, r);
                    newContainer.resources.set(res.name, res);
                }
            }
            return newContainer;
        }
        else
            throw new Error(`Unknown resource type ${initArguments.kind}`);
    }
}
