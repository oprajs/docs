import 'reflect-metadata';
import merge from 'putil-merge';
import { inheritPropertyInitializers, mergePrototype, } from '../../helpers/index.js';
import { OpraSchema } from '../../schema/index.js';
import { DATATYPE_METADATA } from '../constants.js';
import { MixinTypeClass } from './mixin-type-class.js';
/**
 * @class MixinType
 */
export const MixinType = function (...args) {
    // Constructor
    if (this) {
        const [document, init] = args;
        merge(this, new MixinTypeClass(document, init), { descriptor: true });
        return;
    }
    // MixinType helper
    // Filter undefined items
    const clasRefs = [...args].filter(x => !!x);
    if (!clasRefs.length)
        throw new TypeError('No Class has been provided');
    if (clasRefs.length === 1)
        return clasRefs[0];
    class MixinClass {
        constructor() {
            for (const c of clasRefs)
                inheritPropertyInitializers(this, c);
        }
    }
    const metadata = {
        kind: OpraSchema.MixinType.Kind,
        types: []
    };
    Reflect.defineMetadata(DATATYPE_METADATA, metadata, MixinClass);
    for (const c of clasRefs) {
        const itemMeta = Reflect.getMetadata(DATATYPE_METADATA, c);
        if (!(itemMeta && (itemMeta.kind === OpraSchema.ComplexType.Kind || itemMeta.kind === OpraSchema.MixinType.Kind ||
            itemMeta.kind === OpraSchema.MappedType.Kind)))
            throw new TypeError(`Class "${c.name}" is not a ${OpraSchema.ComplexType.Kind}, ${OpraSchema.MixinType.Kind} or ${OpraSchema.MappedType.Kind}`);
        metadata.types.push(c);
        mergePrototype(MixinType.prototype, c.prototype);
    }
    MixinType._applyMixin(MixinClass, ...clasRefs);
    return MixinClass;
};
MixinType.prototype = MixinTypeClass.prototype;
MixinType._applyMixin = () => void 0;
