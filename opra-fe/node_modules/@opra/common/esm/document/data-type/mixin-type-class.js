import { OpraSchema } from '../../schema/index.js';
import { ComplexType } from './complex-type.js';
import { MappedType } from './mapped-type.js';
export class MixinTypeClass extends ComplexType {
    constructor(document, init) {
        super(document, init);
        this.kind = OpraSchema.MixinType.Kind;
        const own = this.own;
        own.types = [];
        const MixinType = Object.getPrototypeOf(this).constructor;
        for (const base of init.types) {
            if (!(base instanceof ComplexType || base instanceof MixinType || base instanceof MappedType))
                throw new TypeError(`${OpraSchema.MixinType.Kind} shall contain ${OpraSchema.ComplexType.Kind}, ` +
                    `${OpraSchema.MixinType.Kind} of ${OpraSchema.MappedType.Kind} types.`);
            own.types.push(base);
            if (base.additionalFields === true && this.additionalFields !== true) {
                // @ts-ignore
                this.additionalFields = true;
            }
            else if (base.additionalFields === 'error' && !this.additionalFields) {
                // @ts-ignore
                this.additionalFields = 'error';
            }
            this.fields.setAll(base.fields);
        }
        this.types = [...own.types];
    }
    // @ts-ignore
    exportSchema() {
        const out = super.exportSchema();
        out.types = this.own.types.map(t => t.name ? t.name : t.exportSchema());
        return out;
    }
}
