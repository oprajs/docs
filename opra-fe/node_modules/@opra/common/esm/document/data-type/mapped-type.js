import 'reflect-metadata';
import merge from 'putil-merge';
import { inheritPropertyInitializers, mergePrototype } from '../../helpers/index.js';
import { OpraSchema } from '../../schema/index.js';
import { DATATYPE_METADATA } from '../constants.js';
import { getIsInheritedPredicateFn, MappedTypeClass } from './mapped-type-class.js';
/**
 *
 */
export function PickType(classRef, keys) {
    return MappedType(classRef, { pick: keys });
}
/**
 *
 */
export function OmitType(classRef, keys) {
    return MappedType(classRef, { omit: keys });
}
/**
 *
 */
export function PartialType(classRef, keys) {
    return MappedType(classRef, { partial: keys || true });
}
/**
 * @class MappedType
 */
export const MappedType = function (...args) {
    // Constructor
    if (this) {
        const [document, init] = args;
        merge(this, new MappedTypeClass(document, init), { descriptor: true });
        return;
    }
    // MappedType helper
    const [mappedSource, options] = args;
    const isInheritedPredicate = getIsInheritedPredicateFn(options.pick, options.omit);
    class MappedClass {
        constructor() {
            inheritPropertyInitializers(this, mappedSource, isInheritedPredicate);
        }
    }
    mergePrototype(MappedClass.prototype, mappedSource.prototype);
    // const mappedTypeMetadata: MappedType.TypeMapping[] = [];
    const m = Reflect.getOwnMetadata(DATATYPE_METADATA, mappedSource);
    if (!m)
        throw new TypeError(`Class "${mappedSource}" doesn't have datatype metadata information`);
    if (!(m.kind === OpraSchema.ComplexType.Kind || m.kind === OpraSchema.MappedType.Kind || m.kind === OpraSchema.MixinType.Kind))
        throw new TypeError(`Class "${mappedSource}" is not a ${OpraSchema.ComplexType.Kind}`);
    const metadata = {
        kind: 'MappedType',
        base: mappedSource
    };
    if (options.pick)
        metadata.pick = options.pick;
    if (options.omit)
        metadata.omit = options.omit;
    if (options.partial)
        metadata.partial = options.partial;
    Reflect.defineMetadata(DATATYPE_METADATA, metadata, MappedClass);
    MappedType._applyMixin(MappedClass, mappedSource, {
        ...options,
        isInheritedPredicate
    });
    return MappedClass;
};
MappedType.prototype = MappedTypeClass.prototype;
MappedType._applyMixin = () => void 0;
