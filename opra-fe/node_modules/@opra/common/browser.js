/****************************************
* All rights reserved PanatesÂ® 2022-2024
* http://www.panates.com
*****************************************/

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../../build/common/esm/document/index.js
import "reflect-metadata";

// ../../build/common/esm/document/constants.js
var DATATYPE_METADATA = Symbol("DATATYPE_METADATA");
var RESOURCE_METADATA = Symbol("RESOURCE_METADATA");
var DECORATOR = Symbol("DECORATOR");
var NAMESPACE_PATTERN = /([a-z$_]\w+)(?::.+)?/i;
var TYPENAME_PATTERN = /^(.*)Type(\d*)$/;
var SORT_FIELD_PATTERN = /^([+-])?([a-z$_][\w.]+)$/;

// ../../build/common/esm/document/resource/container.js
import merge3 from "putil-merge";

// ../../build/common/esm/helpers/function-utils.js
import promisify from "putil-promisify";

// ../../build/common/esm/helpers/type-guards.js
function isConstructor(fn) {
  return typeof fn === "function" && fn.prototype && fn.prototype.constructor === fn && fn.prototype.constructor.name !== "Function" && fn.prototype.constructor.name !== "embedded";
}
__name(isConstructor, "isConstructor");
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
__name(isStream, "isStream");
function isReadable(x) {
  return isStream(x) && typeof x._read === "function" && typeof x._readableState === "object";
}
__name(isReadable, "isReadable");
function isWritable(x) {
  return isStream(x) && typeof x._write === "function";
}
__name(isWritable, "isWritable");
function isReadableStream(x) {
  return isStream(x) && typeof x.getReader === "function" && typeof x.pipeThrough === "function" && typeof x.pipeTo === "function";
}
__name(isReadableStream, "isReadableStream");
function isBlob(x) {
  return x !== null && typeof x === "object" && typeof x.size === "number" && typeof x.arrayBuffer === "function" && typeof x.stream === "function";
}
__name(isBlob, "isBlob");
function isFormData(x) {
  return x !== null && typeof x.constructor === "function" && x.constructor.name === "FormData" && typeof x.append === "function" && typeof x.getAll === "function";
}
__name(isFormData, "isFormData");
function isURL(x) {
  return x !== null && typeof x == "object" && typeof x.host === "string" && typeof x.href === "string";
}
__name(isURL, "isURL");
function isIterable(x) {
  return Symbol.iterator in x;
}
__name(isIterable, "isIterable");
function isAsyncIterable(x) {
  return Symbol.asyncIterator in x;
}
__name(isAsyncIterable, "isAsyncIterable");

// ../../build/common/esm/helpers/function-utils.js
async function resolveThunk(thunk) {
  thunk = promisify.isPromise(thunk) ? await thunk : thunk;
  if (typeof thunk === "function") {
    if (isConstructor(thunk))
      return thunk;
    return resolveClass(thunk());
  }
  return thunk;
}
__name(resolveThunk, "resolveThunk");
async function resolveClass(thunk) {
  thunk = promisify.isPromise(thunk) ? await thunk : thunk;
  if (typeof thunk !== "function")
    throw new Error(`No Class type resolved`);
  if (isConstructor(thunk))
    return thunk;
  return resolveClass(thunk());
}
__name(resolveClass, "resolveClass");

// ../../build/common/esm/helpers/get-stack-filename.js
var PATH_PATTERN = /^(?:file:\/\/)?(.+)$/;
function getStackFileName(position = 1) {
  if (position >= Error.stackTraceLimit) {
    throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
  }
  const oldPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, stack2) => stack2;
  const stack = new Error().stack;
  Error.prepareStackTrace = oldPrepareStackTrace;
  if (stack !== null && typeof stack === "object") {
    const s = stack[position] ? stack[position].getFileName() : void 0;
    const m = s ? PATH_PATTERN.exec(s) : void 0;
    return m ? m[1] : "";
  }
  return "";
}
__name(getStackFileName, "getStackFileName");

// ../../build/common/esm/helpers/is-url-string.js
var URL_PATTERN = /^(https?:\/\/.)[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/i;
function isUrlString(url) {
  return URL_PATTERN.test(url);
}
__name(isUrlString, "isUrlString");
var isAbsoluteUrl = /* @__PURE__ */ __name((urlString) => {
  return !urlString.includes("://") && new URL(urlString, "http://tempuri.org/").host !== "tempuri.org";
}, "isAbsoluteUrl");

// ../../build/common/esm/helpers/mixin-utils.js
function mergePrototype(targetProto, baseProto, filter) {
  for (const k of Object.getOwnPropertyNames(baseProto)) {
    if (k === "constructor" || k === "__proto__" || k === "toJSON" || k === "toString" || filter && !filter(k))
      continue;
    Object.defineProperty(targetProto, k, Object.getOwnPropertyDescriptor(baseProto, k) || /* @__PURE__ */ Object.create(null));
  }
}
__name(mergePrototype, "mergePrototype");
function inheritPropertyInitializers(target, clazz, isPropertyInherited = (key) => true) {
  try {
    const tempInstance = new clazz();
    const propertyNames = Object.getOwnPropertyNames(tempInstance);
    propertyNames.filter((propertyName) => typeof tempInstance[propertyName] !== "undefined" && typeof target[propertyName] === "undefined").filter((propertyName) => isPropertyInherited(propertyName)).forEach((propertyName) => {
      target[propertyName] = tempInstance[propertyName];
    });
  } catch {
  }
}
__name(inheritPropertyInitializers, "inheritPropertyInitializers");

// ../../build/common/esm/helpers/object-utils.js
import isPlainObject from "putil-isplainobject";
import merge from "putil-merge";
function cloneObject(obj, jsonOnly) {
  return merge({}, obj, {
    deep: (v) => isPlainObject(v) && !v[DATATYPE_METADATA],
    filter: (source, key) => {
      const v = source[key];
      return v != null && !jsonOnly || typeof v !== "function" && (typeof v !== "object" || isPlainObject(v) || Array.isArray(v));
    }
  });
}
__name(cloneObject, "cloneObject");
function omitUndefined(obj, recursive) {
  if (!(obj && typeof obj === "object"))
    return obj;
  for (const k of Object.keys(obj)) {
    if (obj[k] === void 0)
      delete obj[k];
    else if (recursive && typeof obj[k] === "object")
      omitUndefined(obj[k]);
  }
  return obj;
}
__name(omitUndefined, "omitUndefined");
function omitNullish(obj, recursive) {
  if (!(obj && typeof obj === "object"))
    return obj;
  for (const k of Object.keys(obj)) {
    if (obj[k] == null)
      delete obj[k];
    else if (recursive && isPlainObject(obj[k]))
      omitNullish(obj[k]);
  }
  return obj;
}
__name(omitNullish, "omitNullish");

// ../../build/common/esm/helpers/path-to-object-tree.js
var DOT_PATTERN = /^([^.]+)\.(.*)$/;
function pathToObjectTree(arr, lowerCaseKeys) {
  if (!(arr && arr.length))
    return;
  return _pathToObjectTree(arr, {}, lowerCaseKeys);
}
__name(pathToObjectTree, "pathToObjectTree");
function _pathToObjectTree(arr, target, lowerCaseKeys) {
  for (let k of arr) {
    if (lowerCaseKeys)
      k = k.toLowerCase();
    const m = DOT_PATTERN.exec(k);
    if (m) {
      const key = m[1];
      if (target[key] === true)
        continue;
      const sub = target[key] = typeof target[key] === "object" ? target[key] : {};
      _pathToObjectTree([m[2]], sub);
    } else {
      target[k] = true;
    }
  }
  return target;
}
__name(_pathToObjectTree, "_pathToObjectTree");

// ../../build/common/esm/helpers/responsive-map.js
var _a;
var _b;
var _c;
var _d;
function isMap(v) {
  return v && typeof v.forEach === "function";
}
__name(isMap, "isMap");
var kKeyMap = Symbol.for("kKeyMap");
var kKeyOrder = Symbol.for("kKeyOrder");
var kWellKnownKeys = Symbol.for("kWellKnownKeys");
var kOptions = Symbol.for("kOptions");
var ResponsiveMap = class extends Map {
  static {
    __name(this, "ResponsiveMap");
  }
  constructor(init, options) {
    super();
    this[_a] = /* @__PURE__ */ new Map();
    this[_b] = [];
    this[_c] = /* @__PURE__ */ new Map();
    this[_d] = { caseSensitive: false };
    this[kOptions].caseSensitive = !!options?.caseSensitive;
    if (options?.wellKnownKeys)
      options.wellKnownKeys.forEach((k) => this[kWellKnownKeys].set(k.toLowerCase(), k));
    if (init)
      this.setAll(init);
  }
  clear() {
    super.clear();
    this[kKeyMap].clear();
    this[kKeyOrder] = [];
  }
  get(key) {
    const orgKey = this._getOriginalKey(key);
    return super.get(orgKey);
  }
  has(key) {
    return this[kKeyMap].has(this._getStoringKey(key));
  }
  set(key, value) {
    key = this._getOriginalKey(key);
    this[kKeyMap].set(this._getStoringKey(key), key);
    if (!this[kKeyOrder].includes(key))
      this[kKeyOrder].push(key);
    return super.set(key, value);
  }
  setAll(source) {
    if (isMap(source))
      source.forEach((v, k) => this.set(k, v));
    else
      Object.keys(source).forEach((k) => this.set(k, source[k]));
    return this;
  }
  keys() {
    return [...this[kKeyOrder]][Symbol.iterator]();
  }
  values() {
    let i = -1;
    const arr = [...this[kKeyOrder]];
    const map = this;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        i++;
        return {
          done: i >= arr.length,
          value: map.get(arr[i])
        };
      }
    };
  }
  entries() {
    let i = -1;
    const arr = [...this[kKeyOrder]];
    const map = this;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        i++;
        return {
          done: i >= arr.length,
          value: [arr[i], map.get(arr[i])]
        };
      }
    };
  }
  delete(key) {
    const orgKey = this._getOriginalKey(key);
    const k = this._getStoringKey(key);
    this[kKeyMap].delete(k);
    const i = this[kKeyOrder].indexOf(orgKey);
    if (i >= 0)
      this[kKeyOrder].splice(i, 1);
    return super.delete(orgKey);
  }
  sort(compareFn) {
    if (compareFn)
      this[kKeyOrder].sort(compareFn);
    else if (this[kOptions].caseSensitive)
      this[kKeyOrder].sort();
    else
      this[kKeyOrder].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
    return this;
  }
  getProxy(handler) {
    const _this = this;
    const finalHandler = {
      get(target, p, receiver) {
        if (typeof p === "string")
          return _this.get(p);
        return Reflect.get(target, p, receiver);
      },
      set(target, p, newValue, receiver) {
        if (typeof p === "string") {
          _this.set(p, newValue);
          return true;
        }
        return Reflect.set(target, p, newValue, receiver);
      },
      has(target, p) {
        if (typeof p === "string")
          return _this.has(p);
        return Reflect.has(target, p);
      },
      ownKeys() {
        return Array.from(_this.keys()).map((x) => x.toLowerCase());
      },
      getPrototypeOf() {
        return Object.prototype;
      },
      defineProperty(target, property, attributes) {
        if (typeof property === "string") {
          _this.set(property, attributes.value);
          return true;
        }
        return false;
      },
      deleteProperty(target, p) {
        if (typeof p === "string")
          return _this.delete(p);
        return false;
      },
      getOwnPropertyDescriptor(target, key) {
        if (typeof key === "string") {
          const value = finalHandler.get(target, key);
          return { configurable: true, enumerable: true, writable: true, value };
        }
      },
      ...handler
    };
    return new Proxy({}, finalHandler);
  }
  toObject() {
    return Object.keys(this.keys()).reduce((trg, k) => {
      trg[k] = this.get(k);
      return trg;
    }, {});
  }
  [(_a = kKeyMap, _b = kKeyOrder, _c = kWellKnownKeys, _d = kOptions, Symbol.iterator)]() {
    return this.entries();
  }
  _getOriginalKey(key) {
    if (!key || this[kOptions].caseSensitive)
      return key;
    return this[kKeyMap].get(key.toLowerCase()) ?? (this[kWellKnownKeys].get(key.toLowerCase()) ?? key);
  }
  _getStoringKey(key) {
    if (this[kOptions].caseSensitive)
      return key;
    return key.toLowerCase();
  }
};

// ../../build/common/esm/i18n/i18n.js
import { splitString, tokenize } from "fast-tokenizer";
import i18next from "@browsery/i18next";

// ../../build/common/esm/i18n/string-utils.js
var unescapeRegEx = /\\(.)/g;
var escapeRegEx = /(\\)/g;
function escapeString(s) {
  return s.replace(escapeRegEx, "\\\\");
}
__name(escapeString, "escapeString");
function unescapeString(s) {
  return s.replace(unescapeRegEx, "$1");
}
__name(unescapeString, "unescapeString");

// ../../build/common/esm/i18n/i18n.js
var BaseI18n = Object.getPrototypeOf(i18next.createInstance()).constructor;
var I18n = class _I18n extends BaseI18n {
  static {
    __name(this, "I18n");
  }
  async init(arg0, arg1) {
    const options = typeof arg0 === "object" ? arg0 : {};
    const callback = typeof arg0 === "function" ? arg0 : arg1;
    try {
      const t = await super.init(options, callback);
      const formatter = this.services.formatter;
      formatter.add("lowercase", (value, lng) => value.toLocaleLowerCase(lng));
      formatter.add("uppercase", (value, lng) => value.toLocaleUpperCase(lng));
      formatter.add("upperFirst", (value, lng) => value.charAt(0).toLocaleUpperCase(lng) + value.substring(1));
      if (options?.resources) {
        for (const lang of Object.keys(options.resources)) {
          const langObj = options.resources[lang];
          for (const ns of Object.keys(langObj)) {
            this.addResourceBundle(lang, ns, langObj[ns], false, true);
          }
        }
      }
      if (callback)
        callback(null, t);
      return t;
    } catch (err) {
      if (callback)
        callback(err, this.t);
      throw err;
    }
  }
  deep(input, options) {
    if (input == null)
      return input;
    const objectStack = /* @__PURE__ */ new WeakMap();
    return this._deepTranslate(input, objectStack, options);
  }
  createInstance(options = {}, callback) {
    return new _I18n(options, callback);
  }
  static createInstance(options, callback) {
    return new _I18n(options, callback);
  }
  _deepTranslate(input, objectStack, options) {
    if (input == null)
      return input;
    if (options?.ignore && options.ignore(input, this))
      return input;
    if (typeof input === "object" && objectStack.has(input))
      return objectStack.get(input);
    if (typeof input === "string") {
      let s = "";
      for (let token of tokenize(input, {
        brackets: { "$t(": ")" },
        quotes: true,
        keepQuotes: true,
        keepBrackets: true,
        keepDelimiters: true
      })) {
        if (token.startsWith("$t(") && token.endsWith(")")) {
          token = token.substring(3, token.length - 1);
          const a = splitString(token, { delimiters: "?", quotes: true, brackets: { "{": "}" } });
          const fallback = unescapeString(token.substring((a[0] || "").length + 1));
          token = a[0] || "";
          const keys = [];
          let opts = null;
          for (const token2 of tokenize(token, { delimiters: ",", quotes: true, brackets: { "{": "}" } })) {
            if (token2.startsWith("{")) {
              opts = JSON.parse(token2);
              continue;
            }
            keys.push(token2);
          }
          const k = keys.length > 1 ? "$t(" + keys.join(",") + ")" : keys[0];
          s += fallback ? this.t(k, fallback, { ...options, ...opts }) : this.t(k, { ...options, ...opts });
          continue;
        }
        s += token;
      }
      return s;
    }
    if (Array.isArray(input)) {
      const out = Array(input.length);
      objectStack.set(input, out);
      for (let i = 0, l = input.length; i < l; i++) {
        out[i] = this._deepTranslate(input[i], objectStack, options);
      }
      objectStack.delete(input);
      return out;
    }
    if (typeof input === "object") {
      if (Buffer.isBuffer(input))
        return input;
      if (Buffer.isBuffer(input) || input instanceof Symbol || input instanceof RegExp || input instanceof Map || input instanceof Set || input instanceof WeakMap || input instanceof WeakSet)
        return input;
      const out = {};
      objectStack.set(input, out);
      const keys = Object.keys(input);
      for (let i = 0, l = keys.length; i < l; i++) {
        const k = keys[i];
        out[k] = this._deepTranslate(input[k], objectStack, options);
      }
      objectStack.delete(input);
      return out;
    }
    return input;
  }
  static get defaultInstance() {
    return defaultInstance;
  }
};
var defaultInstance = I18n.createInstance();

// ../../build/common/esm/i18n/translate.js
var bracketRegEx = /(\))/g;
function translate(key, arg0, arg1) {
  const options = arg0 && typeof arg0 === "object" ? arg0 : void 0;
  const fallback = typeof arg0 === "string" ? arg0 : arg1;
  return "$t(" + key + (options ? "," + JSON.stringify(options) : "") + (fallback ? "?" + escapeString(fallback).replace(bracketRegEx, "\\$1") : "") + ")";
}
__name(translate, "translate");

// ../../build/common/esm/i18n/index.js
var i18n = I18n.createInstance();
i18n.init().catch(() => void 0);

// ../../build/common/esm/exception/opra-exception.js
var OpraException = class extends Error {
  static {
    __name(this, "OpraException");
  }
  constructor(issue, arg1, arg2) {
    super("Unknown error");
    this.status = 500;
    let cause = arg1 && arg1 instanceof Error ? arg1 : void 0;
    this.status = (typeof arg1 === "number" ? arg1 : Number(arg2)) || 500;
    if (issue instanceof Error)
      cause = issue;
    if (cause && cause instanceof Error) {
      this.cause = cause;
      if (cause.stack)
        this.stack = cause.stack;
    }
    if (typeof issue === "string")
      this.initString(issue);
    else if (issue instanceof Error)
      this.initError(issue);
    else
      this.init(issue);
    this.message = this.message || this.constructor.name;
  }
  setStatus(status) {
    this.status = status;
    return this;
  }
  toString() {
    return i18n.deep(this.message);
  }
  toJSON() {
    const env = process.env.NODE_ENV;
    return omitUndefined({
      message: this.message,
      severity: this.severity,
      system: this.system,
      code: this.code,
      details: this.details,
      stack: env === "dev" || env === "development" || env === "test" ? this.stack?.split("\n") : void 0
    }, true);
  }
  init(issue) {
    this.message = issue?.message || this.constructor.name;
    this.severity = issue?.severity || "error";
    if (issue) {
      this.system = issue.system;
      this.code = issue.code;
      this.details = issue.details;
    }
  }
  initString(issue) {
    this.init({
      message: String(issue || "") || this.constructor.name,
      severity: "error",
      code: this.constructor.name
    });
  }
  initError(issue) {
    if (typeof issue.status === "number")
      this.status = issue.status;
    else if (typeof issue.getStatus === "function")
      this.status = issue.getStatus();
    this.init({
      message: issue.message,
      severity: issue.severity || "error",
      code: issue.code || issue.constructor.name
    });
  }
};

// ../../build/common/esm/exception/http-errors/bad-request.error.js
var BadRequestError = class extends OpraException {
  static {
    __name(this, "BadRequestError");
  }
  constructor() {
    super(...arguments);
    this.status = 400;
  }
  init(issue) {
    super.init({
      message: translate("error:BAD_REQUEST", "Bad request"),
      code: "BAD_REQUEST",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/failed-dependency.error.js
var FailedDependencyError = class extends OpraException {
  static {
    __name(this, "FailedDependencyError");
  }
  constructor() {
    super(...arguments);
    this.status = 424;
  }
  init(issue) {
    super.init({
      message: translate("error:FAILED_DEPENDENCY", "The request failed due to failure of a previous request"),
      code: "FAILED_DEPENDENCY",
      ...issue
    });
  }
};

// ../../build/common/esm/http/opra-url.js
import { splitString as splitString3, tokenize as tokenize3 } from "fast-tokenizer";

// ../../build/common/esm/http/opra-url-path.js
import { splitString as splitString2, tokenize as tokenize2 } from "fast-tokenizer";
import isPlainObject2 from "putil-isplainobject";
var _a2;
var nodeInspectCustom = Symbol.for("nodejs.util.inspect.custom");
var kLength = Symbol.for("kLength");
var pathComponentRegEx = /^([^/?#:@]+)(?:@([^/?#:]*))?(?:::(.*))?$/;
var decimalPattern = /^[+-]?\d+(\.\d+)?$/;
var booleanPattern = /^true|false$/;
var OpraURLPath = class _OpraURLPath {
  static {
    __name(this, "OpraURLPath");
  }
  constructor(...init) {
    this[_a2] = 0;
    this._resolve(init.filter((x) => x));
  }
  get length() {
    return this[kLength];
  }
  slice(start, end) {
    return new _OpraURLPath(...[...this].slice(start, end));
  }
  resolve(...items) {
    this._resolve(items);
    return this;
  }
  join(...items) {
    this._resolve(items, true);
    return this;
  }
  isRelativeTo(basePath) {
    basePath = basePath instanceof _OpraURLPath ? basePath : new _OpraURLPath(basePath);
    let i;
    for (i = 0; i < basePath.length; i++) {
      if (String(this[i]) !== String(basePath[i]))
        return false;
    }
    return true;
  }
  forEach(callback) {
    let i = 0;
    for (const item of this.values()) {
      callback.call(this, item, i++, this);
    }
  }
  values() {
    const arr = new Array(this.length);
    for (let i = 0; i < this.length; i++)
      arr[i] = this[i];
    return arr.values();
  }
  toString() {
    const v = Array.from(this).join("/");
    return v ? "/" + v : "";
  }
  /* istanbul ignore next */
  [(_a2 = kLength, nodeInspectCustom)]() {
    return `(UrlPath [${this.toString()}])`;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  _resolve(items, join) {
    let paths = (Array.isArray(items) ? items : [items]).map((item) => {
      if (typeof item === "object" && !(item instanceof _OpraURLPath || item instanceof OpraURLPathComponent)) {
        item = new OpraURLPathComponent(item);
        if (item.resource.includes("/")) {
          const subPath = new _OpraURLPath(item.resource);
          subPath[subPath.length - 1].key = item.key;
          return String(subPath);
        }
      }
      item = String(item);
      if (item.includes("?"))
        item = splitString2(item, {
          delimiters: "?",
          quotes: true,
          brackets: true,
          keepBrackets: true,
          keepQuotes: true
        })[0];
      if (item.includes("#"))
        item = splitString2(item, {
          delimiters: "#",
          quotes: true,
          brackets: true,
          keepBrackets: true,
          keepQuotes: true
        })[0];
      return join ? removeLeadingSeparator(item) : item;
    });
    const oldLength = this.length;
    let n = 0;
    if (!join) {
      for (n = paths.length - 1; n >= 0; n--) {
        if (String(items[n]).startsWith("/"))
          break;
      }
      if (n > 0)
        paths = paths.slice(n);
    }
    const newPath = paths[0]?.startsWith("/") ? [] : Array.from(this).map(String);
    for (let i = 0; i < paths.length; i++) {
      const pathTokenizer = tokenize2(paths[i], { delimiters: "/", quotes: true, brackets: true });
      for (const x of pathTokenizer) {
        if (!x)
          continue;
        if (x.startsWith(".")) {
          if (x === ".")
            continue;
          if (x === "..") {
            newPath.pop();
            continue;
          }
          throw new TypeError("Invalid path string");
        }
        newPath.push(x);
      }
    }
    for (let i = 0; i < newPath.length; i++) {
      this[i] = OpraURLPathComponent.parse(newPath[i]);
    }
    for (let i = newPath.length; i < oldLength; i++) {
      delete this[i];
    }
    this[kLength] = newPath.length;
  }
  static join(...items) {
    const instance = new _OpraURLPath();
    instance.join(...items);
    return instance;
  }
  static resolve(...items) {
    return new _OpraURLPath(...items);
  }
  static relative(source, basePath) {
    source = source instanceof _OpraURLPath ? source : new _OpraURLPath(source);
    basePath = basePath instanceof _OpraURLPath ? basePath : new _OpraURLPath(basePath);
    let i;
    for (i = 0; i < basePath.length; i++) {
      if (String(source[i]) !== String(basePath[i]))
        return;
    }
    return new _OpraURLPath(Array.from(source).slice(i).join("/"));
  }
};
var OpraURLPathComponent = class _OpraURLPathComponent {
  static {
    __name(this, "OpraURLPathComponent");
  }
  constructor(init) {
    this.resource = init.resource;
    this.key = init.key;
    this.args = init.args;
    this.typeCast = init.typeCast;
  }
  toString() {
    let out = encodeURIComponent(this.resource).replace(/%24/, "$");
    if (this.key) {
      if (typeof this.key === "object" && isPlainObject2(this.key)) {
        const arr = [];
        for (const k of Object.keys(this.key)) {
          let v = this.key[k];
          if (typeof v === "number" || typeof v === "boolean")
            v = String(v);
          else
            v = '"' + encodeURIComponent(String(v)) + '"';
          arr.push(encodeURIComponent(k) + "=" + v);
        }
        out += "@" + arr.join(";");
      } else
        out += "@" + encodeURIComponent(String(this.key));
    }
    if (this.args) {
      const arr = [];
      for (const k of Object.keys(this.args)) {
        arr.push(encodeURIComponent(k) + "=" + encodeURIComponent(String(this.args[k])));
      }
      out += "(" + arr.join(";") + ")";
    }
    if (this.typeCast)
      out += "::" + encodeURIComponent(this.typeCast);
    return out;
  }
  /* istanbul ignore next */
  [nodeInspectCustom]() {
    return this.toString();
  }
  /**
   * Factory method.
   * @param input
   */
  static parse(input) {
    const m = pathComponentRegEx.exec(input);
    if (!m)
      throw Object.assign(new TypeError("Invalid Opra URL"), {
        code: "ERR_INVALID_OPRA_URL",
        input
      });
    let key;
    if (m[2]) {
      const s = decodeURIComponent(m[2]);
      const b = splitString2(s, { delimiters: ";", quotes: true, escape: false, keepQuotes: true, keepBrackets: true });
      for (const n of b) {
        const c = splitString2(n, { delimiters: "=", quotes: true, escape: false, keepQuotes: true, keepBrackets: true });
        if (b.length > 1 && c.length < 2 || (key && (c.length >= 2 && typeof key !== "object") || c.length < 2 && typeof key === "object"))
          throw Object.assign(new TypeError("Invalid Opra URL. name:value pair required for multiple key format"), {
            pathComponent: input,
            code: "ERR_INVALID_OPRA_URL"
          });
        if (c.length >= 2) {
          key = key || {};
          const k = c.shift() || "";
          let v = c.join("=");
          if (decimalPattern.test(v))
            v = Number(v);
          else if (booleanPattern.test(v))
            v = Boolean(v);
          else if (v.startsWith('"') && v.endsWith('"'))
            v = v.substring(1, v.length - 1);
          else if (v.startsWith("'") && v.endsWith("'"))
            v = v.substring(1, v.length - 1);
          key[k] = v;
        } else {
          if (decimalPattern.test(c[0]))
            key = Number(c[0]);
          else if (booleanPattern.test(c[0]))
            key = Boolean(c[0]);
          else
            key = c[0];
        }
      }
      return new _OpraURLPathComponent({
        resource: decodeURIComponent(m[1]),
        key,
        typeCast: m[3] ? decodeURIComponent(m[3]) : void 0
      });
    }
    return new _OpraURLPathComponent({
      resource: decodeURIComponent(m[1]),
      typeCast: m[3] ? decodeURIComponent(m[3]) : void 0
    });
  }
};
function removeLeadingSeparator(s) {
  const m = /^\/*(.*)/.exec(s);
  return m?.[1] || s;
}
__name(removeLeadingSeparator, "removeLeadingSeparator");

// ../../build/common/esm/http/opra-url.js
var _a3;
var nodeInspectCustom2 = Symbol.for("nodejs.util.inspect.custom");
var urlRegEx = /^(?:((?:[A-Z][A-Z+-.]+:)+)\/\/([^/?]+))?(.*)?$/i;
var schemeRegEx = /^([A-Z][A-Z+-.]+:?)+$/i;
var hostRegEx = /^([^/:]+)(?::(\d+))?$/;
var hostnameRegEx = /^([^/:]+)$/;
var kContext = Symbol.for("kContext");
var kPath = Symbol.for("kPath");
var kSearchParams = Symbol.for("kSearchParams");
var OpraURL = class _OpraURL {
  static {
    __name(this, "OpraURL");
  }
  constructor(input, base) {
    this[_a3] = {
      protocol: "",
      username: "",
      hostname: "",
      port: "",
      hash: "",
      password: ""
    };
    this[kSearchParams] = new URLSearchParams();
    this[kPath] = new OpraURLPath();
    if (input)
      this._parse(String(input));
    if (base && !this.host) {
      const baseUrl = base instanceof _OpraURL ? base : new _OpraURL(base);
      this[kContext].protocol = baseUrl.protocol;
      this[kContext].hostname = baseUrl.hostname;
      this[kContext].username = baseUrl.username;
      this[kContext].password = baseUrl.password;
      this[kContext].port = baseUrl.port;
      this.path = OpraURLPath.join(baseUrl.path, this.path);
    }
  }
  get address() {
    if (this[kContext].address == null) {
      let address = "";
      if (this[kContext].hostname) {
        address += (this[kContext].protocol || "http:") + "//" + (this[kContext].username || this[kContext].password ? (this[kContext].username ? encodeURIComponent(this[kContext].username) : "") + (this[kContext].password ? ":" + encodeURIComponent(this[kContext].password) : "") + "@" : "") + this.host;
      }
      this[kContext].address = address + (this.pathname !== "/" ? this.pathname : "");
    }
    return this[kContext].address;
  }
  get host() {
    return this.hostname ? this.hostname + (this.port ? ":" + this.port : "") : "";
  }
  set host(v) {
    if (v) {
      const m = hostRegEx.exec(v);
      if (!m)
        throw Object.assign(new TypeError("Invalid host"), {
          host: v,
          code: "ERR_INVALID_URL"
        });
      this.hostname = m[1];
      this.port = m[2] || "";
    } else {
      this.hostname = "";
      this.port = "";
    }
  }
  get hostname() {
    return this[kContext].hostname;
  }
  set hostname(v) {
    if (v) {
      if (!hostnameRegEx.test(v))
        throw Object.assign(new TypeError("Invalid hostname"), {
          hostname: v,
          code: "ERR_INVALID_URL"
        });
      this[kContext].hostname = v;
    } else
      this[kContext].hostname = "";
    this.invalidate();
  }
  get href() {
    return this.address + this.search + this.hash;
  }
  get password() {
    return this[kContext].password;
  }
  set password(v) {
    this[kContext].password = v ?? "";
    this.invalidate();
  }
  get port() {
    return this[kContext].port;
  }
  set port(value) {
    if (value) {
      const v = typeof value === "number" ? value : parseInt(value, 10);
      if (isNaN(v) || v < 1 || v > 65535 || v % 1 > 0)
        throw Object.assign(new TypeError(`Invalid port number (${value})`), {
          hostname: v,
          code: "ERR_INVALID_URL"
        });
      this[kContext].port = String(v);
    } else
      this[kContext].port = "";
    this.invalidate();
  }
  get protocol() {
    return this[kContext].protocol;
  }
  set protocol(v) {
    if (v) {
      if (!schemeRegEx.test(v))
        throw Object.assign(new TypeError("Invalid protocol"), {
          protocol: v,
          code: "ERR_INVALID_URL"
        });
      this[kContext].protocol = v + (v.endsWith(":") ? "" : ":");
    } else
      this[kContext].protocol = "";
    this.invalidate();
  }
  get username() {
    return this[kContext].username;
  }
  set username(v) {
    this[kContext].username = v ?? "";
    this.invalidate();
  }
  get origin() {
    return this.hostname ? this.protocol + "//" + this.hostname : "";
  }
  get path() {
    return this[kPath];
  }
  set path(path) {
    this[kPath] = path instanceof OpraURLPath ? path : new OpraURLPath(path);
    this[kContext].pathname = String(this[kPath]);
    this.invalidate();
  }
  get pathname() {
    if (this[kContext].pathname == null)
      this[kContext].pathname = this.path.toString() || "/";
    return this[kContext].pathname;
  }
  set pathname(v) {
    this[kPath] = new OpraURLPath(v);
    this.invalidate();
  }
  get hash() {
    return this[kContext].hash;
  }
  set hash(v) {
    this[kContext].hash = v ? v.startsWith("#") ? v : "#" + v : "";
  }
  get search() {
    const s = this[kSearchParams].toString();
    return s ? "?" + s : "";
  }
  set search(v) {
    this[kSearchParams] = new URLSearchParams(v);
  }
  get searchParams() {
    return this[kSearchParams];
  }
  set setSearchParams(v) {
    this[kSearchParams] = v;
  }
  invalidate() {
    this[kContext].address = void 0;
    this[kContext].pathname = void 0;
  }
  join(...items) {
    this.path = this.path.join(...items);
    this.invalidate();
    return this;
  }
  resolve(...items) {
    this.path = this.path.resolve(...items);
    this.invalidate();
    return this;
  }
  toString() {
    return this.href;
  }
  _parse(input) {
    const m = urlRegEx.exec(input);
    if (!m)
      throw Object.assign(new TypeError("Invalid URL"), {
        input,
        code: "ERR_INVALID_URL"
      });
    this.protocol = m[1];
    const isAbsolute = !!m[2];
    if (isAbsolute) {
      let tokens = splitString3(m[2], { delimiters: "@" });
      if (tokens.length > 1) {
        this.host = tokens[1];
        tokens = splitString3(tokens[0], { delimiters: ":" });
        this.username = tokens[0] ? decodeURIComponent(tokens[0]) : "";
        this.password = tokens[1] ? decodeURIComponent(tokens[1]) : "";
      } else
        this.host = tokens[0];
    } else {
      this.host = "";
      this.username = "";
      this.password = "";
    }
    input = m[3] || "";
    let tokenizer = tokenize3(input, { delimiters: "#", quotes: true, brackets: true });
    input = tokenizer.next() || "";
    this.hash = tokenizer.join("#");
    tokenizer = tokenize3(input, { delimiters: "?", quotes: true, brackets: true });
    this.path = new OpraURLPath(tokenizer.next());
    this.search = tokenizer.join("&");
  }
  /* istanbul ignore next */
  [(_a3 = kContext, nodeInspectCustom2)]() {
    return {
      protocol: this.protocol,
      username: this.username,
      password: this.password,
      host: this.host,
      hostname: this.hostname,
      origin: this.origin,
      path: this.path,
      pathname: this.pathname,
      search: this.search,
      hash: this.hash
    };
  }
};
OpraURL.kContext = kContext;
OpraURL.kPath = kPath;
OpraURL.kParams = kSearchParams;

// ../../build/common/esm/http/enums/http-headers-codes.enum.js
var HttpHeaderCodes;
(function(HttpHeaderCodes2) {
  HttpHeaderCodes2["X_Opra_Version"] = "X-Opra-Version";
  HttpHeaderCodes2["X_Total_Count"] = "X-Total-Count";
  HttpHeaderCodes2["WWW_Authenticate"] = "WWW-Authenticate";
  HttpHeaderCodes2["Authorization"] = "Authorization";
  HttpHeaderCodes2["Proxy_Authenticate"] = "Proxy-Authenticate";
  HttpHeaderCodes2["Proxy_Authorization"] = "Proxy-Authorization";
  HttpHeaderCodes2["Age"] = "Age";
  HttpHeaderCodes2["Cache_Control"] = "Cache-Control";
  HttpHeaderCodes2["Clear_Site_Data"] = "Clear-Site-Data";
  HttpHeaderCodes2["Expires"] = "Expires";
  HttpHeaderCodes2["Pragma"] = "Pragma";
  HttpHeaderCodes2["Last_Modified"] = "Last-Modified";
  HttpHeaderCodes2["ETag"] = "ETag";
  HttpHeaderCodes2["If_Match"] = "If-Match";
  HttpHeaderCodes2["If_None_Match"] = "If-None-Match";
  HttpHeaderCodes2["If_Modified_Since"] = "If-Modified-Since";
  HttpHeaderCodes2["If_Unmodified_Since"] = "If-Unmodified-Since";
  HttpHeaderCodes2["Vary"] = "Vary";
  HttpHeaderCodes2["Connection"] = "Connection";
  HttpHeaderCodes2["Keep_Alive"] = "Keep-Alive";
  HttpHeaderCodes2["Accept"] = "Accept";
  HttpHeaderCodes2["Accept_Encoding"] = "Accept-Encoding";
  HttpHeaderCodes2["Accept_Language"] = "Accept-Language";
  HttpHeaderCodes2["Expect"] = "Expect";
  HttpHeaderCodes2["Cookie"] = "Cookie";
  HttpHeaderCodes2["Set_Cookie"] = "Set-Cookie";
  HttpHeaderCodes2["Access_Control_Allow_Origin"] = "Access-Control-Allow-Origin";
  HttpHeaderCodes2["Access_Control_Allow_Credentials"] = "Access-Control-Allow-Credentials";
  HttpHeaderCodes2["Access_Control_Allow_Headers"] = "Access-Control-Allow-Headers";
  HttpHeaderCodes2["Access_Control_Allow_Methods"] = "Access-Control-Allow-Methods";
  HttpHeaderCodes2["Access_Control_Expose_Headers"] = "Access-Control-Expose-Headers";
  HttpHeaderCodes2["Access_Control_Max_Age"] = "Access-Control-Max-Age";
  HttpHeaderCodes2["Access_Control_Request_Headers"] = "Access-Control-Request-Headers";
  HttpHeaderCodes2["Access_Control_Request_Method"] = "Access-Control-Request-Method";
  HttpHeaderCodes2["Origin"] = "Origin";
  HttpHeaderCodes2["Timing_Allow_Origin"] = "Timing-Allow-Origin";
  HttpHeaderCodes2["Content_Disposition"] = "Content-Disposition";
  HttpHeaderCodes2["Content_ID"] = "Content-ID";
  HttpHeaderCodes2["Content_Length"] = "Content-Length";
  HttpHeaderCodes2["Content_Type"] = "Content-Type";
  HttpHeaderCodes2["Content_Transfer_Encoding"] = "Content-Transfer-Encoding";
  HttpHeaderCodes2["Content_Encoding"] = "Content-Encoding";
  HttpHeaderCodes2["Content_Language"] = "Content-Language";
  HttpHeaderCodes2["Content_Location"] = "Content-Location";
  HttpHeaderCodes2["Forwarded"] = "Forwarded";
  HttpHeaderCodes2["X_Forwarded_For"] = "X-Forwarded-For";
  HttpHeaderCodes2["X_Forwarded_Host"] = "X-Forwarded-Host";
  HttpHeaderCodes2["X_Forwarded_Proto"] = "X-Forwarded-Proto";
  HttpHeaderCodes2["Via"] = "Via";
  HttpHeaderCodes2["Location"] = "Location";
  HttpHeaderCodes2["From"] = "From";
  HttpHeaderCodes2["Host"] = "Host";
  HttpHeaderCodes2["Referer"] = "Referer";
  HttpHeaderCodes2["Referrer_Policy"] = "Referrer-Policy";
  HttpHeaderCodes2["User_Agent"] = "User-Agent";
  HttpHeaderCodes2["Allow"] = "Allow";
  HttpHeaderCodes2["Server"] = "Server";
  HttpHeaderCodes2["Accept_Ranges"] = "Accept-Ranges";
  HttpHeaderCodes2["Range"] = "Range";
  HttpHeaderCodes2["If_Range"] = "If-Range";
  HttpHeaderCodes2["Content_Range"] = "Content-Range";
  HttpHeaderCodes2["Cross_Origin_Embedder_Policy"] = "Cross-Origin-Embedder-Policy";
  HttpHeaderCodes2["Cross_Origin_Opener_Policy"] = "Cross-Origin-Opener-Policy";
  HttpHeaderCodes2["Cross_Origin_Resource_Policy"] = "Cross-Origin-Resource-Policy";
  HttpHeaderCodes2["Content_Security_Policy"] = "Content-Security-Policy";
  HttpHeaderCodes2["Content_Security_Policy_Report_Only"] = "Content-Security-Policy-Report-Only";
  HttpHeaderCodes2["Expect_CT"] = "Expect-CT";
  HttpHeaderCodes2["Feature_Policy"] = "Feature-Policy";
  HttpHeaderCodes2["Strict_Transport_Security"] = "Strict-Transport-Security";
  HttpHeaderCodes2["Upgrade"] = "Upgrade";
  HttpHeaderCodes2["Upgrade_Insecure_Requests"] = "Upgrade-Insecure-Requests";
  HttpHeaderCodes2["X_Content_Type_Options"] = "X-Content-Type-Options";
  HttpHeaderCodes2["X_Download_Options"] = "X-Download-Options";
  HttpHeaderCodes2["X_Frame_Options"] = "X-Frame-Options";
  HttpHeaderCodes2["X_Permitted_Cross_Domain_Policies"] = "X-Permitted-Cross-Domain-Policies";
  HttpHeaderCodes2["X_Powered_By"] = "X-Powered-By";
  HttpHeaderCodes2["X_XSS_Protection"] = "X-XSS-Protection";
  HttpHeaderCodes2["Transfer_Encoding"] = "Transfer-Encoding";
  HttpHeaderCodes2["TE"] = "TE";
  HttpHeaderCodes2["Trailer"] = "Trailer";
  HttpHeaderCodes2["Sec_WebSocket_Key"] = "Sec-WebSocket-Key";
  HttpHeaderCodes2["Sec_WebSocket_Extensions"] = "Sec-WebSocket-Extensions";
  HttpHeaderCodes2["Sec_WebSocket_Accept"] = "Sec-WebSocket-Accept";
  HttpHeaderCodes2["Sec_WebSocket_Protocol"] = "Sec-WebSocket-Protocol";
  HttpHeaderCodes2["Sec_WebSocket_Version"] = "Sec-WebSocket-Version";
  HttpHeaderCodes2["Date"] = "Date";
  HttpHeaderCodes2["Retry_After"] = "Retry-After";
  HttpHeaderCodes2["Server_Timing"] = "Server-Timing";
  HttpHeaderCodes2["X_DNS_Prefetch_Control"] = "X-DNS-Prefetch-Control";
  HttpHeaderCodes2["Max_Forwards"] = "Max-Forwards";
})(HttpHeaderCodes || (HttpHeaderCodes = {}));

// ../../build/common/esm/http/enums/http-status-codes.enum.js
var HttpStatusCode;
(function(HttpStatusCode2) {
  HttpStatusCode2[HttpStatusCode2["CONTINUE"] = 100] = "CONTINUE";
  HttpStatusCode2[HttpStatusCode2["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
  HttpStatusCode2[HttpStatusCode2["PROCESSING"] = 102] = "PROCESSING";
  HttpStatusCode2[HttpStatusCode2["EARLYHINTS"] = 103] = "EARLYHINTS";
  HttpStatusCode2[HttpStatusCode2["OK"] = 200] = "OK";
  HttpStatusCode2[HttpStatusCode2["CREATED"] = 201] = "CREATED";
  HttpStatusCode2[HttpStatusCode2["ACCEPTED"] = 202] = "ACCEPTED";
  HttpStatusCode2[HttpStatusCode2["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
  HttpStatusCode2[HttpStatusCode2["NO_CONTENT"] = 204] = "NO_CONTENT";
  HttpStatusCode2[HttpStatusCode2["RESET_CONTENT"] = 205] = "RESET_CONTENT";
  HttpStatusCode2[HttpStatusCode2["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
  HttpStatusCode2[HttpStatusCode2["AMBIGUOUS"] = 300] = "AMBIGUOUS";
  HttpStatusCode2[HttpStatusCode2["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
  HttpStatusCode2[HttpStatusCode2["FOUND"] = 302] = "FOUND";
  HttpStatusCode2[HttpStatusCode2["SEE_OTHER"] = 303] = "SEE_OTHER";
  HttpStatusCode2[HttpStatusCode2["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
  HttpStatusCode2[HttpStatusCode2["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
  HttpStatusCode2[HttpStatusCode2["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
  HttpStatusCode2[HttpStatusCode2["BAD_REQUEST"] = 400] = "BAD_REQUEST";
  HttpStatusCode2[HttpStatusCode2["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
  HttpStatusCode2[HttpStatusCode2["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
  HttpStatusCode2[HttpStatusCode2["FORBIDDEN"] = 403] = "FORBIDDEN";
  HttpStatusCode2[HttpStatusCode2["NOT_FOUND"] = 404] = "NOT_FOUND";
  HttpStatusCode2[HttpStatusCode2["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
  HttpStatusCode2[HttpStatusCode2["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
  HttpStatusCode2[HttpStatusCode2["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
  HttpStatusCode2[HttpStatusCode2["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
  HttpStatusCode2[HttpStatusCode2["CONFLICT"] = 409] = "CONFLICT";
  HttpStatusCode2[HttpStatusCode2["GONE"] = 410] = "GONE";
  HttpStatusCode2[HttpStatusCode2["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
  HttpStatusCode2[HttpStatusCode2["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
  HttpStatusCode2[HttpStatusCode2["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
  HttpStatusCode2[HttpStatusCode2["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
  HttpStatusCode2[HttpStatusCode2["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
  HttpStatusCode2[HttpStatusCode2["REQUESTED_RANGE_NOT_SATISFIABLE"] = 416] = "REQUESTED_RANGE_NOT_SATISFIABLE";
  HttpStatusCode2[HttpStatusCode2["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
  HttpStatusCode2[HttpStatusCode2["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
  HttpStatusCode2[HttpStatusCode2["MISDIRECTED_REQUEST"] = 421] = "MISDIRECTED_REQUEST";
  HttpStatusCode2[HttpStatusCode2["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
  HttpStatusCode2[HttpStatusCode2["LOCKED"] = 423] = "LOCKED";
  HttpStatusCode2[HttpStatusCode2["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
  HttpStatusCode2[HttpStatusCode2["TOO_EARLY"] = 425] = "TOO_EARLY";
  HttpStatusCode2[HttpStatusCode2["UPGRADE_REQUIRED"] = 426] = "UPGRADE_REQUIRED";
  HttpStatusCode2[HttpStatusCode2["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
  HttpStatusCode2[HttpStatusCode2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  HttpStatusCode2[HttpStatusCode2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  HttpStatusCode2[HttpStatusCode2["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
  HttpStatusCode2[HttpStatusCode2["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
  HttpStatusCode2[HttpStatusCode2["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
  HttpStatusCode2[HttpStatusCode2["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
  HttpStatusCode2[HttpStatusCode2["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
  HttpStatusCode2[HttpStatusCode2["VARIANT_ALSO_NEGOTIATES"] = 506] = "VARIANT_ALSO_NEGOTIATES";
  HttpStatusCode2[HttpStatusCode2["INSUFFICIENT_STORAGE"] = 507] = "INSUFFICIENT_STORAGE";
  HttpStatusCode2[HttpStatusCode2["LOOP_DETECTED"] = 508] = "LOOP_DETECTED";
  HttpStatusCode2[HttpStatusCode2["NOT_EXTENDED"] = 510] = "NOT_EXTENDED";
  HttpStatusCode2[HttpStatusCode2["NETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NETWORK_AUTHENTICATION_REQUIRED";
})(HttpStatusCode || (HttpStatusCode = {}));

// ../../build/common/esm/http/enums/http-status-messages.js
var HttpStatusMessages = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};

// ../../build/common/esm/exception/http-errors/forbidden.error.js
var ForbiddenError = class extends OpraException {
  static {
    __name(this, "ForbiddenError");
  }
  constructor() {
    super(...arguments);
    this.status = HttpStatusCode.FORBIDDEN;
  }
  init(issue) {
    super.init({
      message: translate("error:FORBIDDEN", "You are not authorized to perform this action"),
      code: "FORBIDDEN",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/internal-server.error.js
var InternalServerError = class extends OpraException {
  static {
    __name(this, "InternalServerError");
  }
  constructor() {
    super(...arguments);
    this.status = 500;
  }
  init(issue) {
    super.init({
      message: translate("error:INTERNAL_SERVER_ERROR", "Internal server error"),
      code: "INTERNAL_SERVER_ERROR",
      severity: "fatal",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/method-not-allowed.error.js
var MethodNotAllowedError = class extends OpraException {
  static {
    __name(this, "MethodNotAllowedError");
  }
  constructor() {
    super(...arguments);
    this.status = 405;
  }
  init(issue) {
    super.init({
      message: translate("error:METHOD_NOT_ALLOWED", "Method not allowed"),
      code: "METHOD_NOT_ALLOWED",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/not-acceptable.error.js
var NotAcceptableError = class extends OpraException {
  static {
    __name(this, "NotAcceptableError");
  }
  constructor() {
    super(...arguments);
    this.status = 406;
  }
  init(issue) {
    super.init({
      message: translate("error:NOT_ACCEPTABLE", "Not Acceptable"),
      code: "NOT_ACCEPTABLE",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/not-found.error.js
var NotFoundError = class extends OpraException {
  static {
    __name(this, "NotFoundError");
  }
  constructor() {
    super(...arguments);
    this.status = 404;
  }
  init(issue) {
    super.init({
      message: translate("error:NOT_FOUND", "Not found"),
      code: "NOT_FOUND",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/unauthorized.error.js
var UnauthorizedError = class extends OpraException {
  static {
    __name(this, "UnauthorizedError");
  }
  constructor() {
    super(...arguments);
    this.status = 401;
  }
  init(issue) {
    super.init({
      message: translate("error:UNAUTHORIZED", "You have not been authenticated to perform this action"),
      code: "UNAUTHORIZED",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/http-errors/unprocessable-entity.error.js
var UnprocessableEntityError = class extends OpraException {
  static {
    __name(this, "UnprocessableEntityError");
  }
  constructor() {
    super(...arguments);
    this.status = 422;
  }
  init(issue) {
    super.init({
      message: translate("error:UNPROCESSABLE_ENTITY", "Unprocessable entity"),
      severity: "error",
      code: "UNPROCESSABLE_ENTITY",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/wrap-exception.js
function wrapException(error) {
  if (error instanceof OpraException)
    return error;
  let status = 500;
  if (typeof error.status === "number")
    status = error.status;
  else if (typeof error.getStatus === "function")
    status = error.getStatus();
  switch (status) {
    case 400:
      return new BadRequestError(error);
    case 401:
      return new UnauthorizedError(error);
    case 403:
      return new ForbiddenError(error);
    case 404:
      return new NotFoundError(error);
    case 405:
      return new MethodNotAllowedError(error);
    case 406:
      return new NotAcceptableError(error);
    case 422:
      return new UnprocessableEntityError(error);
    case 424:
      return new FailedDependencyError(error);
    default:
      return new InternalServerError(error);
  }
}
__name(wrapException, "wrapException");

// ../../build/common/esm/exception/issue-severity.enum.js
var IssueSeverity;
(function(IssueSeverity2) {
  let Enum;
  (function(Enum2) {
    Enum2["fatal"] = "fatal";
    Enum2["error"] = "error";
    Enum2["warning"] = "warning";
    Enum2["info"] = "info";
  })(Enum = IssueSeverity2.Enum || (IssueSeverity2.Enum = {}));
  IssueSeverity2.name = "IssueSeverity";
  IssueSeverity2.description = "Severity of the issue";
  IssueSeverity2.Keys = Object.keys(IssueSeverity2);
  IssueSeverity2.descriptions = {
    fatal: "The issue caused the action to fail and no further checking could be performed",
    error: "The issue is sufficiently important to cause the action to fail",
    warning: "The issue is not important enough to cause the action to fail but may cause it to be performed suboptimally or in a way that is not as desired",
    info: "The issue has no relation to the degree of success of the action"
  };
})(IssueSeverity || (IssueSeverity = {}));

// ../../build/common/esm/exception/http-errors/conflict.error.js
var ConflictError = class extends OpraException {
  static {
    __name(this, "ConflictError");
  }
  constructor() {
    super(...arguments);
    this.status = 409;
  }
  init(issue) {
    super.init({
      message: translate("error:CONFLICT", "Conflict"),
      code: "CONFLICT",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/resource-errors/permission.error.js
var PermissionError = class extends ForbiddenError {
  static {
    __name(this, "PermissionError");
  }
  init(issue) {
    super.init({
      message: translate("error:PERMISSION_ERROR", "You dont have permission for this operation"),
      code: "PERMISSION_ERROR",
      ...issue
    });
  }
};

// ../../build/common/esm/exception/resource-errors/resource-conflict.error.js
var ResourceConflictError = class extends OpraException {
  static {
    __name(this, "ResourceConflictError");
  }
  constructor(resource, fields, cause) {
    super({
      message: translate(`error:RESOURCE_CONFLICT`, { resource, fields }, `There is already an other {{resource}} resource with same values ({{fields}})`),
      severity: "error",
      code: "RESOURCE_CONFLICT",
      details: {
        resource,
        location: fields
      }
    }, cause);
    this.status = 409;
  }
};

// ../../build/common/esm/exception/resource-errors/resource-not.available.error.js
var ResourceNotAvailableError = class extends OpraException {
  static {
    __name(this, "ResourceNotAvailableError");
  }
  constructor(resource, keyValue, cause) {
    super({
      message: translate(`error:RESOURCE_NOT_AVAILABLE`, `Resource "${resource}${keyValue ? "/" + keyValue : ""}" is not available or you dont have access`),
      severity: "error",
      code: "RESOURCE_NOT_AVAILABLE",
      details: {
        resource,
        key: keyValue
      }
    }, cause, HttpStatusCode.UNPROCESSABLE_ENTITY);
  }
};

// ../../build/common/esm/schema/opra-schema.ns.js
var opra_schema_ns_exports = {};
__export(opra_schema_ns_exports, {
  Collection: () => Collection,
  ComplexType: () => ComplexType,
  Container: () => Container,
  EnumType: () => EnumType,
  MappedType: () => MappedType,
  MixinType: () => MixinType,
  SimpleType: () => SimpleType,
  Singleton: () => Singleton,
  SpecVersion: () => SpecVersion,
  Storage: () => Storage,
  isCollection: () => isCollection,
  isComplexType: () => isComplexType,
  isContainer: () => isContainer,
  isDataType: () => isDataType,
  isEnumType: () => isEnumType,
  isMappedType: () => isMappedType,
  isMixinType: () => isMixinType,
  isResource: () => isResource,
  isSimpleType: () => isSimpleType,
  isSingleton: () => isSingleton,
  isStorage: () => isStorage
});

// ../../build/common/esm/schema/data-type/complex-type.interface.js
var ComplexType;
(function(ComplexType3) {
  ComplexType3.Kind = "ComplexType";
})(ComplexType || (ComplexType = {}));

// ../../build/common/esm/schema/data-type/enum-type.interface.js
var EnumType;
(function(EnumType3) {
  EnumType3.Kind = "EnumType";
})(EnumType || (EnumType = {}));

// ../../build/common/esm/schema/data-type/simple-type.interface.js
var SimpleType;
(function(SimpleType3) {
  SimpleType3.Kind = "SimpleType";
})(SimpleType || (SimpleType = {}));

// ../../build/common/esm/schema/data-type/mapped-type.interface.js
var MappedType;
(function(MappedType3) {
  MappedType3.Kind = "MappedType";
})(MappedType || (MappedType = {}));

// ../../build/common/esm/schema/data-type/mixin-type.interface.js
var MixinType;
(function(MixinType3) {
  MixinType3.Kind = "MixinType";
})(MixinType || (MixinType = {}));

// ../../build/common/esm/schema/resource/collection.interface.js
var Collection;
(function(Collection3) {
  Collection3.Kind = "Collection";
})(Collection || (Collection = {}));

// ../../build/common/esm/schema/resource/container.interface.js
var Container;
(function(Container3) {
  Container3.Kind = "Container";
})(Container || (Container = {}));

// ../../build/common/esm/schema/resource/singleton.interface.js
var Singleton;
(function(Singleton3) {
  Singleton3.Kind = "Singleton";
})(Singleton || (Singleton = {}));

// ../../build/common/esm/schema/resource/storage.interface.js
var Storage;
(function(Storage3) {
  Storage3.Kind = "Storage";
})(Storage || (Storage = {}));

// ../../build/common/esm/schema/constants.js
var SpecVersion = "1.0";

// ../../build/common/esm/schema/type-guards.js
function isDataType(obj) {
  return obj && typeof obj === "object" && (obj.kind === ComplexType.Kind || obj.kind === EnumType.Kind || obj.kind === MappedType.Kind || obj.kind === SimpleType.Kind || obj.kind === MixinType.Kind);
}
__name(isDataType, "isDataType");
function isComplexType(obj) {
  return obj && typeof obj === "object" && obj.kind === ComplexType.Kind;
}
__name(isComplexType, "isComplexType");
function isSimpleType(obj) {
  return obj && typeof obj === "object" && obj.kind === SimpleType.Kind;
}
__name(isSimpleType, "isSimpleType");
function isMixinType(obj) {
  return obj && typeof obj === "object" && obj.kind === MixinType.Kind;
}
__name(isMixinType, "isMixinType");
function isMappedType(obj) {
  return obj && typeof obj === "object" && obj.kind === MappedType.Kind;
}
__name(isMappedType, "isMappedType");
function isEnumType(obj) {
  return obj && typeof obj === "object" && obj.kind === EnumType.Kind;
}
__name(isEnumType, "isEnumType");
function isResource(obj) {
  return obj && typeof obj === "object" && (obj.kind === Container.Kind || obj.kind === Collection.Kind || obj.kind === Singleton.Kind || obj.kind === Storage.Kind);
}
__name(isResource, "isResource");
function isCollection(obj) {
  return obj && typeof obj === "object" && obj.kind === Collection.Kind;
}
__name(isCollection, "isCollection");
function isSingleton(obj) {
  return obj && typeof obj === "object" && obj.kind === Singleton.Kind;
}
__name(isSingleton, "isSingleton");
function isStorage(obj) {
  return obj && typeof obj === "object" && obj.kind === Storage.Kind;
}
__name(isStorage, "isStorage");
function isContainer(obj) {
  return obj && typeof obj === "object" && obj.kind === Container.Kind;
}
__name(isContainer, "isContainer");

// ../../build/common/esm/document/utils/inspect.util.js
var nodeInspectCustom3 = Symbol.for("nodejs.util.inspect.custom");
var colorReset = "\x1B[0m";
var colorFgYellow = "\x1B[33m";
var colorFgMagenta = "\x1B[35m";

// ../../build/common/esm/document/resource/action.js
import { isAny } from "valgen";

// ../../build/common/esm/document/data-type/data-type.js
var DataType = class _DataType {
  static {
    __name(this, "DataType");
  }
  constructor(document, init) {
    this.document = document;
    this.name = init?.name;
    this.own = {};
    this.description = init?.description;
    if (!this.name)
      this.isEmbedded = true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  exportSchema(options) {
    return omitUndefined({
      kind: this.kind,
      description: this.description
    });
  }
  extendsFrom(type) {
    const dataType = type instanceof _DataType ? type : this.document.getDataType(type);
    let t = this;
    while (t) {
      if (t === dataType)
        return true;
      t = t.base;
    }
    return false;
  }
  toString() {
    return `[${Object.getPrototypeOf(this).constructor.name} ${this.name || "#Embedded"}]`;
  }
  [nodeInspectCustom3]() {
    return `[${colorFgYellow + Object.getPrototypeOf(this).constructor.name + colorReset} ${colorFgMagenta + this.name + colorReset}]`;
  }
};

// ../../build/common/esm/document/resource/parameter.js
import { vg } from "valgen";
var Parameter = class {
  static {
    __name(this, "Parameter");
  }
  constructor(name, init) {
    this.name = name;
    this.type = init.type;
    this.description = init.description;
    this.isArray = init.isArray;
    this.default = init.default;
    this.required = init.required;
    this.deprecated = init.deprecated;
    this.examples = init.examples;
    this.isBuiltin = init.isBuiltin;
  }
  exportSchema(options) {
    return omitUndefined({
      type: this.type.name ? this.type.name : this.type.exportSchema(options),
      description: this.description,
      isArray: this.isArray,
      default: this.default,
      required: this.required,
      deprecated: this.deprecated,
      examples: this.examples
    });
  }
  getDecoder() {
    if (!this._decoder)
      this._decoder = this.generateCodec("decode");
    return this._decoder;
  }
  getEncoder() {
    if (!this._encoder)
      this._encoder = this.generateCodec("encode");
    return this._encoder;
  }
  generateCodec(codec, options) {
    let fn = this.type.generateCodec(codec, options);
    if (this.isArray)
      fn = vg.stringSplit(",");
    return !options?.partial && this.required ? vg.required(fn) : vg.optional(fn);
  }
};

// ../../build/common/esm/document/resource/endpoint.js
var Endpoint = class {
  static {
    __name(this, "Endpoint");
  }
  constructor(resource, name, init) {
    this.resource = resource;
    this.name = name;
    this.options = {};
    Object.assign(this, init);
    this.parameters = new ResponsiveMap();
    if (init.parameters) {
      for (const [n, p] of Object.entries(init.parameters)) {
        this.defineParameter(n, p);
      }
    }
  }
  getFullPath(documentPath) {
    return this.resource.getFullPath(documentPath) + (this.kind === "action" ? (documentPath ? "/actions/" : "/") + this.name : "");
  }
  defineParameter(name, init) {
    const type = init.type && init.type instanceof DataType ? init.type : this.resource.document.getDataType(init.type || "any");
    const prm = new Parameter(name, {
      ...init,
      type
    });
    this.parameters.set(prm.name, prm);
    return prm;
  }
  exportSchema(options) {
    const schema = omitUndefined({
      description: this.description
    });
    if (Object.keys(this.options).length)
      schema.options = { ...this.options };
    if (this.parameters.size) {
      let i = 0;
      const parameters = {};
      for (const [name, param] of this.parameters.entries()) {
        if (!param.isBuiltin) {
          parameters[name] = param.exportSchema(options);
          i++;
        }
      }
      if (i)
        schema.parameters = parameters;
    }
    return schema;
  }
};

// ../../build/common/esm/document/resource/action.js
var Action = class extends Endpoint {
  static {
    __name(this, "Action");
  }
  constructor(resource, name, init) {
    super(resource, name, init);
    this.resource = resource;
    this.name = name;
    this.kind = "action";
    this.encodeReturning = isAny;
    if (init.returnType)
      this.returnType = init.returnType instanceof DataType ? init.returnType : this.resource.document.getDataType(init.returnType);
    this.returnMime = init.returnMime;
  }
  exportSchema(options) {
    const schema = super.exportSchema(options);
    if (this.returnType)
      schema.returnType = this.returnType.isEmbedded ? this.returnType.exportSchema(options) : this.returnType.name;
    if (this.returnMime)
      schema.returnMime = this.returnMime;
    return schema;
  }
};

// ../../build/common/esm/document/resource/resource.js
var Resource = class _Resource {
  static {
    __name(this, "Resource");
  }
  constructor(parent, init) {
    this.actions = new ResponsiveMap();
    if (parent instanceof _Resource) {
      this.document = parent.document;
      this.parent = parent;
    } else
      this.document = parent;
    this.name = init.name;
    this.description = init.description;
    this.controller = init.controller;
    if (this.controller) {
      this.ctor = Object.getPrototypeOf(this.controller).constructor;
    } else
      this.ctor = init.ctor;
    if (init.actions) {
      for (const [name, meta] of Object.entries(init.actions)) {
        this.actions.set(name, new Action(this, name, meta));
      }
    }
  }
  getFullPath(documentPath) {
    if (this === this.document.root)
      return documentPath ? "/root" : "/";
    let out = this.parent?.getFullPath(documentPath);
    if (!out?.endsWith("/"))
      out += "/";
    return out + (documentPath ? "resources/" : "") + this.name;
  }
  exportSchema(options) {
    const schema = omitUndefined({
      kind: this.kind,
      description: this.description
    });
    if (this.actions.size) {
      schema.actions = {};
      for (const action of this.actions.values()) {
        schema.actions[action.name] = action.exportSchema(options);
      }
    }
    return schema;
  }
  toString() {
    return `[${Object.getPrototypeOf(this).constructor.name} ${this.name || "#Embedded"}]`;
  }
  [nodeInspectCustom3]() {
    return `[${colorFgYellow + Object.getPrototypeOf(this).constructor.name + colorReset} ${colorFgMagenta + this.name + colorReset}]`;
  }
};

// ../../build/common/esm/document/resource/container-class.js
var PATH_PREFIX_PATTERN = /^(\/*)(.+)$/;
var ContainerClass = class _ContainerClass extends Resource {
  static {
    __name(this, "ContainerClass");
  }
  constructor(owner, init) {
    super(owner instanceof _ContainerClass ? owner.document : owner, init);
    this.kind = opra_schema_ns_exports.Container.Kind;
    this.resources = new ResponsiveMap();
    this.parent = owner instanceof _ContainerClass ? owner : void 0;
  }
  exportSchema(options) {
    const schema = super.exportSchema(options);
    if (this.resources.size) {
      const resources = schema.resources = {};
      for (const [name, r] of this.resources.entries()) {
        resources[name] = r.exportSchema(options);
      }
    }
    return schema;
  }
  getResource(path, silent) {
    let resource;
    path = PATH_PREFIX_PATTERN.exec(path)?.[2] || path;
    if (path.includes("/")) {
      const arr = path.split("/");
      let i;
      const l = arr.length;
      let container = this;
      for (i = 0; i < l; i++) {
        resource = container.resources.get(arr[i]);
        if (resource instanceof _ContainerClass)
          container = resource;
        else
          break;
      }
      if (!resource || i < l - 1)
        resource = void 0;
    } else
      resource = this.resources.get(path);
    if (resource || silent)
      return resource;
    throw new ResourceNotAvailableError(path);
  }
  getContainer(path, silent) {
    const t = this.getResource(path);
    if (!t && silent)
      return;
    if (t && t.kind === opra_schema_ns_exports.Container.Kind)
      return t;
    throw new NotAcceptableError(`Resource type "${t.name}" is not a Container`);
  }
  getCollection(path, silent) {
    const t = this.getResource(path);
    if (!t && silent)
      return;
    if (t && t.kind === opra_schema_ns_exports.Collection.Kind)
      return t;
    throw new NotAcceptableError(`Resource type "${t.name}" is not a Collection`);
  }
  getSingleton(path, silent) {
    const t = this.getResource(path);
    if (!t && silent)
      return;
    if (t && t.kind === opra_schema_ns_exports.Singleton.Kind)
      return t;
    throw new NotAcceptableError(`Resource type "${t.name}" is not a Singleton`);
  }
  getStorage(path, silent) {
    const t = this.getResource(path);
    if (!t && silent)
      return;
    if (t && t.kind === opra_schema_ns_exports.Storage.Kind)
      return t;
    throw new NotAcceptableError(`Resource type "${t.name}" is not a Storage`);
  }
};

// ../../build/common/esm/document/resource/action-decorator.js
function createActionDecorator(options, bannedProperties, list) {
  const decorator = /* @__PURE__ */ __name((target, propertyKey) => {
    if (typeof propertyKey === "string" && bannedProperties.includes(propertyKey))
      throw new TypeError(`The "${propertyKey}" property is reserved for "${propertyKey}" operations and cannot be used as an action'`);
    const resourceMetadata = Reflect.getOwnMetadata(RESOURCE_METADATA, target.constructor) || {};
    resourceMetadata.actions = resourceMetadata.actions || {};
    const actionMeta = { ...options };
    resourceMetadata.actions[propertyKey] = actionMeta;
    for (const fn of list)
      fn(actionMeta);
    Reflect.defineMetadata(RESOURCE_METADATA, resourceMetadata, target.constructor);
  }, "decorator");
  decorator.Parameter = (name, arg0) => {
    const parameterOptions = typeof arg0 === "string" || typeof arg0 === "function" ? { type: arg0 } : { ...arg0 };
    list.push((operationMeta) => {
      operationMeta.parameters = operationMeta.parameters || {};
      operationMeta.parameters[name] = { ...parameterOptions };
    });
    return decorator;
  };
  decorator.Returns = (t) => {
    list.push((actionMetadata) => {
      actionMetadata.returnType = t;
    });
    return decorator;
  };
  return decorator;
}
__name(createActionDecorator, "createActionDecorator");

// ../../build/common/esm/document/resource/resource-decorator.js
import omit from "lodash.omit";
import merge2 from "putil-merge";
function ResourceDecorator(kind, meta) {
  const namePattern = new RegExp(`^(.*)(${kind}|Resource|Controller)$`);
  return function(target) {
    let name = meta?.name;
    if (!name) {
      name = namePattern.exec(target.name)?.[1] || target.name;
      if (kind === "Container")
        name = name.charAt(0).toLowerCase() + name.substring(1);
    }
    const metadata = { kind, name };
    const baseMetadata = Reflect.getOwnMetadata(RESOURCE_METADATA, Object.getPrototypeOf(target));
    if (baseMetadata)
      merge2(metadata, baseMetadata, { deep: true });
    const oldMetadata = Reflect.getOwnMetadata(RESOURCE_METADATA, target);
    if (oldMetadata)
      merge2(metadata, oldMetadata, { deep: true });
    merge2(metadata, {
      kind,
      name,
      ...omit(meta, ["kind", "name", "controller"])
    }, { deep: true });
    Reflect.defineMetadata(RESOURCE_METADATA, metadata, target);
  };
}
__name(ResourceDecorator, "ResourceDecorator");

// ../../build/common/esm/document/resource/container-decorator.js
function ContainerDecorator(options) {
  return ResourceDecorator(opra_schema_ns_exports.Container.Kind, options);
}
__name(ContainerDecorator, "ContainerDecorator");
Object.assign(ContainerDecorator, ResourceDecorator);
(function(ContainerDecorator2) {
  function Action2(options) {
    const list = [];
    return createActionDecorator(options, [], list);
  }
  __name(Action2, "Action");
  ContainerDecorator2.Action = Action2;
})(ContainerDecorator || (ContainerDecorator = {}));

// ../../build/common/esm/document/resource/container.js
var Container2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [options] = args;
    return Container2[DECORATOR].call(void 0, options);
  }
  const [parent, init] = args;
  merge3(this, new ContainerClass(parent, init), { descriptor: true });
  if (init.resources) {
    const container = this;
    init.resources.forEach((r) => container.resources.set(r.name, r));
  }
}, "Container");
Container2.prototype = ContainerClass.prototype;
Object.assign(Container2, ContainerDecorator);
Container2[DECORATOR] = ContainerDecorator;

// ../../build/common/esm/document/data-type/complex-type.js
import "reflect-metadata";
import merge5 from "putil-merge";

// ../../build/common/esm/document/data-type/complex-type.decorator.js
import omit2 from "lodash.omit";
function ComplexTypeDecorator(options) {
  return function(target) {
    const name = options?.name || target.name.match(TYPENAME_PATTERN)?.[1] || target.name;
    let metadata = Reflect.getOwnMetadata(DATATYPE_METADATA, target);
    if (!metadata) {
      metadata = {};
      Reflect.defineMetadata(DATATYPE_METADATA, metadata, target);
    }
    metadata.kind = opra_schema_ns_exports.ComplexType.Kind;
    metadata.name = name;
    if (options)
      Object.assign(metadata, omit2(options, ["kind", "name", "base", "fields"]));
  };
}
__name(ComplexTypeDecorator, "ComplexTypeDecorator");

// ../../build/common/esm/document/data-type/complex-type-class.js
import { vg as vg3 } from "valgen";

// ../../build/common/esm/document/data-type/field.js
import merge4 from "putil-merge";

// ../../build/common/esm/document/data-type/field-class.js
import { isUndefined, vg as vg2 } from "valgen";
var FieldClass = class {
  static {
    __name(this, "FieldClass");
  }
  constructor(owner, init) {
    this.owner = owner;
    this.origin = init.origin || owner;
    this.type = init.type;
    this.designType = init.designType;
    this.name = init.name;
    this.description = init.description;
    this.isArray = init.isArray;
    this.default = init.default;
    this.fixed = init.fixed;
    this.required = init.required;
    this.readonly = init.readonly;
    this.writeonly = init.writeonly;
    this.exclusive = init.exclusive;
    this.translatable = init.translatable;
    this.deprecated = init.deprecated;
    this.examples = init.examples;
    this.pattern = init.pattern ? init.pattern instanceof RegExp ? init.pattern : new RegExp(init.pattern) : void 0;
    this.partialUpdate = init.partialUpdate;
  }
  exportSchema(options) {
    const isEmbedded = !this.type?.name || this.type?.kind === "ComplexType" && this.type.isEmbedded;
    return omitUndefined({
      type: this.type ? isEmbedded ? this.type.exportSchema(options) : this.type.name : void 0,
      description: this.description,
      isArray: this.isArray,
      default: this.default,
      fixed: this.fixed,
      required: this.required,
      readonly: this.readonly,
      writeonly: this.writeonly,
      exclusive: this.exclusive,
      translatable: this.translatable,
      deprecated: this.deprecated,
      examples: this.examples,
      pattern: this.pattern ? String(this.pattern) : void 0,
      partialUpdate: this.partialUpdate
    });
  }
  generateCodec(codec, options) {
    if (options?.operation === "read" && this.writeonly)
      return isUndefined;
    if (options?.operation === "write" && this.readonly)
      return isUndefined;
    let fn = this.type.generateCodec(codec, {
      ...options,
      designType: this.designType,
      partial: options?.partial && (this.partialUpdate || !this.isArray)
    });
    if (this.pattern)
      fn = vg2.allOf(fn, vg2.isRegExp(this.pattern));
    if (this.isArray)
      fn = vg2.isArray(fn);
    return !options?.partial && this.required ? vg2.required(fn) : vg2.optional(fn);
  }
};

// ../../build/common/esm/document/data-type/field-decorator.js
function FieldDecorator(options) {
  return function(target, propertyKey) {
    if (typeof propertyKey !== "string")
      throw new TypeError(`Symbol properties can't be used as a field`);
    const metadata = Reflect.getOwnMetadata(DATATYPE_METADATA, target.constructor) || {};
    metadata.kind = opra_schema_ns_exports.ComplexType.Kind;
    metadata.fields = metadata.fields || {};
    const designType = Reflect.getMetadata("design:type", target, propertyKey);
    const elemMeta = metadata.fields[propertyKey] = {
      ...options,
      designType
    };
    if (designType === Array) {
      elemMeta.isArray = true;
      delete elemMeta.designType;
    }
    Reflect.defineMetadata(DATATYPE_METADATA, omitUndefined(metadata), target.constructor);
  };
}
__name(FieldDecorator, "FieldDecorator");

// ../../build/common/esm/document/data-type/field.js
var ApiField = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [options] = args;
    return ApiField[DECORATOR](options);
  }
  const [owner, init] = args;
  merge4(this, new FieldClass(owner, init), { descriptor: true });
}, "ApiField");
ApiField.prototype = FieldClass.prototype;
Object.assign(ApiField, FieldDecorator);
ApiField[DECORATOR] = FieldDecorator;

// ../../build/common/esm/document/data-type/complex-type-class.js
var ComplexTypeClass = class extends DataType {
  static {
    __name(this, "ComplexTypeClass");
  }
  constructor(document, init) {
    super(document, init);
    this.kind = opra_schema_ns_exports.ComplexType.Kind;
    this.fields = new ResponsiveMap();
    const own = this.own = {};
    own.ctor = init.ctor;
    if (init.base) {
      if (!(init.base.kind === "ComplexType" || init.base.kind === "MappedType" || init.base.kind === "MixinType"))
        throw new TypeError('"base" argument must be one of ComplexType or MappedType or MixinType');
      own.ctor = own.ctor || init.base.ctor;
    }
    own.additionalFields = init?.additionalFields;
    own.embedded = init?.embedded;
    own.fields = new ResponsiveMap();
    this.kind = opra_schema_ns_exports.ComplexType.Kind;
    this.base = init?.base;
    this.ctor = own.ctor || Object;
    this.abstract = init.abstract;
    this.additionalFields = own.additionalFields;
    this.isEmbedded = this.isEmbedded || init.embedded;
    if (this.base?.additionalFields === true && this.additionalFields !== true)
      this.additionalFields = true;
    else if (this.base?.additionalFields === "error" && !this.additionalFields)
      this.additionalFields = "error";
    if (this.base) {
      if (this.base.fields)
        for (const [k, el] of this.base.fields.entries()) {
          const field = new ApiField(this, el);
          this.fields.set(k, field);
        }
    }
    if (init.fields) {
      for (const [k, el] of Object.entries(init.fields)) {
        const field = new ApiField(this, el);
        this.own.fields.set(field.name, field);
        this.fields.set(k, field);
      }
    }
  }
  findField(nameOrPath) {
    let field;
    if (nameOrPath.includes(".")) {
      for (const [, f] of this.iteratePath(nameOrPath, true)) {
        if (!f)
          return;
        field = f;
      }
      return field;
    }
    return this.fields.get(nameOrPath);
  }
  getField(nameOrPath) {
    let field;
    if (nameOrPath.includes(".")) {
      for (const [, f] of this.iteratePath(nameOrPath)) {
        field = f;
      }
    } else
      field = this.fields.get(nameOrPath);
    if (!field)
      throw new Error(translate("error:UNKNOWN_FIELD", { field: nameOrPath }));
    return field;
  }
  iteratePath(path, silent) {
    const arr = path.split(".");
    const len = arr.length;
    let dataType = this;
    let field;
    let curPath = "";
    let s;
    let i = -1;
    const ComplexType3 = Object.getPrototypeOf(this).constructor;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        i++;
        if (i < len) {
          s = arr[i];
          if (dataType && !(dataType instanceof ComplexType3)) {
            if (silent)
              return { done: true, value: [] };
            throw new TypeError(`"${curPath}" field is not a complex type and has no child fields`);
          }
          field = dataType?.fields.get(s);
          if (field) {
            curPath += (curPath ? "." : "") + field.name;
            dataType = field.type;
          } else {
            curPath += (curPath ? "." : "") + s;
            if (dataType && !dataType.additionalFields) {
              if (silent)
                return { done: true, value: [] };
              throw new Error(translate("error:UNKNOWN_FIELD", { field: curPath }));
            }
          }
        }
        return {
          done: i >= len,
          value: [field?.name || s, field, curPath]
        };
      }
    };
  }
  normalizeFieldNames(fieldNames, allowSortSigns) {
    const array = (Array.isArray(fieldNames) ? fieldNames : [fieldNames]).map((s) => {
      let sign = "";
      if (allowSortSigns) {
        const m = SORT_FIELD_PATTERN.exec(s);
        sign = m && m[1] || "";
        s = m && m[2] || s;
      }
      let curPath = "";
      for (const [, , p] of this.iteratePath(s)) {
        curPath = p;
      }
      return sign + curPath;
    }).flat();
    return array.length ? array : void 0;
  }
  exportSchema(options) {
    const out = super.exportSchema(options);
    Object.assign(out, omitUndefined({
      base: this.base ? this.base.name ? this.base.name : this.base.exportSchema(options) : void 0,
      abstract: this.abstract,
      additionalFields: this.own.additionalFields instanceof DataType ? this.own.additionalFields.name ? this.own.additionalFields.name : this.own.additionalFields.exportSchema(options) : this.own.additionalFields
    }));
    if (this.own.fields.size) {
      const fields = out.fields = {};
      for (const field of this.own.fields.values()) {
        fields[field.name] = field.exportSchema(options);
      }
    }
    return omitUndefined(out);
  }
  isTypeOf(t) {
    return t === this.own?.ctor;
  }
  extendsFrom(t) {
    const base = t instanceof DataType ? t : this.document.getDataType(t);
    if (this.base) {
      if (this.base === base)
        return true;
      return this.base.extendsFrom(base);
    }
    return false;
  }
  generateCodec(codec, options) {
    const schema = this.generateCodecSchema(codec, options);
    const additionalFields = this.additionalFields instanceof DataType ? this.additionalFields.generateCodec(codec, {
      operation: options?.operation,
      caseSensitive: options?.caseSensitive,
      partial: options?.partial
    }) : this.additionalFields;
    return vg3.isObject(schema, {
      ctor: this.ctor,
      additionalFields,
      name: this.name,
      caseInSensitive: !options?.caseSensitive,
      onFail: options?.onFail
    });
  }
  generateCodecSchema(codec, options) {
    const opts = {
      ...options,
      pick: (options?.pick || []).map((x) => x.toLowerCase()),
      omit: (options?.omit || []).map((x) => x.toLowerCase()),
      overwriteFields: options?.overwriteFields ? this._buildOverwriteFieldsTree(options.overwriteFields) : void 0
    };
    return this._generateCodecSchema(codec, opts);
  }
  _generateCodecSchema(codec, options) {
    const schema = {};
    const overwriteFields = options?.overwriteFields;
    const optionsPick = options?.pick || [];
    const optionsOmit = options?.omit || [];
    const fieldNames = [...this.fields.keys()];
    if (overwriteFields) {
      for (const k of Object.keys(overwriteFields)) {
        if (!this.fields.has(k))
          fieldNames.push(k);
      }
    }
    for (const fieldName of fieldNames) {
      const lowerName = fieldName.toLowerCase();
      const overwriteFieldInit = overwriteFields?.[fieldName];
      if (!overwriteFieldInit && (optionsOmit.find((x) => x === lowerName) || optionsPick.length && !optionsPick.find((x) => x === lowerName || x.startsWith(lowerName + "."))))
        continue;
      const subOptions = {
        ...options,
        pick: optionsPick.filter((x) => x.startsWith(lowerName + ".")).map((x) => x.substring(x.indexOf(".") + 1)),
        omit: optionsOmit.filter((x) => x.startsWith(lowerName + ".")).map((x) => x.substring(x.indexOf(".") + 1)),
        overwriteFields: overwriteFieldInit?.overrideFields
      };
      let f;
      if (overwriteFieldInit) {
        const field = this.fields.get(fieldName);
        const init = { ...field, ...overwriteFieldInit, name: fieldName };
        if (!(init.type instanceof DataType))
          init.type = this.document.getDataType(init.type || "any");
        f = new ApiField(this, init);
      } else
        f = this.getField(fieldName);
      schema[f.name] = f.generateCodec(codec, subOptions);
    }
    return schema;
  }
  _buildOverwriteFieldsTree(obj) {
    const tree = {};
    for (let k of Object.keys(obj)) {
      const v = obj[k];
      if (!k.includes(".")) {
        const field = this.fields.get(k);
        if (field)
          k = field.name;
        tree[k] = { ...tree[k], ...v };
        continue;
      }
      const keyPath = k.split(".");
      let subTree = tree;
      while (keyPath.length) {
        let j = keyPath.shift();
        const field = this.fields.get(j);
        if (field)
          j = field.name;
        const treeItem = subTree[j] = subTree[j] || {};
        if (keyPath.length) {
          subTree = treeItem.overrideFields = treeItem.overrideFields || {};
        } else
          Object.assign(treeItem, v);
      }
    }
    return tree;
  }
};

// ../../build/common/esm/document/data-type/complex-type.js
var ComplexType2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [options] = args;
    return ComplexType2[DECORATOR](options);
  }
  const [document, init] = args;
  merge5(this, new ComplexTypeClass(document, init), { descriptor: true });
}, "ComplexType");
ComplexType2.prototype = ComplexTypeClass.prototype;
Object.assign(ComplexType2, ComplexTypeDecorator);
ComplexType2[DECORATOR] = ComplexTypeDecorator;

// ../../build/common/esm/document/data-type/enum-type.js
import "reflect-metadata";
import merge6 from "putil-merge";

// ../../build/common/esm/document/data-type/enum-type-class.js
import { vg as vg4 } from "valgen";
var EnumTypeClass = class extends DataType {
  static {
    __name(this, "EnumTypeClass");
  }
  constructor(document, init) {
    super(document, init);
    this.kind = opra_schema_ns_exports.EnumType.Kind;
    this.enumObject = init.enumObject;
    this.base = init.base;
    this.ownValues = { ...init.values };
    this.values = { ...this.base?.values, ...this.ownValues };
    this.decode = vg4.isEnum(Object.keys(this.values));
    this.encode = vg4.isEnum(Object.keys(this.values));
  }
  isTypeOf(t) {
    return t[DATATYPE_METADATA] && t[DATATYPE_METADATA] === this.enumObject?.[DATATYPE_METADATA];
  }
  exportSchema() {
    const out = super.exportSchema();
    out.values = {};
    Object.entries(this.values).forEach(([k, i]) => {
      out.values[k] = omitUndefined({ key: i.key, description: i.description });
    });
    return out;
  }
  generateCodec(codec) {
    if (codec === "encode")
      return this.encode;
    else
      return this.decode;
  }
};

// ../../build/common/esm/document/data-type/enum-type.js
var EnumType2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [enumSource, options] = args;
    let values = {};
    if (Array.isArray(enumSource)) {
      values = {};
      enumSource.forEach((k) => {
        const description = options?.meanings?.[k];
        values[k] = omitUndefined({ description });
      });
    } else {
      Object.keys(enumSource).forEach((k) => {
        const description = options?.meanings?.[k];
        values[enumSource[k]] = omitUndefined({ key: k, description });
      });
    }
    const metadata = {
      kind: opra_schema_ns_exports.EnumType.Kind,
      values,
      base: options?.base,
      name: options?.name,
      description: options?.description
    };
    Object.defineProperty(enumSource, DATATYPE_METADATA, {
      value: metadata,
      enumerable: false,
      configurable: true,
      writable: true
    });
    return metadata;
  }
  const [document, init] = args;
  merge6(this, new EnumTypeClass(document, init), { descriptor: true });
  return;
}, "EnumType");
EnumType2.prototype = EnumTypeClass.prototype;

// ../../build/common/esm/document/document-base.js
var DocumentBase = class {
  static {
    __name(this, "DocumentBase");
  }
  constructor() {
    this.info = {
      version: "",
      title: ""
    };
  }
  /**
   * Export as OPRA schema definition object
   */
  exportSchema() {
    return omitUndefined({
      version: opra_schema_ns_exports.SpecVersion,
      url: this.url,
      info: cloneObject(this.info, true)
    });
  }
};

// ../../build/common/esm/document/type-document.js
var TypeDocument = class extends DocumentBase {
  static {
    __name(this, "TypeDocument");
  }
  constructor() {
    super();
    this._designCtorMap = /* @__PURE__ */ new Map();
    this._typeIndex = /* @__PURE__ */ new Map();
    this._typeNsMap = /* @__PURE__ */ new Map();
    this.references = new ResponsiveMap();
    this.types = new ResponsiveMap();
    const BigIntConstructor = Object.getPrototypeOf(BigInt(0)).constructor;
    const BufferConstructor = Object.getPrototypeOf(Buffer.from([]));
    this._designCtorMap.set(String, "string");
    this._designCtorMap.set(Number, "number");
    this._designCtorMap.set(Boolean, "boolean");
    this._designCtorMap.set(Object, "any");
    this._designCtorMap.set(Date, "datetime");
    this._designCtorMap.set(BigIntConstructor, "bigint");
    this._designCtorMap.set(ArrayBuffer, "base64");
    this._designCtorMap.set(SharedArrayBuffer, "base64");
    this._designCtorMap.set(BufferConstructor, "base64");
  }
  /**
   *
   */
  getDataType(arg0, silent) {
    if (typeof arg0 === "function") {
      const x = this._designCtorMap.get(arg0);
      if (x)
        arg0 = x;
    }
    const t = typeof arg0 === "string" ? this._typeIndex.get(arg0.toLowerCase()) : this._typeIndex.get(arg0);
    if (t)
      return t;
    let name;
    if (typeof arg0 === "string")
      name = arg0;
    else if (arg0 instanceof DataType)
      name = arg0.name || "";
    else {
      const metadata = typeof arg0 === "function" ? Reflect.getMetadata(DATATYPE_METADATA, arg0) : arg0?.[DATATYPE_METADATA];
      if (!metadata) {
        if (!silent)
          throw new TypeError("Invalid argument");
        return;
      }
      name = metadata.name;
    }
    if (t === null) {
      if (silent)
        return;
      throw new Error(`Data type "${name}" does not exists`);
    }
    let dataType;
    let ns = "";
    if (typeof arg0 === "string" && arg0) {
      const m = NAMESPACE_PATTERN.exec(arg0);
      if (!m)
        throw new TypeError(`Invalid data type name "${name}"`);
      if (m[2]) {
        ns = m[1];
        const ref = this.references.get(ns);
        if (!ref) {
          if (silent)
            return;
          throw new Error(`No referenced document found for given namespace "${m[1]}"`);
        }
        dataType = ref.getDataType(m[2], silent);
      } else {
        dataType = this.types.get(arg0);
        if (!dataType) {
          const references = Array.from(this.references.keys()).reverse();
          for (const refNs of references) {
            const ref = this.references.get(refNs);
            dataType = ref.getDataType(name, true);
            if (dataType) {
              ns = refNs;
              break;
            }
          }
        }
      }
    } else {
      const types = Array.from(this.types.values()).reverse();
      for (const dt of types) {
        if (dt === arg0 || (dt instanceof ComplexType2 || dt instanceof EnumType2) && dt.isTypeOf(arg0)) {
          dataType = dt;
          break;
        }
      }
      if (!dataType) {
        const references = Array.from(this.references.keys()).reverse();
        for (const refNs of references) {
          const ref = this.references.get(refNs);
          dataType = ref.getDataType(arg0, true);
          if (dataType) {
            ns = refNs;
            break;
          }
        }
      }
    }
    if (dataType) {
      this._typeIndex.set(arg0, dataType);
      if (ns)
        this._typeNsMap.set(dataType, ns);
      return dataType;
    }
    if (!silent)
      throw new NotFoundError(`Data type "${name}" does not exists`);
    return;
    if (!silent)
      throw new TypeError("Invalid argument");
  }
  /**
   *
   */
  getDataTypeNs(arg0, silent) {
    const dt = this.getDataType(arg0, silent);
    if (dt)
      return this._typeNsMap.get(dt);
  }
  getComplexType(nameOrCtor, silent) {
    if (nameOrCtor === Object)
      nameOrCtor = "object";
    const t = this.getDataType(nameOrCtor, silent);
    if (t) {
      if (t && t.kind === opra_schema_ns_exports.ComplexType.Kind)
        return t;
      throw new NotAcceptableError(`Data type "${t.name}" is not a ComplexType`);
    }
  }
  getSimpleType(nameOrCtor, silent) {
    const t = this.getDataType(nameOrCtor, silent);
    if (t) {
      if (t && t.kind === opra_schema_ns_exports.SimpleType.Kind)
        return t;
      throw new NotAcceptableError(`Data type "${t.name || t}" is not a SimpleType`);
    }
  }
  getEnumType(nameOrCtor, silent) {
    const t = this.getDataType(nameOrCtor);
    if (!t && silent)
      return;
    if (t && t.kind === opra_schema_ns_exports.EnumType.Kind)
      return t;
    throw new NotAcceptableError(`Data type "${t.name || t}" is not a EnumType`);
  }
  /**
   * Export as Opra schema definition object
   */
  exportSchema(options) {
    const schema = super.exportSchema();
    if (this.references.size) {
      const references = {};
      let i = 0;
      for (const [ns, r] of this.references.entries()) {
        if (ns.toLowerCase() === "opra")
          continue;
        references[ns] = r.exportSchema(options);
        i++;
      }
      if (i)
        schema.references = references;
    }
    if (this.types.size) {
      const types = schema.types = {};
      for (const [name, r] of this.types.entries()) {
        types[name] = r.exportSchema(options);
      }
    }
    return schema;
  }
  invalidate() {
    this._typeIndex.clear();
    this._typeNsMap.clear();
  }
};

// ../../build/common/esm/document/api-document.js
var ApiDocument = class extends TypeDocument {
  static {
    __name(this, "ApiDocument");
  }
  constructor() {
    super(...arguments);
    this.root = new Container2(this, { name: "" });
  }
  getResource(path, silent) {
    return this.root.getResource(path, silent);
  }
  getContainer(path, silent) {
    return this.root.getContainer(path, silent);
  }
  getCollection(path, silent) {
    return this.root.getCollection(path, silent);
  }
  getSingleton(path, silent) {
    return this.root.getSingleton(path, silent);
  }
  getStorage(path, silent) {
    return this.root.getStorage(path, silent);
  }
  /**
   * Export as Opra schema definition object
   */
  exportSchema(options) {
    const schema = super.exportSchema(options);
    schema.root = this.root.exportSchema(options);
    delete schema.root.kind;
    return schema;
  }
};

// ../../build/common/esm/document/factory/type-document-factory.js
import { validator } from "valgen";

// ../../node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(__decorate, "__decorate");

// ../../build/common/esm/document/data-type/simple-type.js
import "reflect-metadata";
import merge7 from "putil-merge";

// ../../build/common/esm/document/data-type/simple-type.decorator.js
import omit3 from "lodash.omit";
function SimpleTypeDecorator(options) {
  return function(target) {
    let name = options?.name || target.name.match(TYPENAME_PATTERN)?.[1] || target.name;
    name = name.charAt(0).toLowerCase() + name.substring(1);
    const metadata = Reflect.getOwnMetadata(DATATYPE_METADATA, target) || {};
    metadata.kind = opra_schema_ns_exports.SimpleType.Kind;
    metadata.name = name;
    if (options)
      Object.assign(metadata, omit3(options, ["kind", "name"]));
    Reflect.defineMetadata(DATATYPE_METADATA, metadata, target);
  };
}
__name(SimpleTypeDecorator, "SimpleTypeDecorator");

// ../../build/common/esm/document/data-type/simple-type-class.js
import { isAny as isAny2 } from "valgen";
var SimpleTypeClass = class extends DataType {
  static {
    __name(this, "SimpleTypeClass");
  }
  constructor(document, init) {
    super(document, init);
    this.kind = opra_schema_ns_exports.SimpleType.Kind;
    this.base = init.base;
    this.decode = init.decoder || init.base?.decode || isAny2;
    this.encode = init.encoder || init.base?.encode || isAny2;
  }
  exportSchema(options) {
    const out = super.exportSchema(options);
    Object.assign(out, omitUndefined({
      base: this.base ? this.base.name ? this.base.name : this.base.exportSchema(options) : void 0,
      decode: !options?.webSafe ? this.decode : void 0,
      encode: !options?.webSafe ? this.encode : void 0
    }));
    return out;
  }
  generateCodec(codec) {
    if (codec === "encode")
      return this.encode;
    else
      return this.decode;
  }
};

// ../../build/common/esm/document/data-type/simple-type.js
var SimpleType2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [options] = args;
    return SimpleType2[DECORATOR](options);
  }
  const [document, init] = args;
  merge7(this, new SimpleTypeClass(document, init), { descriptor: true });
}, "SimpleType");
SimpleType2.prototype = SimpleTypeClass.prototype;
Object.assign(SimpleType2, SimpleTypeDecorator);
SimpleType2[DECORATOR] = SimpleTypeDecorator;

// ../../build/common/esm/document/data-type/builtin/any.type.js
var AnyType = class AnyType2 {
  static {
    __name(this, "AnyType");
  }
};
AnyType = __decorate([
  SimpleType2({
    description: "Represents any value"
  })
], AnyType);

// ../../build/common/esm/document/data-type/builtin/approx-date.type.js
import { vg as vg5 } from "valgen";
var ApproxDateType = class ApproxDateType2 {
  static {
    __name(this, "ApproxDateType");
  }
};
ApproxDateType = __decorate([
  SimpleType2({
    description: "An approximate date value",
    example: [
      "2021-04-18",
      "2021-04",
      "2021"
    ],
    decoder: vg5.isDateString({ trim: "date" }),
    encoder: vg5.isDateString({ trim: "date" })
  })
], ApproxDateType);

// ../../build/common/esm/document/data-type/builtin/approx-datetime.type.js
import { isDateString } from "valgen";
var ApproxDatetimeType = class ApproxDatetimeType2 {
  static {
    __name(this, "ApproxDatetimeType");
  }
};
ApproxDatetimeType = __decorate([
  SimpleType2({
    description: "An approximate datetime value.",
    example: [
      "2021-04-18T22:30:15+01:00",
      "2021-04-18T22:30:15",
      "2021-04-18 22:30",
      "2021-04-18",
      "2021-04",
      "2021"
    ],
    decoder: isDateString,
    encoder: isDateString
  })
], ApproxDatetimeType);

// ../../build/common/esm/document/data-type/builtin/base64.type.js
import { isBase64 } from "valgen";
var Base64Type = class Base64Type2 {
  static {
    __name(this, "Base64Type");
  }
};
Base64Type = __decorate([
  SimpleType2({
    description: "A stream of bytes, base64 encoded",
    decoder: isBase64,
    encoder: isBase64
  })
], Base64Type);

// ../../build/common/esm/document/data-type/builtin/bigint.type.js
import { isBigint, isString, vg as vg6 } from "valgen";
var BigintType = class BigintType2 {
  static {
    __name(this, "BigintType");
  }
};
BigintType = __decorate([
  SimpleType2({
    description: "BigInt number",
    decoder: isBigint,
    encoder: vg6.pipe(isBigint, isString)
  })
], BigintType);

// ../../build/common/esm/document/data-type/builtin/boolean.type.js
import { isBoolean } from "valgen";
var BooleanType = class BooleanType2 {
  static {
    __name(this, "BooleanType");
  }
};
BooleanType = __decorate([
  SimpleType2({
    description: "Simple true/false value",
    decoder: isBoolean,
    encoder: isBoolean
  })
], BooleanType);

// ../../build/common/esm/document/data-type/builtin/date.type.js
import { vg as vg7 } from "valgen";
var DateType = class DateType2 {
  static {
    __name(this, "DateType");
  }
};
DateType = __decorate([
  SimpleType2({
    description: "A date without time",
    example: ["2021-04-18"],
    decoder: vg7.isDate({ precision: "date" }),
    encoder: vg7.isDateString({ precision: "date", trim: "date" })
  })
], DateType);

// ../../build/common/esm/document/data-type/builtin/datetime.type.js
import { vg as vg8 } from "valgen";
var DatetimeType = class DatetimeType2 {
  static {
    __name(this, "DatetimeType");
  }
};
DatetimeType = __decorate([
  SimpleType2({
    description: "A full datetime value",
    example: [
      "2021-04-18T22:30:15",
      "2021-04-18 22:30:15",
      "2021-04-18 22:30"
    ],
    decoder: vg8.isDate({ precision: "time" }),
    encoder: vg8.isDateString({ precision: "time", trim: "time" })
  })
], DatetimeType);

// ../../build/common/esm/document/data-type/builtin/email.type.js
import { vg as vg9 } from "valgen";
var EmailType = class EmailType2 {
  static {
    __name(this, "EmailType");
  }
};
EmailType = __decorate([
  SimpleType2({
    description: "An email value",
    decoder: vg9.isEmail(),
    encoder: vg9.isEmail()
  })
], EmailType);

// ../../build/common/esm/document/data-type/builtin/integer.type.js
import { isInteger } from "valgen";
var IntegerType = class IntegerType2 {
  static {
    __name(this, "IntegerType");
  }
};
IntegerType = __decorate([
  SimpleType2({
    description: "An integer number",
    decoder: isInteger,
    encoder: isInteger
  })
], IntegerType);

// ../../build/common/esm/document/data-type/builtin/null.type.js
import { isNull } from "valgen";
var NullType = class NullType2 {
  static {
    __name(this, "NullType");
  }
};
NullType = __decorate([
  SimpleType2({
    description: "A Null value",
    decoder: isNull,
    encoder: isNull
  })
], NullType);

// ../../build/common/esm/document/data-type/builtin/number.type.js
import { isNumber } from "valgen";
var NumberType = class NumberType2 {
  static {
    __name(this, "NumberType");
  }
};
NumberType = __decorate([
  SimpleType2({
    description: "Both Integer as well as Floating-Point numbers",
    decoder: isNumber,
    encoder: isNumber
  })
], NumberType);

// ../../build/common/esm/document/data-type/builtin/object.type.js
var ObjectType = class ObjectType2 {
  static {
    __name(this, "ObjectType");
  }
};
ObjectType = __decorate([
  ComplexType2({
    name: "object",
    description: "A non modelled object",
    additionalFields: true,
    ctor: Object
  })
], ObjectType);

// ../../build/common/esm/document/data-type/builtin/object-id.type.js
import { isObjectId, isString as isString2, vg as vg10 } from "valgen";
var ObjectIdType = class ObjectIdType2 {
  static {
    __name(this, "ObjectIdType");
  }
};
ObjectIdType = __decorate([
  SimpleType2({
    description: "A MongoDB ObjectID value",
    decoder: isObjectId,
    encoder: vg10.pipe(isObjectId, isString2)
  })
], ObjectIdType);

// ../../build/common/esm/document/data-type/builtin/string.type.js
import { isString as isString3 } from "valgen";
var StringType = class StringType2 {
  static {
    __name(this, "StringType");
  }
};
StringType = __decorate([
  SimpleType2({
    description: "A sequence of characters",
    decoder: isString3,
    encoder: isString3
  })
], StringType);

// ../../build/common/esm/document/data-type/builtin/time.type.js
import { vg as vg11 } from "valgen";
var TIME_PATTERN = /^([0-1][0-9]|2[0-4]):([0-5][0-9])(?::([0-5][0-9]))?$/;
var TimeType = class TimeType2 {
  static {
    __name(this, "TimeType");
  }
};
TimeType = __decorate([
  SimpleType2({
    description: "Time string in 24h format, for example, 18:23:00",
    decoder: vg11.isRegExp(TIME_PATTERN, {
      formatName: "time",
      onFail: () => "{{label}} is not a valid time"
    }),
    encoder: vg11.isRegExp(TIME_PATTERN, {
      formatName: "time",
      onFail: () => "{{label}} is not a valid time"
    })
  })
], TimeType);

// ../../build/common/esm/document/data-type/builtin/url.type.js
import { isURL as isURL2 } from "valgen";
var UrlType = class UrlType2 {
  static {
    __name(this, "UrlType");
  }
};
UrlType = __decorate([
  SimpleType2({
    description: "A Uniform Resource Identifier Reference (RFC 3986 icon) value",
    decoder: isURL2,
    encoder: isURL2
  })
], UrlType);

// ../../build/common/esm/document/data-type/builtin/uuid.type.js
import { isUUID } from "valgen";
var UuidType = class UuidType2 {
  static {
    __name(this, "UuidType");
  }
};
UuidType = __decorate([
  SimpleType2({
    description: "A Universal Unique Identifier (UUID) value",
    decoder: isUUID,
    encoder: isUUID
  })
], UuidType);

// ../../build/common/esm/document/data-type/mapped-type.js
import "reflect-metadata";
import merge8 from "putil-merge";

// ../../build/common/esm/document/data-type/mapped-type-class.js
var MappedTypeClass = class extends ComplexTypeClass {
  static {
    __name(this, "MappedTypeClass");
  }
  constructor(document, init) {
    super(document, init);
    this.kind = opra_schema_ns_exports.MappedType.Kind;
    const own = this.own;
    own.pick = init.pick;
    own.omit = init.omit;
    own.partial = init.partial;
    this.kind = opra_schema_ns_exports.MappedType.Kind;
    this.pick = own.pick;
    this.omit = own.omit;
    this.partial = own.partial;
    const isInheritedPredicate = getIsInheritedPredicateFn(init.pick, init.omit);
    for (const fieldName of this.fields.keys()) {
      if (!isInheritedPredicate(fieldName)) {
        this.fields.delete(fieldName);
      }
      if (this.partial === true || Array.isArray(this.partial) && this.partial.includes(fieldName)) {
        const f = this.fields.get(fieldName);
        if (f)
          f.required = false;
      }
    }
  }
  exportSchema() {
    const out = super.exportSchema();
    Object.assign(out, omitUndefined({
      pick: this.own.pick,
      omit: this.own.omit,
      partial: this.own.partial
    }));
    return out;
  }
};
function getIsInheritedPredicateFn(pick, omit4) {
  const pickKeys = pick?.map((x) => String(x).toLowerCase());
  const omitKeys = omit4?.map((x) => String(x).toLowerCase());
  return (propertyName) => {
    if (omitKeys && omitKeys.includes(propertyName.toLowerCase()))
      return false;
    if (pickKeys)
      return pickKeys.includes(propertyName.toLowerCase());
    return true;
  };
}
__name(getIsInheritedPredicateFn, "getIsInheritedPredicateFn");

// ../../build/common/esm/document/data-type/mapped-type.js
function PickType(classRef, keys) {
  return MappedType2(classRef, { pick: keys });
}
__name(PickType, "PickType");
function OmitType(classRef, keys) {
  return MappedType2(classRef, { omit: keys });
}
__name(OmitType, "OmitType");
function PartialType(classRef, keys) {
  return MappedType2(classRef, { partial: keys || true });
}
__name(PartialType, "PartialType");
var MappedType2 = /* @__PURE__ */ __name(function(...args) {
  if (this) {
    const [document, init] = args;
    merge8(this, new MappedTypeClass(document, init), { descriptor: true });
    return;
  }
  const [mappedSource, options] = args;
  const isInheritedPredicate = getIsInheritedPredicateFn(options.pick, options.omit);
  class MappedClass {
    static {
      __name(this, "MappedClass");
    }
    constructor() {
      inheritPropertyInitializers(this, mappedSource, isInheritedPredicate);
    }
  }
  mergePrototype(MappedClass.prototype, mappedSource.prototype);
  const m = Reflect.getOwnMetadata(DATATYPE_METADATA, mappedSource);
  if (!m)
    throw new TypeError(`Class "${mappedSource}" doesn't have datatype metadata information`);
  if (!(m.kind === opra_schema_ns_exports.ComplexType.Kind || m.kind === opra_schema_ns_exports.MappedType.Kind || m.kind === opra_schema_ns_exports.MixinType.Kind))
    throw new TypeError(`Class "${mappedSource}" is not a ${opra_schema_ns_exports.ComplexType.Kind}`);
  const metadata = {
    kind: "MappedType",
    base: mappedSource
  };
  if (options.pick)
    metadata.pick = options.pick;
  if (options.omit)
    metadata.omit = options.omit;
  if (options.partial)
    metadata.partial = options.partial;
  Reflect.defineMetadata(DATATYPE_METADATA, metadata, MappedClass);
  MappedType2._applyMixin(MappedClass, mappedSource, {
    ...options,
    isInheritedPredicate
  });
  return MappedClass;
}, "MappedType");
MappedType2.prototype = MappedTypeClass.prototype;
MappedType2._applyMixin = () => void 0;

// ../../build/common/esm/document/data-type/mixin-type.js
import "reflect-metadata";
import merge9 from "putil-merge";

// ../../build/common/esm/document/data-type/mixin-type-class.js
var MixinTypeClass = class extends ComplexType2 {
  static {
    __name(this, "MixinTypeClass");
  }
  constructor(document, init) {
    super(document, init);
    this.kind = opra_schema_ns_exports.MixinType.Kind;
    const own = this.own;
    own.types = [];
    const MixinType3 = Object.getPrototypeOf(this).constructor;
    for (const base of init.types) {
      if (!(base instanceof ComplexType2 || base instanceof MixinType3 || base instanceof MappedType2))
        throw new TypeError(`${opra_schema_ns_exports.MixinType.Kind} shall contain ${opra_schema_ns_exports.ComplexType.Kind}, ${opra_schema_ns_exports.MixinType.Kind} of ${opra_schema_ns_exports.MappedType.Kind} types.`);
      own.types.push(base);
      if (base.additionalFields === true && this.additionalFields !== true) {
        this.additionalFields = true;
      } else if (base.additionalFields === "error" && !this.additionalFields) {
        this.additionalFields = "error";
      }
      this.fields.setAll(base.fields);
    }
    this.types = [...own.types];
  }
  // @ts-ignore
  exportSchema() {
    const out = super.exportSchema();
    out.types = this.own.types.map((t) => t.name ? t.name : t.exportSchema());
    return out;
  }
};

// ../../build/common/esm/document/data-type/mixin-type.js
var MixinType2 = /* @__PURE__ */ __name(function(...args) {
  if (this) {
    const [document, init] = args;
    merge9(this, new MixinTypeClass(document, init), { descriptor: true });
    return;
  }
  const clasRefs = [...args].filter((x) => !!x);
  if (!clasRefs.length)
    throw new TypeError("No Class has been provided");
  if (clasRefs.length === 1)
    return clasRefs[0];
  class MixinClass {
    static {
      __name(this, "MixinClass");
    }
    constructor() {
      for (const c of clasRefs)
        inheritPropertyInitializers(this, c);
    }
  }
  const metadata = {
    kind: opra_schema_ns_exports.MixinType.Kind,
    types: []
  };
  Reflect.defineMetadata(DATATYPE_METADATA, metadata, MixinClass);
  for (const c of clasRefs) {
    const itemMeta = Reflect.getMetadata(DATATYPE_METADATA, c);
    if (!(itemMeta && (itemMeta.kind === opra_schema_ns_exports.ComplexType.Kind || itemMeta.kind === opra_schema_ns_exports.MixinType.Kind || itemMeta.kind === opra_schema_ns_exports.MappedType.Kind)))
      throw new TypeError(`Class "${c.name}" is not a ${opra_schema_ns_exports.ComplexType.Kind}, ${opra_schema_ns_exports.MixinType.Kind} or ${opra_schema_ns_exports.MappedType.Kind}`);
    metadata.types.push(c);
    mergePrototype(MixinType2.prototype, c.prototype);
  }
  MixinType2._applyMixin(MixinClass, ...clasRefs);
  return MixinClass;
}, "MixinType");
MixinType2.prototype = MixinTypeClass.prototype;
MixinType2._applyMixin = () => void 0;

// ../../build/common/esm/document/factory/type-document-factory.js
var TypeDocumentFactory = class _TypeDocumentFactory {
  static {
    __name(this, "TypeDocumentFactory");
  }
  constructor() {
    this.typeQueue = new ResponsiveMap();
    this.circularRefs = /* @__PURE__ */ new Map();
    this.curPath = [];
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Creates ApiDocument instance from given schema object
   */
  static async createDocument(init) {
    const factory = new _TypeDocumentFactory();
    const document = factory.document = new TypeDocument();
    await factory.initDocument(init);
    return document;
  }
  /**
   * Downloads schema from the given URL and creates the document instance   * @param url
   */
  static async createDocumentFromUrl(url) {
    const factory = new _TypeDocumentFactory();
    const document = factory.document = new TypeDocument();
    await factory.initDocumentFromUrl(url);
    return document;
  }
  async initDocument(init) {
    init.version = init.version || opra_schema_ns_exports.SpecVersion;
    this.document.url = init.url;
    if (init.info)
      Object.assign(this.document.info, init.info);
    if (!init?.noBuiltinTypes) {
      const builtinDocument = await this.createBuiltinTypeDocument();
      this.document.references.set("opra", builtinDocument);
    }
    if (init.references)
      await this.addReferences(init.references);
    if (init.types) {
      this.curPath.push("Types->");
      if (Array.isArray(init.types)) {
        let i = 0;
        for (const thunk of init.types) {
          const metadata = Reflect.getMetadata(DATATYPE_METADATA, thunk) || thunk[DATATYPE_METADATA];
          if (!(metadata && metadata.name))
            throw new TypeError(`Metadata information not found at types[${i++}] "${String(thunk)}"`);
          this.typeQueue.set(metadata.name, thunk);
        }
      } else
        for (const [name, schema] of Object.entries(init.types)) {
          this.typeQueue.set(name, { ...schema, name });
        }
      for (const thunk of this.typeQueue.values()) {
        await this.importDataType(thunk);
      }
      this.document.types.sort();
      this.curPath.pop();
    }
    this.document.invalidate();
    return this.document;
  }
  async initDocumentFromUrl(url) {
    const resp = await fetch(url, { method: "GET" });
    const init = await resp.json();
    if (!init)
      throw new TypeError(`Invalid response returned from url: ${url}`);
    return await this.initDocument({ ...init, url });
  }
  async createBuiltinTypeDocument() {
    const init = {
      version: opra_schema_ns_exports.SpecVersion,
      url: "https://oprajs.com/spec/v1.0",
      info: {
        version: opra_schema_ns_exports.SpecVersion,
        title: "Opra built-in types",
        license: {
          url: "https://github.com/oprajs/opra/blob/main/LICENSE",
          name: "MIT"
        }
      },
      types: [
        AnyType,
        Base64Type,
        BigintType,
        BooleanType,
        DateType,
        EmailType,
        IntegerType,
        NullType,
        NumberType,
        ObjectIdType,
        ObjectType,
        ApproxDateType,
        ApproxDatetimeType,
        StringType,
        DatetimeType,
        TimeType,
        UrlType,
        UuidType
      ]
    };
    const factory = new _TypeDocumentFactory();
    factory.document = new TypeDocument();
    return await factory.initDocument({ ...init, noBuiltinTypes: true });
  }
  async addReferences(references) {
    const { document } = this;
    let ns;
    let r;
    for ([ns, r] of Object.entries(references)) {
      r = await r;
      if (typeof r === "string") {
        document.references.set(ns, await this.initDocumentFromUrl(r));
      } else if (r instanceof TypeDocument)
        document.references.set(ns, r);
      else if (typeof r === "object") {
        document.references.set(ns, await this.initDocument(r));
      } else
        throw new TypeError(`Invalid document reference (${ns}) in schema`);
    }
  }
  async importDataType(thunk) {
    thunk = await resolveThunk(thunk);
    let name = "";
    let ctor;
    if (typeof thunk === "string") {
      name = thunk;
      thunk = this.typeQueue.get(name);
    }
    let initArguments;
    if (typeof thunk === "function") {
      const metadata = Reflect.getMetadata(DATATYPE_METADATA, thunk);
      if (!metadata) {
        const dataType = this.document.getDataType(thunk, true);
        if (dataType)
          return dataType;
        throw new TypeError(`Class "${thunk.name}" doesn't have a valid DataType metadata`);
      }
      name = metadata.embedded ? void 0 : metadata.name;
      initArguments = cloneObject(metadata);
      ctor = thunk;
    } else if (typeof thunk === "object") {
      if (opra_schema_ns_exports.isDataType(thunk)) {
        name = thunk.name;
        ctor = thunk.ctor || ctor;
        initArguments = cloneObject(thunk);
      } else {
        const metadata = thunk[DATATYPE_METADATA];
        if (!metadata)
          throw new TypeError(`No EnumType metadata found for object ${JSON.stringify(thunk).substring(0, 20)}...`);
        name = metadata.embedded ? void 0 : metadata.name;
        initArguments = cloneObject(metadata);
        initArguments.enumObject = thunk;
      }
    }
    ctor = ctor ?? (initArguments && isConstructor(initArguments.ctor) ? initArguments.ctor : void 0);
    if (name) {
      if (this.circularRefs.has(name.toLowerCase()))
        throw new TypeError("Circular reference detected");
      const dataType = this.document.getDataType(name, true);
      if (dataType)
        return dataType;
      this.curPath.push("/" + name);
      this.circularRefs.set(name, 1);
    }
    if (ctor) {
      if (this.circularRefs.has(ctor))
        throw new TypeError("Circular reference detected");
      const dataType = this.document.getDataType(ctor, true);
      if (dataType)
        return dataType;
      this.circularRefs.set(ctor, 1);
    }
    try {
      if (!initArguments)
        throw new TypeError(`No DataType schema determined`);
      const instance = this.createDataTypeInstance(initArguments.kind, name);
      if (name)
        this.document.types.set(name, instance);
      await this.prepareDataTypeInitArguments(initArguments, ctor);
      if (initArguments.kind === "ComplexType") {
        if (typeof initArguments.additionalFields === "function")
          initArguments.additionalFields = await this.importDataType(initArguments.additionalFields);
        ComplexType2.apply(instance, [this.document, initArguments]);
      } else if (initArguments.kind === "SimpleType")
        SimpleType2.apply(instance, [this.document, initArguments]);
      else if (initArguments.kind === "EnumType")
        EnumType2.apply(instance, [this.document, initArguments]);
      else if (initArguments.kind === "MappedType")
        MappedType2.apply(instance, [this.document, initArguments]);
      else if (initArguments.kind === "MixinType")
        MixinType2.apply(instance, [this.document, initArguments]);
      else
        throw new TypeError(`Invalid data type schema: ${String(initArguments)}`);
      return instance;
    } finally {
      if (name) {
        this.curPath.pop();
        this.circularRefs.delete(name.toLowerCase());
      }
      if (ctor)
        this.circularRefs.delete(ctor);
    }
  }
  async prepareDataTypeInitArguments(schema, ctor) {
    const initArguments = schema;
    if (initArguments.kind === "SimpleType" || initArguments.kind === "ComplexType" || initArguments.kind === "EnumType") {
      if (ctor) {
        const baseClass = Object.getPrototypeOf(ctor.prototype).constructor;
        const baseMeta = Reflect.getMetadata(DATATYPE_METADATA, baseClass);
        if (baseMeta) {
          initArguments.base = await this.importDataType(baseClass);
        }
      } else if (initArguments.base) {
        initArguments.base = await this.importDataType(initArguments.base);
      }
    }
    if (initArguments.kind === "SimpleType" && ctor) {
      if (typeof ctor.prototype.decode === "function")
        initArguments.decoder = initArguments.name ? validator(initArguments.name, ctor.prototype.decode) : validator(ctor.prototype.decode);
      if (typeof ctor.prototype.encode === "function")
        initArguments.decoder = initArguments.name ? validator(initArguments.name, ctor.prototype.encode) : validator(ctor.prototype.encode);
      return;
    }
    if (initArguments.kind === "ComplexType") {
      initArguments.ctor = ctor;
      if (initArguments.fields) {
        const srcFields = initArguments.fields;
        const trgFields = initArguments.fields = {};
        for (const [fieldName, o] of Object.entries(srcFields)) {
          try {
            this.curPath.push("." + fieldName);
            const srcMeta = typeof o === "string" ? { type: o } : o;
            const fieldInit = trgFields[fieldName] = {
              ...srcMeta,
              name: fieldName
            };
            if (srcMeta.enum) {
              const enumObject = srcMeta.enum;
              delete srcMeta.enum;
              if (enumObject[DATATYPE_METADATA]) {
                fieldInit.type = await this.importDataType(enumObject);
              } else {
                const enumMeta = EnumType2(enumObject, { name: "" });
                fieldInit.type = await this.importDataType({ ...enumMeta, kind: "EnumType", base: void 0 });
              }
            } else {
              if (srcMeta.isArray && !srcMeta.type)
                throw new TypeError(`"type" must be defined explicitly for array properties`);
              fieldInit.type = await this.importDataType(srcMeta.type || srcMeta.designType || "any");
            }
            this.curPath.pop();
          } catch (e) {
            e.message = `Error in resource "${initArguments.name}.${fieldName}". ` + e.message;
            throw e;
          }
        }
      }
    }
    if (initArguments.kind === "MappedType") {
      const dataType = await this.importDataType(initArguments.base);
      if (!(dataType instanceof ComplexType2))
        throw new TypeError("MappedType.type property must address to a ComplexType");
      initArguments.base = dataType;
    }
    if (initArguments.kind === "MixinType") {
      const oldTypes = initArguments.types;
      initArguments.types = [];
      for (const type of oldTypes)
        initArguments.types.push(await this.importDataType(type));
    }
    return initArguments;
  }
  createDataTypeInstance(kind, name) {
    const dataType = {
      document: this.document,
      kind,
      name
    };
    switch (kind) {
      case opra_schema_ns_exports.ComplexType.Kind:
        Object.setPrototypeOf(dataType, ComplexType2.prototype);
        break;
      case opra_schema_ns_exports.EnumType.Kind:
        Object.setPrototypeOf(dataType, EnumType2.prototype);
        break;
      case opra_schema_ns_exports.MappedType.Kind:
        Object.setPrototypeOf(dataType, MappedType2.prototype);
        break;
      case opra_schema_ns_exports.SimpleType.Kind:
        Object.setPrototypeOf(dataType, SimpleType2.prototype);
        break;
      case opra_schema_ns_exports.MixinType.Kind:
        Object.setPrototypeOf(dataType, MixinType2.prototype);
        break;
      default:
        throw new TypeError(`Unknown DataType kind (${kind})`);
    }
    return dataType;
  }
};
TypeDocumentFactory.designTypeMap = /* @__PURE__ */ new Map();

// ../../build/common/esm/document/resource/collection.js
import merge10 from "putil-merge";

// ../../build/common/esm/document/resource/collection-class.js
import { vg as vg13 } from "valgen";

// ../../build/common/esm/filter/opra-filter.ns.js
var opra_filter_ns_exports = {};
__export(opra_filter_ns_exports, {
  $and: () => $and,
  $arithmetic: () => $arithmetic,
  $array: () => $array,
  $date: () => $date,
  $eq: () => $eq,
  $field: () => $field,
  $gt: () => $gt,
  $gte: () => $gte,
  $ilike: () => $ilike,
  $in: () => $in,
  $like: () => $like,
  $lt: () => $lt,
  $lte: () => $lte,
  $ne: () => $ne,
  $notILike: () => $notILike,
  $notIn: () => $notIn,
  $notLike: () => $notLike,
  $number: () => $number,
  $or: () => $or,
  $paren: () => $paren,
  $time: () => $time,
  ArithmeticExpression: () => ArithmeticExpression,
  ArithmeticExpressionItem: () => ArithmeticExpressionItem,
  ArrayExpression: () => ArrayExpression,
  Ast: () => Ast,
  BooleanLiteral: () => BooleanLiteral,
  ComparisonExpression: () => ComparisonExpression,
  DateLiteral: () => DateLiteral,
  Expression: () => Expression,
  FilterTreeVisitor: () => FilterTreeVisitor,
  Literal: () => Literal,
  LogicalExpression: () => LogicalExpression,
  NegativeExpression: () => NegativeExpression,
  NullLiteral: () => NullLiteral,
  NumberLiteral: () => NumberLiteral,
  OpraErrorListener: () => OpraErrorListener,
  ParenthesizedExpression: () => ParenthesizedExpression,
  QualifiedIdentifier: () => QualifiedIdentifier,
  StringLiteral: () => StringLiteral,
  Term: () => Term,
  TimeLiteral: () => TimeLiteral,
  parse: () => parse
});

// ../../build/common/esm/filter/ast/abstract/ast.js
var Ast = class {
  static {
    __name(this, "Ast");
  }
  constructor() {
    this.kind = Object.getPrototypeOf(this).constructor.name;
  }
};

// ../../build/common/esm/filter/ast/abstract/expression.js
var Expression = class extends Ast {
  static {
    __name(this, "Expression");
  }
};

// ../../build/common/esm/filter/ast/abstract/term.js
var Term = class extends Expression {
  static {
    __name(this, "Term");
  }
};

// ../../build/common/esm/filter/ast/abstract/literal.js
var Literal = class extends Term {
  static {
    __name(this, "Literal");
  }
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return "" + this.value;
  }
};

// ../../build/common/esm/filter/ast/expressions/arithmetic-expression.js
var ArithmeticExpression = class extends Expression {
  static {
    __name(this, "ArithmeticExpression");
  }
  constructor() {
    super();
    this.items = [];
  }
  append(op, expression) {
    this.items.push(new ArithmeticExpressionItem({
      op,
      expression
    }));
    return this;
  }
  toString() {
    return this.items.map((child, i) => (i > 0 ? child.op : "") + child.expression).join("");
  }
};
var ArithmeticExpressionItem = class {
  static {
    __name(this, "ArithmeticExpressionItem");
  }
  constructor(o) {
    Object.assign(this, o);
  }
};

// ../../build/common/esm/filter/ast/expressions/array-expression.js
var ArrayExpression = class extends Term {
  static {
    __name(this, "ArrayExpression");
  }
  constructor(items) {
    super();
    this.items = items;
  }
  toString() {
    return "[" + this.items.map((child) => "" + child).join(",") + "]";
  }
};

// ../../build/common/esm/filter/ast/expressions/comparison-expression.js
var WORD_PATTERN = /\w/;
var ComparisonExpression = class extends Expression {
  static {
    __name(this, "ComparisonExpression");
  }
  constructor(o) {
    super();
    Object.assign(this, o);
  }
  toString() {
    return `${this.left}${WORD_PATTERN.test(this.op) ? " " + this.op + " " : this.op}${this.right}`;
  }
};

// ../../build/common/esm/filter/ast/expressions/logical-expression.js
var LogicalExpression = class extends Expression {
  static {
    __name(this, "LogicalExpression");
  }
  constructor(o) {
    super();
    Object.assign(this, o);
    if (this.op === "&&")
      this.op = "and";
    if (this.op === "||")
      this.op = "or";
  }
  toString() {
    return this.items.map((child) => "" + child).join(" " + this.op + " ");
  }
};

// ../../build/common/esm/filter/ast/expressions/parenthesized-expression.js
var ParenthesizedExpression = class extends Expression {
  static {
    __name(this, "ParenthesizedExpression");
  }
  constructor(expression) {
    super();
    this.expression = expression;
  }
  toString() {
    return `(${this.expression})`;
  }
};

// ../../build/common/esm/filter/ast/expressions/negative-expression.js
var NegativeExpression = class extends Expression {
  static {
    __name(this, "NegativeExpression");
  }
  constructor(expression) {
    super();
    this.expression = expression;
  }
  toString() {
    return `(${this.expression})`;
  }
};

// ../../build/common/esm/filter/ast/terms/boolean-literal.js
var BooleanLiteral = class extends Literal {
  static {
    __name(this, "BooleanLiteral");
  }
  constructor(value) {
    super(value);
  }
};

// ../../build/common/esm/filter/ast/terms/date-literal.js
import { toDateDef } from "putil-varhelpers";

// ../../build/common/esm/filter/errors.js
var SyntaxError = class extends TypeError {
  static {
    __name(this, "SyntaxError");
  }
};
var FilterValidationError = class extends TypeError {
  static {
    __name(this, "FilterValidationError");
  }
  constructor(message) {
    super(typeof message === "string" ? message : message?.message);
    if (typeof message === "object")
      Object.assign(this, message);
  }
};
var FilterParseError = class extends Error {
  static {
    __name(this, "FilterParseError");
  }
  constructor(message, args) {
    super(message);
    Object.assign(this, args);
  }
};

// ../../build/common/esm/filter/utils.js
var quotesRegEx = /'/g;
var escapeRegEx2 = /(\\)/g;
var unescapeRegEx2 = /\\(.)/g;
function escapeString2(s) {
  return s.replace(escapeRegEx2, "\\\\");
}
__name(escapeString2, "escapeString");
function unescapeString2(s) {
  return s.replace(unescapeRegEx2, "$1");
}
__name(unescapeString2, "unescapeString");
function quoteFilterString(s) {
  return "'" + escapeString2(s).replace(quotesRegEx, "\\'") + "'";
}
__name(quoteFilterString, "quoteFilterString");
function unquoteFilterString(s) {
  if (s && (s.startsWith("'") || s.startsWith('"')) && s.endsWith(s.charAt(0))) {
    return unescapeString2(s.substring(1, s.length - 1));
  }
  return s;
}
__name(unquoteFilterString, "unquoteFilterString");

// ../../build/common/esm/filter/ast/terms/date-literal.js
var NullDate = /* @__PURE__ */ new Date(0);
var DateLiteral = class extends Literal {
  static {
    __name(this, "DateLiteral");
  }
  constructor(value) {
    super("");
    if (value instanceof Date) {
      this.value = value.toISOString();
      return;
    }
    if (typeof value === "string" && toDateDef(value, NullDate) !== NullDate) {
      this.value = value;
      return;
    }
    throw new FilterValidationError(`Invalid date value "${value}"`);
  }
  toString() {
    return quoteFilterString(this.value);
  }
};

// ../../build/common/esm/filter/ast/terms/null-literal.js
var NullLiteral = class extends Literal {
  static {
    __name(this, "NullLiteral");
  }
  constructor() {
    super(null);
    this.value = null;
  }
};

// ../../build/common/esm/filter/ast/terms/number-literal.js
var NumberLiteral = class extends Literal {
  static {
    __name(this, "NumberLiteral");
  }
  constructor(value) {
    super(0);
    if (typeof value === "number" || typeof value === "bigint") {
      this.value = value;
      return;
    }
    try {
      if (typeof value === "string") {
        if (value.includes(".")) {
          this.value = parseFloat(value);
          return;
        }
        const n = Number(value);
        if ("" + n === value)
          this.value = n;
        else
          this.value = BigInt(value);
        return;
      }
    } catch {
    }
    throw new FilterValidationError(`Invalid number literal ${value}`);
  }
  toString() {
    return typeof this.value === "bigint" ? ("" + this.value).replace(/n$/, "") : "" + this.value;
  }
};

// ../../build/common/esm/filter/ast/terms/qualified-identifier.js
var QualifiedIdentifier = class extends Literal {
  static {
    __name(this, "QualifiedIdentifier");
  }
  constructor(value) {
    super("" + value);
  }
};

// ../../build/common/esm/filter/ast/terms/string-literal.js
var StringLiteral = class extends Literal {
  static {
    __name(this, "StringLiteral");
  }
  constructor(value) {
    super("" + value);
  }
  toString() {
    return quoteFilterString(this.value);
  }
};

// ../../build/common/esm/filter/ast/terms/time-literal.js
var TIME_PATTERN2 = /^([01]\d|2[0-3]):([0-5]\d)(:[0-5]\d)?(\.(\d+))?$/;
var TimeLiteral = class extends Literal {
  static {
    __name(this, "TimeLiteral");
  }
  constructor(value) {
    super("");
    if (value instanceof Date) {
      this.value = pad(value.getHours()) + ":" + pad(value.getMinutes()) + (value.getSeconds() ? ":" + pad(value.getSeconds()) : "") + (value.getMilliseconds() ? "." + pad(value.getMilliseconds()) : "");
      return;
    }
    if (typeof value === "string" && TIME_PATTERN2.test(value)) {
      this.value = value;
      return;
    }
    throw new FilterValidationError(`Invalid time value "${value}"`);
  }
  toString() {
    return quoteFilterString(this.value);
  }
};
function pad(n) {
  return n <= 9 ? "0" + n : "" + n;
}
__name(pad, "pad");

// ../../build/common/esm/filter/parse.js
import { CharStream, CommonTokenStream } from "@browsery/antlr4";

// ../../build/common/esm/filter/antlr/OpraFilterLexer.js
import { ATNDeserializer, DFA, Lexer, LexerATNSimulator, PredictionContextCache, Token } from "@browsery/antlr4";
var OpraFilterLexer = class _OpraFilterLexer extends Lexer {
  static {
    __name(this, "OpraFilterLexer");
  }
  constructor(input) {
    super(input);
    this._interp = new LexerATNSimulator(this, _OpraFilterLexer._ATN, _OpraFilterLexer.DecisionsToDFA, new PredictionContextCache());
  }
  get grammarFileName() {
    return "OpraFilter.g4";
  }
  get literalNames() {
    return _OpraFilterLexer.literalNames;
  }
  get symbolicNames() {
    return _OpraFilterLexer.symbolicNames;
  }
  get ruleNames() {
    return _OpraFilterLexer.ruleNames;
  }
  get serializedATN() {
    return _OpraFilterLexer._serializedATN;
  }
  get channelNames() {
    return _OpraFilterLexer.channelNames;
  }
  get modeNames() {
    return _OpraFilterLexer.modeNames;
  }
  static get _ATN() {
    if (!_OpraFilterLexer.__ATN) {
      _OpraFilterLexer.__ATN = new ATNDeserializer().deserialize(_OpraFilterLexer._serializedATN);
    }
    return _OpraFilterLexer.__ATN;
  }
};
OpraFilterLexer.T__0 = 1;
OpraFilterLexer.T__1 = 2;
OpraFilterLexer.T__2 = 3;
OpraFilterLexer.T__3 = 4;
OpraFilterLexer.T__4 = 5;
OpraFilterLexer.T__5 = 6;
OpraFilterLexer.T__6 = 7;
OpraFilterLexer.T__7 = 8;
OpraFilterLexer.T__8 = 9;
OpraFilterLexer.T__9 = 10;
OpraFilterLexer.T__10 = 11;
OpraFilterLexer.T__11 = 12;
OpraFilterLexer.T__12 = 13;
OpraFilterLexer.T__13 = 14;
OpraFilterLexer.T__14 = 15;
OpraFilterLexer.T__15 = 16;
OpraFilterLexer.T__16 = 17;
OpraFilterLexer.T__17 = 18;
OpraFilterLexer.T__18 = 19;
OpraFilterLexer.T__19 = 20;
OpraFilterLexer.T__20 = 21;
OpraFilterLexer.T__21 = 22;
OpraFilterLexer.T__22 = 23;
OpraFilterLexer.T__23 = 24;
OpraFilterLexer.T__24 = 25;
OpraFilterLexer.T__25 = 26;
OpraFilterLexer.T__26 = 27;
OpraFilterLexer.T__27 = 28;
OpraFilterLexer.T__28 = 29;
OpraFilterLexer.T__29 = 30;
OpraFilterLexer.T__30 = 31;
OpraFilterLexer.T__31 = 32;
OpraFilterLexer.T__32 = 33;
OpraFilterLexer.T__33 = 34;
OpraFilterLexer.IDENTIFIER = 35;
OpraFilterLexer.POLAR_OP = 36;
OpraFilterLexer.DATE = 37;
OpraFilterLexer.DATETIME = 38;
OpraFilterLexer.TIME = 39;
OpraFilterLexer.NUMBER = 40;
OpraFilterLexer.INTEGER = 41;
OpraFilterLexer.STRING = 42;
OpraFilterLexer.WHITESPACE = 43;
OpraFilterLexer.EOF = Token.EOF;
OpraFilterLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
OpraFilterLexer.literalNames = [
  null,
  "'('",
  "')'",
  "'not'",
  "'!'",
  "'.'",
  "'@'",
  "'['",
  "','",
  "']'",
  "'true'",
  "'false'",
  "'null'",
  "'Infinity'",
  "'infinity'",
  "'+'",
  "'-'",
  "'*'",
  "'/'",
  "'<='",
  "'<'",
  "'>'",
  "'>='",
  "'='",
  "'!='",
  "'in'",
  "'!in'",
  "'like'",
  "'!like'",
  "'ilike'",
  "'!ilike'",
  "'and'",
  "'or'",
  "'&&'",
  "'||'"
];
OpraFilterLexer.symbolicNames = [
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "IDENTIFIER",
  "POLAR_OP",
  "DATE",
  "DATETIME",
  "TIME",
  "NUMBER",
  "INTEGER",
  "STRING",
  "WHITESPACE"
];
OpraFilterLexer.modeNames = ["DEFAULT_MODE"];
OpraFilterLexer.ruleNames = [
  "T__0",
  "T__1",
  "T__2",
  "T__3",
  "T__4",
  "T__5",
  "T__6",
  "T__7",
  "T__8",
  "T__9",
  "T__10",
  "T__11",
  "T__12",
  "T__13",
  "T__14",
  "T__15",
  "T__16",
  "T__17",
  "T__18",
  "T__19",
  "T__20",
  "T__21",
  "T__22",
  "T__23",
  "T__24",
  "T__25",
  "T__26",
  "T__27",
  "T__28",
  "T__29",
  "T__30",
  "T__31",
  "T__32",
  "T__33",
  "IDENTIFIER",
  "POLAR_OP",
  "DATE",
  "DATETIME",
  "TIME",
  "NUMBER",
  "INTEGER",
  "STRING",
  "WHITESPACE",
  "DIGIT",
  "DATEFORMAT",
  "TIMEFORMAT",
  "TIMEZONEOFFSETFORMAT",
  "ESC",
  "UNICODE",
  "HEX"
];
OpraFilterLexer._serializedATN = [
  4,
  0,
  43,
  426,
  6,
  -1,
  2,
  0,
  7,
  0,
  2,
  1,
  7,
  1,
  2,
  2,
  7,
  2,
  2,
  3,
  7,
  3,
  2,
  4,
  7,
  4,
  2,
  5,
  7,
  5,
  2,
  6,
  7,
  6,
  2,
  7,
  7,
  7,
  2,
  8,
  7,
  8,
  2,
  9,
  7,
  9,
  2,
  10,
  7,
  10,
  2,
  11,
  7,
  11,
  2,
  12,
  7,
  12,
  2,
  13,
  7,
  13,
  2,
  14,
  7,
  14,
  2,
  15,
  7,
  15,
  2,
  16,
  7,
  16,
  2,
  17,
  7,
  17,
  2,
  18,
  7,
  18,
  2,
  19,
  7,
  19,
  2,
  20,
  7,
  20,
  2,
  21,
  7,
  21,
  2,
  22,
  7,
  22,
  2,
  23,
  7,
  23,
  2,
  24,
  7,
  24,
  2,
  25,
  7,
  25,
  2,
  26,
  7,
  26,
  2,
  27,
  7,
  27,
  2,
  28,
  7,
  28,
  2,
  29,
  7,
  29,
  2,
  30,
  7,
  30,
  2,
  31,
  7,
  31,
  2,
  32,
  7,
  32,
  2,
  33,
  7,
  33,
  2,
  34,
  7,
  34,
  2,
  35,
  7,
  35,
  2,
  36,
  7,
  36,
  2,
  37,
  7,
  37,
  2,
  38,
  7,
  38,
  2,
  39,
  7,
  39,
  2,
  40,
  7,
  40,
  2,
  41,
  7,
  41,
  2,
  42,
  7,
  42,
  2,
  43,
  7,
  43,
  2,
  44,
  7,
  44,
  2,
  45,
  7,
  45,
  2,
  46,
  7,
  46,
  2,
  47,
  7,
  47,
  2,
  48,
  7,
  48,
  2,
  49,
  7,
  49,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  2,
  1,
  3,
  1,
  3,
  1,
  4,
  1,
  4,
  1,
  5,
  1,
  5,
  1,
  6,
  1,
  6,
  1,
  7,
  1,
  7,
  1,
  8,
  1,
  8,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  10,
  1,
  11,
  1,
  11,
  1,
  11,
  1,
  11,
  1,
  11,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  12,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  13,
  1,
  14,
  1,
  14,
  1,
  15,
  1,
  15,
  1,
  16,
  1,
  16,
  1,
  17,
  1,
  17,
  1,
  18,
  1,
  18,
  1,
  18,
  1,
  19,
  1,
  19,
  1,
  20,
  1,
  20,
  1,
  21,
  1,
  21,
  1,
  21,
  1,
  22,
  1,
  22,
  1,
  23,
  1,
  23,
  1,
  23,
  1,
  24,
  1,
  24,
  1,
  24,
  1,
  25,
  1,
  25,
  1,
  25,
  1,
  25,
  1,
  26,
  1,
  26,
  1,
  26,
  1,
  26,
  1,
  26,
  1,
  27,
  1,
  27,
  1,
  27,
  1,
  27,
  1,
  27,
  1,
  27,
  1,
  28,
  1,
  28,
  1,
  28,
  1,
  28,
  1,
  28,
  1,
  28,
  1,
  29,
  1,
  29,
  1,
  29,
  1,
  29,
  1,
  29,
  1,
  29,
  1,
  29,
  1,
  30,
  1,
  30,
  1,
  30,
  1,
  30,
  1,
  31,
  1,
  31,
  1,
  31,
  1,
  32,
  1,
  32,
  1,
  32,
  1,
  33,
  1,
  33,
  1,
  33,
  1,
  34,
  1,
  34,
  5,
  34,
  225,
  8,
  34,
  10,
  34,
  12,
  34,
  228,
  9,
  34,
  1,
  35,
  1,
  35,
  1,
  36,
  1,
  36,
  1,
  36,
  1,
  36,
  1,
  36,
  1,
  36,
  1,
  36,
  1,
  36,
  3,
  36,
  240,
  8,
  36,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  1,
  37,
  3,
  37,
  256,
  8,
  37,
  1,
  38,
  1,
  38,
  1,
  38,
  1,
  38,
  1,
  38,
  1,
  38,
  1,
  38,
  1,
  38,
  3,
  38,
  266,
  8,
  38,
  1,
  39,
  3,
  39,
  269,
  8,
  39,
  1,
  39,
  4,
  39,
  272,
  8,
  39,
  11,
  39,
  12,
  39,
  273,
  1,
  39,
  1,
  39,
  5,
  39,
  278,
  8,
  39,
  10,
  39,
  12,
  39,
  281,
  9,
  39,
  3,
  39,
  283,
  8,
  39,
  1,
  39,
  1,
  39,
  3,
  39,
  287,
  8,
  39,
  1,
  39,
  4,
  39,
  290,
  8,
  39,
  11,
  39,
  12,
  39,
  291,
  3,
  39,
  294,
  8,
  39,
  1,
  39,
  1,
  39,
  1,
  39,
  1,
  39,
  4,
  39,
  300,
  8,
  39,
  11,
  39,
  12,
  39,
  301,
  3,
  39,
  304,
  8,
  39,
  1,
  40,
  3,
  40,
  307,
  8,
  40,
  1,
  40,
  4,
  40,
  310,
  8,
  40,
  11,
  40,
  12,
  40,
  311,
  1,
  40,
  1,
  40,
  1,
  40,
  1,
  40,
  4,
  40,
  318,
  8,
  40,
  11,
  40,
  12,
  40,
  319,
  3,
  40,
  322,
  8,
  40,
  1,
  41,
  1,
  41,
  1,
  41,
  5,
  41,
  327,
  8,
  41,
  10,
  41,
  12,
  41,
  330,
  9,
  41,
  1,
  41,
  1,
  41,
  1,
  41,
  1,
  41,
  5,
  41,
  336,
  8,
  41,
  10,
  41,
  12,
  41,
  339,
  9,
  41,
  1,
  41,
  3,
  41,
  342,
  8,
  41,
  1,
  42,
  4,
  42,
  345,
  8,
  42,
  11,
  42,
  12,
  42,
  346,
  1,
  42,
  1,
  42,
  1,
  43,
  1,
  43,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  3,
  44,
  362,
  8,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  1,
  44,
  3,
  44,
  371,
  8,
  44,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  3,
  45,
  377,
  8,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  1,
  45,
  4,
  45,
  389,
  8,
  45,
  11,
  45,
  12,
  45,
  390,
  3,
  45,
  393,
  8,
  45,
  3,
  45,
  395,
  8,
  45,
  1,
  46,
  1,
  46,
  1,
  46,
  3,
  46,
  400,
  8,
  46,
  1,
  46,
  1,
  46,
  1,
  46,
  3,
  46,
  405,
  8,
  46,
  1,
  46,
  1,
  46,
  1,
  46,
  3,
  46,
  410,
  8,
  46,
  3,
  46,
  412,
  8,
  46,
  1,
  47,
  1,
  47,
  1,
  47,
  3,
  47,
  417,
  8,
  47,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  48,
  1,
  49,
  1,
  49,
  0,
  0,
  50,
  1,
  1,
  3,
  2,
  5,
  3,
  7,
  4,
  9,
  5,
  11,
  6,
  13,
  7,
  15,
  8,
  17,
  9,
  19,
  10,
  21,
  11,
  23,
  12,
  25,
  13,
  27,
  14,
  29,
  15,
  31,
  16,
  33,
  17,
  35,
  18,
  37,
  19,
  39,
  20,
  41,
  21,
  43,
  22,
  45,
  23,
  47,
  24,
  49,
  25,
  51,
  26,
  53,
  27,
  55,
  28,
  57,
  29,
  59,
  30,
  61,
  31,
  63,
  32,
  65,
  33,
  67,
  34,
  69,
  35,
  71,
  36,
  73,
  37,
  75,
  38,
  77,
  39,
  79,
  40,
  81,
  41,
  83,
  42,
  85,
  43,
  87,
  0,
  89,
  0,
  91,
  0,
  93,
  0,
  95,
  0,
  97,
  0,
  99,
  0,
  1,
  0,
  16,
  4,
  0,
  36,
  36,
  65,
  90,
  95,
  95,
  97,
  122,
  5,
  0,
  36,
  36,
  48,
  57,
  65,
  90,
  95,
  95,
  97,
  122,
  2,
  0,
  43,
  43,
  45,
  45,
  1,
  0,
  39,
  39,
  1,
  0,
  34,
  34,
  3,
  0,
  9,
  10,
  13,
  13,
  32,
  32,
  1,
  0,
  48,
  57,
  1,
  0,
  48,
  48,
  1,
  0,
  49,
  57,
  1,
  0,
  49,
  49,
  1,
  0,
  48,
  50,
  1,
  0,
  49,
  51,
  1,
  0,
  48,
  49,
  1,
  0,
  48,
  51,
  1,
  0,
  48,
  53,
  3,
  0,
  48,
  57,
  65,
  70,
  97,
  102,
  453,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  3,
  1,
  0,
  0,
  0,
  0,
  5,
  1,
  0,
  0,
  0,
  0,
  7,
  1,
  0,
  0,
  0,
  0,
  9,
  1,
  0,
  0,
  0,
  0,
  11,
  1,
  0,
  0,
  0,
  0,
  13,
  1,
  0,
  0,
  0,
  0,
  15,
  1,
  0,
  0,
  0,
  0,
  17,
  1,
  0,
  0,
  0,
  0,
  19,
  1,
  0,
  0,
  0,
  0,
  21,
  1,
  0,
  0,
  0,
  0,
  23,
  1,
  0,
  0,
  0,
  0,
  25,
  1,
  0,
  0,
  0,
  0,
  27,
  1,
  0,
  0,
  0,
  0,
  29,
  1,
  0,
  0,
  0,
  0,
  31,
  1,
  0,
  0,
  0,
  0,
  33,
  1,
  0,
  0,
  0,
  0,
  35,
  1,
  0,
  0,
  0,
  0,
  37,
  1,
  0,
  0,
  0,
  0,
  39,
  1,
  0,
  0,
  0,
  0,
  41,
  1,
  0,
  0,
  0,
  0,
  43,
  1,
  0,
  0,
  0,
  0,
  45,
  1,
  0,
  0,
  0,
  0,
  47,
  1,
  0,
  0,
  0,
  0,
  49,
  1,
  0,
  0,
  0,
  0,
  51,
  1,
  0,
  0,
  0,
  0,
  53,
  1,
  0,
  0,
  0,
  0,
  55,
  1,
  0,
  0,
  0,
  0,
  57,
  1,
  0,
  0,
  0,
  0,
  59,
  1,
  0,
  0,
  0,
  0,
  61,
  1,
  0,
  0,
  0,
  0,
  63,
  1,
  0,
  0,
  0,
  0,
  65,
  1,
  0,
  0,
  0,
  0,
  67,
  1,
  0,
  0,
  0,
  0,
  69,
  1,
  0,
  0,
  0,
  0,
  71,
  1,
  0,
  0,
  0,
  0,
  73,
  1,
  0,
  0,
  0,
  0,
  75,
  1,
  0,
  0,
  0,
  0,
  77,
  1,
  0,
  0,
  0,
  0,
  79,
  1,
  0,
  0,
  0,
  0,
  81,
  1,
  0,
  0,
  0,
  0,
  83,
  1,
  0,
  0,
  0,
  0,
  85,
  1,
  0,
  0,
  0,
  1,
  101,
  1,
  0,
  0,
  0,
  3,
  103,
  1,
  0,
  0,
  0,
  5,
  105,
  1,
  0,
  0,
  0,
  7,
  109,
  1,
  0,
  0,
  0,
  9,
  111,
  1,
  0,
  0,
  0,
  11,
  113,
  1,
  0,
  0,
  0,
  13,
  115,
  1,
  0,
  0,
  0,
  15,
  117,
  1,
  0,
  0,
  0,
  17,
  119,
  1,
  0,
  0,
  0,
  19,
  121,
  1,
  0,
  0,
  0,
  21,
  126,
  1,
  0,
  0,
  0,
  23,
  132,
  1,
  0,
  0,
  0,
  25,
  137,
  1,
  0,
  0,
  0,
  27,
  146,
  1,
  0,
  0,
  0,
  29,
  155,
  1,
  0,
  0,
  0,
  31,
  157,
  1,
  0,
  0,
  0,
  33,
  159,
  1,
  0,
  0,
  0,
  35,
  161,
  1,
  0,
  0,
  0,
  37,
  163,
  1,
  0,
  0,
  0,
  39,
  166,
  1,
  0,
  0,
  0,
  41,
  168,
  1,
  0,
  0,
  0,
  43,
  170,
  1,
  0,
  0,
  0,
  45,
  173,
  1,
  0,
  0,
  0,
  47,
  175,
  1,
  0,
  0,
  0,
  49,
  178,
  1,
  0,
  0,
  0,
  51,
  181,
  1,
  0,
  0,
  0,
  53,
  185,
  1,
  0,
  0,
  0,
  55,
  190,
  1,
  0,
  0,
  0,
  57,
  196,
  1,
  0,
  0,
  0,
  59,
  202,
  1,
  0,
  0,
  0,
  61,
  209,
  1,
  0,
  0,
  0,
  63,
  213,
  1,
  0,
  0,
  0,
  65,
  216,
  1,
  0,
  0,
  0,
  67,
  219,
  1,
  0,
  0,
  0,
  69,
  222,
  1,
  0,
  0,
  0,
  71,
  229,
  1,
  0,
  0,
  0,
  73,
  239,
  1,
  0,
  0,
  0,
  75,
  255,
  1,
  0,
  0,
  0,
  77,
  265,
  1,
  0,
  0,
  0,
  79,
  303,
  1,
  0,
  0,
  0,
  81,
  321,
  1,
  0,
  0,
  0,
  83,
  341,
  1,
  0,
  0,
  0,
  85,
  344,
  1,
  0,
  0,
  0,
  87,
  350,
  1,
  0,
  0,
  0,
  89,
  352,
  1,
  0,
  0,
  0,
  91,
  376,
  1,
  0,
  0,
  0,
  93,
  411,
  1,
  0,
  0,
  0,
  95,
  413,
  1,
  0,
  0,
  0,
  97,
  418,
  1,
  0,
  0,
  0,
  99,
  424,
  1,
  0,
  0,
  0,
  101,
  102,
  5,
  40,
  0,
  0,
  102,
  2,
  1,
  0,
  0,
  0,
  103,
  104,
  5,
  41,
  0,
  0,
  104,
  4,
  1,
  0,
  0,
  0,
  105,
  106,
  5,
  110,
  0,
  0,
  106,
  107,
  5,
  111,
  0,
  0,
  107,
  108,
  5,
  116,
  0,
  0,
  108,
  6,
  1,
  0,
  0,
  0,
  109,
  110,
  5,
  33,
  0,
  0,
  110,
  8,
  1,
  0,
  0,
  0,
  111,
  112,
  5,
  46,
  0,
  0,
  112,
  10,
  1,
  0,
  0,
  0,
  113,
  114,
  5,
  64,
  0,
  0,
  114,
  12,
  1,
  0,
  0,
  0,
  115,
  116,
  5,
  91,
  0,
  0,
  116,
  14,
  1,
  0,
  0,
  0,
  117,
  118,
  5,
  44,
  0,
  0,
  118,
  16,
  1,
  0,
  0,
  0,
  119,
  120,
  5,
  93,
  0,
  0,
  120,
  18,
  1,
  0,
  0,
  0,
  121,
  122,
  5,
  116,
  0,
  0,
  122,
  123,
  5,
  114,
  0,
  0,
  123,
  124,
  5,
  117,
  0,
  0,
  124,
  125,
  5,
  101,
  0,
  0,
  125,
  20,
  1,
  0,
  0,
  0,
  126,
  127,
  5,
  102,
  0,
  0,
  127,
  128,
  5,
  97,
  0,
  0,
  128,
  129,
  5,
  108,
  0,
  0,
  129,
  130,
  5,
  115,
  0,
  0,
  130,
  131,
  5,
  101,
  0,
  0,
  131,
  22,
  1,
  0,
  0,
  0,
  132,
  133,
  5,
  110,
  0,
  0,
  133,
  134,
  5,
  117,
  0,
  0,
  134,
  135,
  5,
  108,
  0,
  0,
  135,
  136,
  5,
  108,
  0,
  0,
  136,
  24,
  1,
  0,
  0,
  0,
  137,
  138,
  5,
  73,
  0,
  0,
  138,
  139,
  5,
  110,
  0,
  0,
  139,
  140,
  5,
  102,
  0,
  0,
  140,
  141,
  5,
  105,
  0,
  0,
  141,
  142,
  5,
  110,
  0,
  0,
  142,
  143,
  5,
  105,
  0,
  0,
  143,
  144,
  5,
  116,
  0,
  0,
  144,
  145,
  5,
  121,
  0,
  0,
  145,
  26,
  1,
  0,
  0,
  0,
  146,
  147,
  5,
  105,
  0,
  0,
  147,
  148,
  5,
  110,
  0,
  0,
  148,
  149,
  5,
  102,
  0,
  0,
  149,
  150,
  5,
  105,
  0,
  0,
  150,
  151,
  5,
  110,
  0,
  0,
  151,
  152,
  5,
  105,
  0,
  0,
  152,
  153,
  5,
  116,
  0,
  0,
  153,
  154,
  5,
  121,
  0,
  0,
  154,
  28,
  1,
  0,
  0,
  0,
  155,
  156,
  5,
  43,
  0,
  0,
  156,
  30,
  1,
  0,
  0,
  0,
  157,
  158,
  5,
  45,
  0,
  0,
  158,
  32,
  1,
  0,
  0,
  0,
  159,
  160,
  5,
  42,
  0,
  0,
  160,
  34,
  1,
  0,
  0,
  0,
  161,
  162,
  5,
  47,
  0,
  0,
  162,
  36,
  1,
  0,
  0,
  0,
  163,
  164,
  5,
  60,
  0,
  0,
  164,
  165,
  5,
  61,
  0,
  0,
  165,
  38,
  1,
  0,
  0,
  0,
  166,
  167,
  5,
  60,
  0,
  0,
  167,
  40,
  1,
  0,
  0,
  0,
  168,
  169,
  5,
  62,
  0,
  0,
  169,
  42,
  1,
  0,
  0,
  0,
  170,
  171,
  5,
  62,
  0,
  0,
  171,
  172,
  5,
  61,
  0,
  0,
  172,
  44,
  1,
  0,
  0,
  0,
  173,
  174,
  5,
  61,
  0,
  0,
  174,
  46,
  1,
  0,
  0,
  0,
  175,
  176,
  5,
  33,
  0,
  0,
  176,
  177,
  5,
  61,
  0,
  0,
  177,
  48,
  1,
  0,
  0,
  0,
  178,
  179,
  5,
  105,
  0,
  0,
  179,
  180,
  5,
  110,
  0,
  0,
  180,
  50,
  1,
  0,
  0,
  0,
  181,
  182,
  5,
  33,
  0,
  0,
  182,
  183,
  5,
  105,
  0,
  0,
  183,
  184,
  5,
  110,
  0,
  0,
  184,
  52,
  1,
  0,
  0,
  0,
  185,
  186,
  5,
  108,
  0,
  0,
  186,
  187,
  5,
  105,
  0,
  0,
  187,
  188,
  5,
  107,
  0,
  0,
  188,
  189,
  5,
  101,
  0,
  0,
  189,
  54,
  1,
  0,
  0,
  0,
  190,
  191,
  5,
  33,
  0,
  0,
  191,
  192,
  5,
  108,
  0,
  0,
  192,
  193,
  5,
  105,
  0,
  0,
  193,
  194,
  5,
  107,
  0,
  0,
  194,
  195,
  5,
  101,
  0,
  0,
  195,
  56,
  1,
  0,
  0,
  0,
  196,
  197,
  5,
  105,
  0,
  0,
  197,
  198,
  5,
  108,
  0,
  0,
  198,
  199,
  5,
  105,
  0,
  0,
  199,
  200,
  5,
  107,
  0,
  0,
  200,
  201,
  5,
  101,
  0,
  0,
  201,
  58,
  1,
  0,
  0,
  0,
  202,
  203,
  5,
  33,
  0,
  0,
  203,
  204,
  5,
  105,
  0,
  0,
  204,
  205,
  5,
  108,
  0,
  0,
  205,
  206,
  5,
  105,
  0,
  0,
  206,
  207,
  5,
  107,
  0,
  0,
  207,
  208,
  5,
  101,
  0,
  0,
  208,
  60,
  1,
  0,
  0,
  0,
  209,
  210,
  5,
  97,
  0,
  0,
  210,
  211,
  5,
  110,
  0,
  0,
  211,
  212,
  5,
  100,
  0,
  0,
  212,
  62,
  1,
  0,
  0,
  0,
  213,
  214,
  5,
  111,
  0,
  0,
  214,
  215,
  5,
  114,
  0,
  0,
  215,
  64,
  1,
  0,
  0,
  0,
  216,
  217,
  5,
  38,
  0,
  0,
  217,
  218,
  5,
  38,
  0,
  0,
  218,
  66,
  1,
  0,
  0,
  0,
  219,
  220,
  5,
  124,
  0,
  0,
  220,
  221,
  5,
  124,
  0,
  0,
  221,
  68,
  1,
  0,
  0,
  0,
  222,
  226,
  7,
  0,
  0,
  0,
  223,
  225,
  7,
  1,
  0,
  0,
  224,
  223,
  1,
  0,
  0,
  0,
  225,
  228,
  1,
  0,
  0,
  0,
  226,
  224,
  1,
  0,
  0,
  0,
  226,
  227,
  1,
  0,
  0,
  0,
  227,
  70,
  1,
  0,
  0,
  0,
  228,
  226,
  1,
  0,
  0,
  0,
  229,
  230,
  7,
  2,
  0,
  0,
  230,
  72,
  1,
  0,
  0,
  0,
  231,
  232,
  5,
  39,
  0,
  0,
  232,
  233,
  3,
  89,
  44,
  0,
  233,
  234,
  5,
  39,
  0,
  0,
  234,
  240,
  1,
  0,
  0,
  0,
  235,
  236,
  5,
  34,
  0,
  0,
  236,
  237,
  3,
  89,
  44,
  0,
  237,
  238,
  5,
  34,
  0,
  0,
  238,
  240,
  1,
  0,
  0,
  0,
  239,
  231,
  1,
  0,
  0,
  0,
  239,
  235,
  1,
  0,
  0,
  0,
  240,
  74,
  1,
  0,
  0,
  0,
  241,
  242,
  5,
  39,
  0,
  0,
  242,
  243,
  3,
  89,
  44,
  0,
  243,
  244,
  5,
  84,
  0,
  0,
  244,
  245,
  3,
  91,
  45,
  0,
  245,
  246,
  3,
  93,
  46,
  0,
  246,
  247,
  5,
  39,
  0,
  0,
  247,
  256,
  1,
  0,
  0,
  0,
  248,
  249,
  5,
  34,
  0,
  0,
  249,
  250,
  3,
  89,
  44,
  0,
  250,
  251,
  5,
  84,
  0,
  0,
  251,
  252,
  3,
  91,
  45,
  0,
  252,
  253,
  3,
  93,
  46,
  0,
  253,
  254,
  5,
  34,
  0,
  0,
  254,
  256,
  1,
  0,
  0,
  0,
  255,
  241,
  1,
  0,
  0,
  0,
  255,
  248,
  1,
  0,
  0,
  0,
  256,
  76,
  1,
  0,
  0,
  0,
  257,
  258,
  5,
  39,
  0,
  0,
  258,
  259,
  3,
  91,
  45,
  0,
  259,
  260,
  5,
  39,
  0,
  0,
  260,
  266,
  1,
  0,
  0,
  0,
  261,
  262,
  5,
  34,
  0,
  0,
  262,
  263,
  3,
  91,
  45,
  0,
  263,
  264,
  5,
  34,
  0,
  0,
  264,
  266,
  1,
  0,
  0,
  0,
  265,
  257,
  1,
  0,
  0,
  0,
  265,
  261,
  1,
  0,
  0,
  0,
  266,
  78,
  1,
  0,
  0,
  0,
  267,
  269,
  3,
  71,
  35,
  0,
  268,
  267,
  1,
  0,
  0,
  0,
  268,
  269,
  1,
  0,
  0,
  0,
  269,
  271,
  1,
  0,
  0,
  0,
  270,
  272,
  3,
  87,
  43,
  0,
  271,
  270,
  1,
  0,
  0,
  0,
  272,
  273,
  1,
  0,
  0,
  0,
  273,
  271,
  1,
  0,
  0,
  0,
  273,
  274,
  1,
  0,
  0,
  0,
  274,
  282,
  1,
  0,
  0,
  0,
  275,
  279,
  5,
  46,
  0,
  0,
  276,
  278,
  3,
  87,
  43,
  0,
  277,
  276,
  1,
  0,
  0,
  0,
  278,
  281,
  1,
  0,
  0,
  0,
  279,
  277,
  1,
  0,
  0,
  0,
  279,
  280,
  1,
  0,
  0,
  0,
  280,
  283,
  1,
  0,
  0,
  0,
  281,
  279,
  1,
  0,
  0,
  0,
  282,
  275,
  1,
  0,
  0,
  0,
  282,
  283,
  1,
  0,
  0,
  0,
  283,
  293,
  1,
  0,
  0,
  0,
  284,
  286,
  5,
  69,
  0,
  0,
  285,
  287,
  7,
  2,
  0,
  0,
  286,
  285,
  1,
  0,
  0,
  0,
  286,
  287,
  1,
  0,
  0,
  0,
  287,
  289,
  1,
  0,
  0,
  0,
  288,
  290,
  3,
  87,
  43,
  0,
  289,
  288,
  1,
  0,
  0,
  0,
  290,
  291,
  1,
  0,
  0,
  0,
  291,
  289,
  1,
  0,
  0,
  0,
  291,
  292,
  1,
  0,
  0,
  0,
  292,
  294,
  1,
  0,
  0,
  0,
  293,
  284,
  1,
  0,
  0,
  0,
  293,
  294,
  1,
  0,
  0,
  0,
  294,
  304,
  1,
  0,
  0,
  0,
  295,
  296,
  5,
  48,
  0,
  0,
  296,
  297,
  5,
  120,
  0,
  0,
  297,
  299,
  1,
  0,
  0,
  0,
  298,
  300,
  3,
  99,
  49,
  0,
  299,
  298,
  1,
  0,
  0,
  0,
  300,
  301,
  1,
  0,
  0,
  0,
  301,
  299,
  1,
  0,
  0,
  0,
  301,
  302,
  1,
  0,
  0,
  0,
  302,
  304,
  1,
  0,
  0,
  0,
  303,
  268,
  1,
  0,
  0,
  0,
  303,
  295,
  1,
  0,
  0,
  0,
  304,
  80,
  1,
  0,
  0,
  0,
  305,
  307,
  3,
  71,
  35,
  0,
  306,
  305,
  1,
  0,
  0,
  0,
  306,
  307,
  1,
  0,
  0,
  0,
  307,
  309,
  1,
  0,
  0,
  0,
  308,
  310,
  3,
  87,
  43,
  0,
  309,
  308,
  1,
  0,
  0,
  0,
  310,
  311,
  1,
  0,
  0,
  0,
  311,
  309,
  1,
  0,
  0,
  0,
  311,
  312,
  1,
  0,
  0,
  0,
  312,
  322,
  1,
  0,
  0,
  0,
  313,
  314,
  5,
  48,
  0,
  0,
  314,
  315,
  5,
  120,
  0,
  0,
  315,
  317,
  1,
  0,
  0,
  0,
  316,
  318,
  3,
  99,
  49,
  0,
  317,
  316,
  1,
  0,
  0,
  0,
  318,
  319,
  1,
  0,
  0,
  0,
  319,
  317,
  1,
  0,
  0,
  0,
  319,
  320,
  1,
  0,
  0,
  0,
  320,
  322,
  1,
  0,
  0,
  0,
  321,
  306,
  1,
  0,
  0,
  0,
  321,
  313,
  1,
  0,
  0,
  0,
  322,
  82,
  1,
  0,
  0,
  0,
  323,
  328,
  5,
  39,
  0,
  0,
  324,
  327,
  3,
  95,
  47,
  0,
  325,
  327,
  8,
  3,
  0,
  0,
  326,
  324,
  1,
  0,
  0,
  0,
  326,
  325,
  1,
  0,
  0,
  0,
  327,
  330,
  1,
  0,
  0,
  0,
  328,
  326,
  1,
  0,
  0,
  0,
  328,
  329,
  1,
  0,
  0,
  0,
  329,
  331,
  1,
  0,
  0,
  0,
  330,
  328,
  1,
  0,
  0,
  0,
  331,
  342,
  5,
  39,
  0,
  0,
  332,
  337,
  5,
  34,
  0,
  0,
  333,
  336,
  3,
  95,
  47,
  0,
  334,
  336,
  8,
  4,
  0,
  0,
  335,
  333,
  1,
  0,
  0,
  0,
  335,
  334,
  1,
  0,
  0,
  0,
  336,
  339,
  1,
  0,
  0,
  0,
  337,
  335,
  1,
  0,
  0,
  0,
  337,
  338,
  1,
  0,
  0,
  0,
  338,
  340,
  1,
  0,
  0,
  0,
  339,
  337,
  1,
  0,
  0,
  0,
  340,
  342,
  5,
  34,
  0,
  0,
  341,
  323,
  1,
  0,
  0,
  0,
  341,
  332,
  1,
  0,
  0,
  0,
  342,
  84,
  1,
  0,
  0,
  0,
  343,
  345,
  7,
  5,
  0,
  0,
  344,
  343,
  1,
  0,
  0,
  0,
  345,
  346,
  1,
  0,
  0,
  0,
  346,
  344,
  1,
  0,
  0,
  0,
  346,
  347,
  1,
  0,
  0,
  0,
  347,
  348,
  1,
  0,
  0,
  0,
  348,
  349,
  6,
  42,
  0,
  0,
  349,
  86,
  1,
  0,
  0,
  0,
  350,
  351,
  7,
  6,
  0,
  0,
  351,
  88,
  1,
  0,
  0,
  0,
  352,
  353,
  7,
  6,
  0,
  0,
  353,
  354,
  7,
  6,
  0,
  0,
  354,
  355,
  7,
  6,
  0,
  0,
  355,
  356,
  7,
  6,
  0,
  0,
  356,
  361,
  5,
  45,
  0,
  0,
  357,
  358,
  7,
  7,
  0,
  0,
  358,
  362,
  7,
  8,
  0,
  0,
  359,
  360,
  7,
  9,
  0,
  0,
  360,
  362,
  7,
  10,
  0,
  0,
  361,
  357,
  1,
  0,
  0,
  0,
  361,
  359,
  1,
  0,
  0,
  0,
  362,
  363,
  1,
  0,
  0,
  0,
  363,
  370,
  5,
  45,
  0,
  0,
  364,
  365,
  7,
  11,
  0,
  0,
  365,
  371,
  7,
  7,
  0,
  0,
  366,
  367,
  7,
  10,
  0,
  0,
  367,
  371,
  7,
  8,
  0,
  0,
  368,
  369,
  5,
  51,
  0,
  0,
  369,
  371,
  5,
  49,
  0,
  0,
  370,
  364,
  1,
  0,
  0,
  0,
  370,
  366,
  1,
  0,
  0,
  0,
  370,
  368,
  1,
  0,
  0,
  0,
  371,
  90,
  1,
  0,
  0,
  0,
  372,
  373,
  7,
  12,
  0,
  0,
  373,
  377,
  7,
  6,
  0,
  0,
  374,
  375,
  5,
  50,
  0,
  0,
  375,
  377,
  7,
  13,
  0,
  0,
  376,
  372,
  1,
  0,
  0,
  0,
  376,
  374,
  1,
  0,
  0,
  0,
  377,
  378,
  1,
  0,
  0,
  0,
  378,
  379,
  5,
  58,
  0,
  0,
  379,
  380,
  7,
  14,
  0,
  0,
  380,
  381,
  7,
  6,
  0,
  0,
  381,
  394,
  1,
  0,
  0,
  0,
  382,
  383,
  5,
  58,
  0,
  0,
  383,
  384,
  7,
  14,
  0,
  0,
  384,
  385,
  7,
  6,
  0,
  0,
  385,
  392,
  1,
  0,
  0,
  0,
  386,
  388,
  5,
  46,
  0,
  0,
  387,
  389,
  7,
  6,
  0,
  0,
  388,
  387,
  1,
  0,
  0,
  0,
  389,
  390,
  1,
  0,
  0,
  0,
  390,
  388,
  1,
  0,
  0,
  0,
  390,
  391,
  1,
  0,
  0,
  0,
  391,
  393,
  1,
  0,
  0,
  0,
  392,
  386,
  1,
  0,
  0,
  0,
  392,
  393,
  1,
  0,
  0,
  0,
  393,
  395,
  1,
  0,
  0,
  0,
  394,
  382,
  1,
  0,
  0,
  0,
  394,
  395,
  1,
  0,
  0,
  0,
  395,
  92,
  1,
  0,
  0,
  0,
  396,
  412,
  5,
  90,
  0,
  0,
  397,
  404,
  7,
  2,
  0,
  0,
  398,
  400,
  7,
  12,
  0,
  0,
  399,
  398,
  1,
  0,
  0,
  0,
  399,
  400,
  1,
  0,
  0,
  0,
  400,
  401,
  1,
  0,
  0,
  0,
  401,
  405,
  7,
  6,
  0,
  0,
  402,
  403,
  5,
  50,
  0,
  0,
  403,
  405,
  7,
  13,
  0,
  0,
  404,
  399,
  1,
  0,
  0,
  0,
  404,
  402,
  1,
  0,
  0,
  0,
  405,
  409,
  1,
  0,
  0,
  0,
  406,
  407,
  5,
  58,
  0,
  0,
  407,
  408,
  7,
  14,
  0,
  0,
  408,
  410,
  7,
  6,
  0,
  0,
  409,
  406,
  1,
  0,
  0,
  0,
  409,
  410,
  1,
  0,
  0,
  0,
  410,
  412,
  1,
  0,
  0,
  0,
  411,
  396,
  1,
  0,
  0,
  0,
  411,
  397,
  1,
  0,
  0,
  0,
  412,
  94,
  1,
  0,
  0,
  0,
  413,
  416,
  5,
  92,
  0,
  0,
  414,
  417,
  3,
  97,
  48,
  0,
  415,
  417,
  9,
  0,
  0,
  0,
  416,
  414,
  1,
  0,
  0,
  0,
  416,
  415,
  1,
  0,
  0,
  0,
  417,
  96,
  1,
  0,
  0,
  0,
  418,
  419,
  5,
  117,
  0,
  0,
  419,
  420,
  3,
  99,
  49,
  0,
  420,
  421,
  3,
  99,
  49,
  0,
  421,
  422,
  3,
  99,
  49,
  0,
  422,
  423,
  3,
  99,
  49,
  0,
  423,
  98,
  1,
  0,
  0,
  0,
  424,
  425,
  7,
  15,
  0,
  0,
  425,
  100,
  1,
  0,
  0,
  0,
  35,
  0,
  226,
  239,
  255,
  265,
  268,
  273,
  279,
  282,
  286,
  291,
  293,
  301,
  303,
  306,
  311,
  319,
  321,
  326,
  328,
  335,
  337,
  341,
  346,
  361,
  370,
  376,
  390,
  392,
  394,
  399,
  404,
  409,
  411,
  416,
  1,
  0,
  1,
  0
];
OpraFilterLexer.DecisionsToDFA = OpraFilterLexer._ATN.decisionToState.map((ds, index) => new DFA(ds, index));
var OpraFilterLexer_default = OpraFilterLexer;

// ../../build/common/esm/filter/antlr/OpraFilterParser.js
import { ATN, ATNDeserializer as ATNDeserializer2, DFA as DFA2, FailedPredicateException, NoViableAltException, Parser, ParserATNSimulator, ParserRuleContext, PredictionContextCache as PredictionContextCache2, RecognitionException, Token as Token2 } from "@browsery/antlr4";
var OpraFilterParser = class _OpraFilterParser extends Parser {
  static {
    __name(this, "OpraFilterParser");
  }
  get grammarFileName() {
    return "OpraFilter.g4";
  }
  get literalNames() {
    return _OpraFilterParser.literalNames;
  }
  get symbolicNames() {
    return _OpraFilterParser.symbolicNames;
  }
  get ruleNames() {
    return _OpraFilterParser.ruleNames;
  }
  get serializedATN() {
    return _OpraFilterParser._serializedATN;
  }
  createFailedPredicateException(predicate, message) {
    return new FailedPredicateException(this, predicate, message);
  }
  constructor(input) {
    super(input);
    this._interp = new ParserATNSimulator(this, _OpraFilterParser._ATN, _OpraFilterParser.DecisionsToDFA, new PredictionContextCache2());
  }
  // @RuleVersion(0)
  root() {
    const localctx = new RootContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, _OpraFilterParser.RULE_root);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 34;
        this.expression(0);
        this.state = 35;
        this.match(_OpraFilterParser.EOF);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  expression(_p) {
    if (_p === void 0) {
      _p = 0;
    }
    const _parentctx = this._ctx;
    const _parentState = this.state;
    let localctx = new ExpressionContext(this, this._ctx, _parentState);
    let _prevctx = localctx;
    const _startState = 2;
    this.enterRecursionRule(localctx, 2, _OpraFilterParser.RULE_expression, _p);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 48;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 35:
            {
              localctx = new ComparisonExpressionContext(this, localctx);
              this._ctx = localctx;
              _prevctx = localctx;
              this.state = 38;
              localctx._left = this.comparisonLeft();
              this.state = 39;
              localctx._operator = this.comparisonOperator();
              this.state = 40;
              localctx._right = this.comparisonRight();
            }
            break;
          case 1:
            {
              localctx = new ParenthesizedExpressionContext(this, localctx);
              this._ctx = localctx;
              _prevctx = localctx;
              this.state = 42;
              this.match(_OpraFilterParser.T__0);
              this.state = 43;
              this.parenthesizedItem();
              this.state = 44;
              this.match(_OpraFilterParser.T__1);
            }
            break;
          case 3:
          case 4:
            {
              localctx = new NegativeExpressionContext(this, localctx);
              this._ctx = localctx;
              _prevctx = localctx;
              this.state = 46;
              _la = this._input.LA(1);
              if (!(_la === 3 || _la === 4)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 47;
              this.expression(1);
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 56;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 1, this._ctx);
        while (_alt !== 2 && _alt !== ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            if (this._parseListeners != null) {
              this.triggerExitRuleEvent();
            }
            _prevctx = localctx;
            {
              {
                localctx = new LogicalExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
                this.pushNewRecursionContext(localctx, _startState, _OpraFilterParser.RULE_expression);
                this.state = 50;
                if (!this.precpred(this._ctx, 3)) {
                  throw this.createFailedPredicateException("this.precpred(this._ctx, 3)");
                }
                this.state = 51;
                localctx._op = this.logicalOperator();
                this.state = 52;
                this.expression(4);
              }
            }
          }
          this.state = 58;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 1, this._ctx);
        }
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.unrollRecursionContexts(_parentctx);
    }
    return localctx;
  }
  // @RuleVersion(0)
  comparisonLeft() {
    const localctx = new ComparisonLeftContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, _OpraFilterParser.RULE_comparisonLeft);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 59;
        this.qualifiedIdentifier();
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  comparisonRight() {
    const localctx = new ComparisonRightContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, _OpraFilterParser.RULE_comparisonRight);
    try {
      this.state = 65;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 37:
        case 38:
        case 39:
        case 40:
        case 42:
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 61;
            this.value();
          }
          break;
        case 35:
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 62;
            this.qualifiedIdentifier();
          }
          break;
        case 6:
          this.enterOuterAlt(localctx, 3);
          {
            this.state = 63;
            this.externalConstant();
          }
          break;
        case 7:
          this.enterOuterAlt(localctx, 4);
          {
            this.state = 64;
            this.arrayValue();
          }
          break;
        default:
          throw new NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  parenthesizedItem() {
    const localctx = new ParenthesizedItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, _OpraFilterParser.RULE_parenthesizedItem);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 67;
        this.expression(0);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  value() {
    let localctx = new ValueContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, _OpraFilterParser.RULE_value);
    try {
      this.state = 77;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case 40:
          localctx = new NumberLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          {
            this.state = 69;
            this.match(_OpraFilterParser.NUMBER);
          }
          break;
        case 13:
        case 14:
          localctx = new InfinityLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          {
            this.state = 70;
            this.infinity();
          }
          break;
        case 10:
        case 11:
          localctx = new BooleanLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          {
            this.state = 71;
            this.boolean_();
          }
          break;
        case 12:
          localctx = new NullLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          {
            this.state = 72;
            this.null_();
          }
          break;
        case 37:
          localctx = new DateLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 5);
          {
            this.state = 73;
            this.match(_OpraFilterParser.DATE);
          }
          break;
        case 38:
          localctx = new DateTimeLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 6);
          {
            this.state = 74;
            this.match(_OpraFilterParser.DATETIME);
          }
          break;
        case 39:
          localctx = new TimeLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 7);
          {
            this.state = 75;
            this.match(_OpraFilterParser.TIME);
          }
          break;
        case 42:
          localctx = new StringLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 8);
          {
            this.state = 76;
            this.match(_OpraFilterParser.STRING);
          }
          break;
        default:
          throw new NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  qualifiedIdentifier() {
    const localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, _OpraFilterParser.RULE_qualifiedIdentifier);
    try {
      let _alt;
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 84;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 4, this._ctx);
        while (_alt !== 2 && _alt !== ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            {
              {
                this.state = 79;
                this.identifier();
                this.state = 80;
                this.match(_OpraFilterParser.T__4);
              }
            }
          }
          this.state = 86;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 4, this._ctx);
        }
        this.state = 87;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  externalConstant() {
    const localctx = new ExternalConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, _OpraFilterParser.RULE_externalConstant);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 89;
        this.match(_OpraFilterParser.T__5);
        this.state = 90;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  identifier() {
    const localctx = new IdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, _OpraFilterParser.RULE_identifier);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 92;
        this.match(_OpraFilterParser.IDENTIFIER);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  arrayValue() {
    const localctx = new ArrayValueContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, _OpraFilterParser.RULE_arrayValue);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 94;
        this.match(_OpraFilterParser.T__6);
        this.state = 95;
        this.value();
        this.state = 100;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 8) {
          {
            {
              this.state = 96;
              this.match(_OpraFilterParser.T__7);
              this.state = 97;
              this.value();
            }
          }
          this.state = 102;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 103;
        this.match(_OpraFilterParser.T__8);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  boolean_() {
    const localctx = new BooleanContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, _OpraFilterParser.RULE_boolean);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 105;
        _la = this._input.LA(1);
        if (!(_la === 10 || _la === 11)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  null_() {
    const localctx = new NullContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, _OpraFilterParser.RULE_null);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 107;
        this.match(_OpraFilterParser.T__11);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  infinity() {
    const localctx = new InfinityContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, _OpraFilterParser.RULE_infinity);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 109;
        _la = this._input.LA(1);
        if (!(_la === 13 || _la === 14)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  arithmeticOperator() {
    const localctx = new ArithmeticOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, _OpraFilterParser.RULE_arithmeticOperator);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 111;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & 491520) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  comparisonOperator() {
    const localctx = new ComparisonOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, _OpraFilterParser.RULE_comparisonOperator);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 113;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & 2146959360) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  logicalOperator() {
    const localctx = new LogicalOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, _OpraFilterParser.RULE_logicalOperator);
    let _la;
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 115;
        _la = this._input.LA(1);
        if (!((_la - 31 & ~31) === 0 && (1 << _la - 31 & 15) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  // @RuleVersion(0)
  polarityOperator() {
    const localctx = new PolarityOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, _OpraFilterParser.RULE_polarityOperator);
    try {
      this.enterOuterAlt(localctx, 1);
      {
        this.state = 117;
        this.match(_OpraFilterParser.POLAR_OP);
      }
    } catch (re) {
      if (re instanceof RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  sempred(localctx, ruleIndex, predIndex) {
    switch (ruleIndex) {
      case 1:
        return this.expression_sempred(localctx, predIndex);
    }
    return true;
  }
  expression_sempred(localctx, predIndex) {
    switch (predIndex) {
      case 0:
        return this.precpred(this._ctx, 3);
    }
    return true;
  }
  static get _ATN() {
    if (!_OpraFilterParser.__ATN) {
      _OpraFilterParser.__ATN = new ATNDeserializer2().deserialize(_OpraFilterParser._serializedATN);
    }
    return _OpraFilterParser.__ATN;
  }
};
OpraFilterParser.T__0 = 1;
OpraFilterParser.T__1 = 2;
OpraFilterParser.T__2 = 3;
OpraFilterParser.T__3 = 4;
OpraFilterParser.T__4 = 5;
OpraFilterParser.T__5 = 6;
OpraFilterParser.T__6 = 7;
OpraFilterParser.T__7 = 8;
OpraFilterParser.T__8 = 9;
OpraFilterParser.T__9 = 10;
OpraFilterParser.T__10 = 11;
OpraFilterParser.T__11 = 12;
OpraFilterParser.T__12 = 13;
OpraFilterParser.T__13 = 14;
OpraFilterParser.T__14 = 15;
OpraFilterParser.T__15 = 16;
OpraFilterParser.T__16 = 17;
OpraFilterParser.T__17 = 18;
OpraFilterParser.T__18 = 19;
OpraFilterParser.T__19 = 20;
OpraFilterParser.T__20 = 21;
OpraFilterParser.T__21 = 22;
OpraFilterParser.T__22 = 23;
OpraFilterParser.T__23 = 24;
OpraFilterParser.T__24 = 25;
OpraFilterParser.T__25 = 26;
OpraFilterParser.T__26 = 27;
OpraFilterParser.T__27 = 28;
OpraFilterParser.T__28 = 29;
OpraFilterParser.T__29 = 30;
OpraFilterParser.T__30 = 31;
OpraFilterParser.T__31 = 32;
OpraFilterParser.T__32 = 33;
OpraFilterParser.T__33 = 34;
OpraFilterParser.IDENTIFIER = 35;
OpraFilterParser.POLAR_OP = 36;
OpraFilterParser.DATE = 37;
OpraFilterParser.DATETIME = 38;
OpraFilterParser.TIME = 39;
OpraFilterParser.NUMBER = 40;
OpraFilterParser.INTEGER = 41;
OpraFilterParser.STRING = 42;
OpraFilterParser.WHITESPACE = 43;
OpraFilterParser.EOF = Token2.EOF;
OpraFilterParser.RULE_root = 0;
OpraFilterParser.RULE_expression = 1;
OpraFilterParser.RULE_comparisonLeft = 2;
OpraFilterParser.RULE_comparisonRight = 3;
OpraFilterParser.RULE_parenthesizedItem = 4;
OpraFilterParser.RULE_value = 5;
OpraFilterParser.RULE_qualifiedIdentifier = 6;
OpraFilterParser.RULE_externalConstant = 7;
OpraFilterParser.RULE_identifier = 8;
OpraFilterParser.RULE_arrayValue = 9;
OpraFilterParser.RULE_boolean = 10;
OpraFilterParser.RULE_null = 11;
OpraFilterParser.RULE_infinity = 12;
OpraFilterParser.RULE_arithmeticOperator = 13;
OpraFilterParser.RULE_comparisonOperator = 14;
OpraFilterParser.RULE_logicalOperator = 15;
OpraFilterParser.RULE_polarityOperator = 16;
OpraFilterParser.literalNames = [
  null,
  "'('",
  "')'",
  "'not'",
  "'!'",
  "'.'",
  "'@'",
  "'['",
  "','",
  "']'",
  "'true'",
  "'false'",
  "'null'",
  "'Infinity'",
  "'infinity'",
  "'+'",
  "'-'",
  "'*'",
  "'/'",
  "'<='",
  "'<'",
  "'>'",
  "'>='",
  "'='",
  "'!='",
  "'in'",
  "'!in'",
  "'like'",
  "'!like'",
  "'ilike'",
  "'!ilike'",
  "'and'",
  "'or'",
  "'&&'",
  "'||'"
];
OpraFilterParser.symbolicNames = [
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "IDENTIFIER",
  "POLAR_OP",
  "DATE",
  "DATETIME",
  "TIME",
  "NUMBER",
  "INTEGER",
  "STRING",
  "WHITESPACE"
];
OpraFilterParser.ruleNames = [
  "root",
  "expression",
  "comparisonLeft",
  "comparisonRight",
  "parenthesizedItem",
  "value",
  "qualifiedIdentifier",
  "externalConstant",
  "identifier",
  "arrayValue",
  "boolean",
  "null",
  "infinity",
  "arithmeticOperator",
  "comparisonOperator",
  "logicalOperator",
  "polarityOperator"
];
OpraFilterParser._serializedATN = [
  4,
  1,
  43,
  120,
  2,
  0,
  7,
  0,
  2,
  1,
  7,
  1,
  2,
  2,
  7,
  2,
  2,
  3,
  7,
  3,
  2,
  4,
  7,
  4,
  2,
  5,
  7,
  5,
  2,
  6,
  7,
  6,
  2,
  7,
  7,
  7,
  2,
  8,
  7,
  8,
  2,
  9,
  7,
  9,
  2,
  10,
  7,
  10,
  2,
  11,
  7,
  11,
  2,
  12,
  7,
  12,
  2,
  13,
  7,
  13,
  2,
  14,
  7,
  14,
  2,
  15,
  7,
  15,
  2,
  16,
  7,
  16,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  1,
  49,
  8,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  5,
  1,
  55,
  8,
  1,
  10,
  1,
  12,
  1,
  58,
  9,
  1,
  1,
  2,
  1,
  2,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  3,
  3,
  3,
  66,
  8,
  3,
  1,
  4,
  1,
  4,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  5,
  1,
  5,
  3,
  5,
  78,
  8,
  5,
  1,
  6,
  1,
  6,
  1,
  6,
  5,
  6,
  83,
  8,
  6,
  10,
  6,
  12,
  6,
  86,
  9,
  6,
  1,
  6,
  1,
  6,
  1,
  7,
  1,
  7,
  1,
  7,
  1,
  8,
  1,
  8,
  1,
  9,
  1,
  9,
  1,
  9,
  1,
  9,
  5,
  9,
  99,
  8,
  9,
  10,
  9,
  12,
  9,
  102,
  9,
  9,
  1,
  9,
  1,
  9,
  1,
  10,
  1,
  10,
  1,
  11,
  1,
  11,
  1,
  12,
  1,
  12,
  1,
  13,
  1,
  13,
  1,
  14,
  1,
  14,
  1,
  15,
  1,
  15,
  1,
  16,
  1,
  16,
  1,
  16,
  0,
  1,
  2,
  17,
  0,
  2,
  4,
  6,
  8,
  10,
  12,
  14,
  16,
  18,
  20,
  22,
  24,
  26,
  28,
  30,
  32,
  0,
  6,
  1,
  0,
  3,
  4,
  1,
  0,
  10,
  11,
  1,
  0,
  13,
  14,
  1,
  0,
  15,
  18,
  1,
  0,
  19,
  30,
  1,
  0,
  31,
  34,
  117,
  0,
  34,
  1,
  0,
  0,
  0,
  2,
  48,
  1,
  0,
  0,
  0,
  4,
  59,
  1,
  0,
  0,
  0,
  6,
  65,
  1,
  0,
  0,
  0,
  8,
  67,
  1,
  0,
  0,
  0,
  10,
  77,
  1,
  0,
  0,
  0,
  12,
  84,
  1,
  0,
  0,
  0,
  14,
  89,
  1,
  0,
  0,
  0,
  16,
  92,
  1,
  0,
  0,
  0,
  18,
  94,
  1,
  0,
  0,
  0,
  20,
  105,
  1,
  0,
  0,
  0,
  22,
  107,
  1,
  0,
  0,
  0,
  24,
  109,
  1,
  0,
  0,
  0,
  26,
  111,
  1,
  0,
  0,
  0,
  28,
  113,
  1,
  0,
  0,
  0,
  30,
  115,
  1,
  0,
  0,
  0,
  32,
  117,
  1,
  0,
  0,
  0,
  34,
  35,
  3,
  2,
  1,
  0,
  35,
  36,
  5,
  0,
  0,
  1,
  36,
  1,
  1,
  0,
  0,
  0,
  37,
  38,
  6,
  1,
  -1,
  0,
  38,
  39,
  3,
  4,
  2,
  0,
  39,
  40,
  3,
  28,
  14,
  0,
  40,
  41,
  3,
  6,
  3,
  0,
  41,
  49,
  1,
  0,
  0,
  0,
  42,
  43,
  5,
  1,
  0,
  0,
  43,
  44,
  3,
  8,
  4,
  0,
  44,
  45,
  5,
  2,
  0,
  0,
  45,
  49,
  1,
  0,
  0,
  0,
  46,
  47,
  7,
  0,
  0,
  0,
  47,
  49,
  3,
  2,
  1,
  1,
  48,
  37,
  1,
  0,
  0,
  0,
  48,
  42,
  1,
  0,
  0,
  0,
  48,
  46,
  1,
  0,
  0,
  0,
  49,
  56,
  1,
  0,
  0,
  0,
  50,
  51,
  10,
  3,
  0,
  0,
  51,
  52,
  3,
  30,
  15,
  0,
  52,
  53,
  3,
  2,
  1,
  4,
  53,
  55,
  1,
  0,
  0,
  0,
  54,
  50,
  1,
  0,
  0,
  0,
  55,
  58,
  1,
  0,
  0,
  0,
  56,
  54,
  1,
  0,
  0,
  0,
  56,
  57,
  1,
  0,
  0,
  0,
  57,
  3,
  1,
  0,
  0,
  0,
  58,
  56,
  1,
  0,
  0,
  0,
  59,
  60,
  3,
  12,
  6,
  0,
  60,
  5,
  1,
  0,
  0,
  0,
  61,
  66,
  3,
  10,
  5,
  0,
  62,
  66,
  3,
  12,
  6,
  0,
  63,
  66,
  3,
  14,
  7,
  0,
  64,
  66,
  3,
  18,
  9,
  0,
  65,
  61,
  1,
  0,
  0,
  0,
  65,
  62,
  1,
  0,
  0,
  0,
  65,
  63,
  1,
  0,
  0,
  0,
  65,
  64,
  1,
  0,
  0,
  0,
  66,
  7,
  1,
  0,
  0,
  0,
  67,
  68,
  3,
  2,
  1,
  0,
  68,
  9,
  1,
  0,
  0,
  0,
  69,
  78,
  5,
  40,
  0,
  0,
  70,
  78,
  3,
  24,
  12,
  0,
  71,
  78,
  3,
  20,
  10,
  0,
  72,
  78,
  3,
  22,
  11,
  0,
  73,
  78,
  5,
  37,
  0,
  0,
  74,
  78,
  5,
  38,
  0,
  0,
  75,
  78,
  5,
  39,
  0,
  0,
  76,
  78,
  5,
  42,
  0,
  0,
  77,
  69,
  1,
  0,
  0,
  0,
  77,
  70,
  1,
  0,
  0,
  0,
  77,
  71,
  1,
  0,
  0,
  0,
  77,
  72,
  1,
  0,
  0,
  0,
  77,
  73,
  1,
  0,
  0,
  0,
  77,
  74,
  1,
  0,
  0,
  0,
  77,
  75,
  1,
  0,
  0,
  0,
  77,
  76,
  1,
  0,
  0,
  0,
  78,
  11,
  1,
  0,
  0,
  0,
  79,
  80,
  3,
  16,
  8,
  0,
  80,
  81,
  5,
  5,
  0,
  0,
  81,
  83,
  1,
  0,
  0,
  0,
  82,
  79,
  1,
  0,
  0,
  0,
  83,
  86,
  1,
  0,
  0,
  0,
  84,
  82,
  1,
  0,
  0,
  0,
  84,
  85,
  1,
  0,
  0,
  0,
  85,
  87,
  1,
  0,
  0,
  0,
  86,
  84,
  1,
  0,
  0,
  0,
  87,
  88,
  3,
  16,
  8,
  0,
  88,
  13,
  1,
  0,
  0,
  0,
  89,
  90,
  5,
  6,
  0,
  0,
  90,
  91,
  3,
  16,
  8,
  0,
  91,
  15,
  1,
  0,
  0,
  0,
  92,
  93,
  5,
  35,
  0,
  0,
  93,
  17,
  1,
  0,
  0,
  0,
  94,
  95,
  5,
  7,
  0,
  0,
  95,
  100,
  3,
  10,
  5,
  0,
  96,
  97,
  5,
  8,
  0,
  0,
  97,
  99,
  3,
  10,
  5,
  0,
  98,
  96,
  1,
  0,
  0,
  0,
  99,
  102,
  1,
  0,
  0,
  0,
  100,
  98,
  1,
  0,
  0,
  0,
  100,
  101,
  1,
  0,
  0,
  0,
  101,
  103,
  1,
  0,
  0,
  0,
  102,
  100,
  1,
  0,
  0,
  0,
  103,
  104,
  5,
  9,
  0,
  0,
  104,
  19,
  1,
  0,
  0,
  0,
  105,
  106,
  7,
  1,
  0,
  0,
  106,
  21,
  1,
  0,
  0,
  0,
  107,
  108,
  5,
  12,
  0,
  0,
  108,
  23,
  1,
  0,
  0,
  0,
  109,
  110,
  7,
  2,
  0,
  0,
  110,
  25,
  1,
  0,
  0,
  0,
  111,
  112,
  7,
  3,
  0,
  0,
  112,
  27,
  1,
  0,
  0,
  0,
  113,
  114,
  7,
  4,
  0,
  0,
  114,
  29,
  1,
  0,
  0,
  0,
  115,
  116,
  7,
  5,
  0,
  0,
  116,
  31,
  1,
  0,
  0,
  0,
  117,
  118,
  5,
  36,
  0,
  0,
  118,
  33,
  1,
  0,
  0,
  0,
  6,
  48,
  56,
  65,
  77,
  84,
  100
];
OpraFilterParser.DecisionsToDFA = OpraFilterParser._ATN.decisionToState.map((ds, index) => new DFA2(ds, index));
var OpraFilterParser_default = OpraFilterParser;
var RootContext = class extends ParserRuleContext {
  static {
    __name(this, "RootContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  EOF() {
    return this.getToken(OpraFilterParser.EOF, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_root;
  }
  enterRule(listener) {
    if (listener.enterRoot) {
      listener.enterRoot(this);
    }
  }
  exitRule(listener) {
    if (listener.exitRoot) {
      listener.exitRoot(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitRoot) {
      return visitor.visitRoot(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionContext = class extends ParserRuleContext {
  static {
    __name(this, "ExpressionContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_expression;
  }
  copyFrom(ctx) {
    super.copyFrom(ctx);
  }
};
var ParenthesizedExpressionContext = class extends ExpressionContext {
  static {
    __name(this, "ParenthesizedExpressionContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  parenthesizedItem() {
    return this.getTypedRuleContext(ParenthesizedItemContext, 0);
  }
  enterRule(listener) {
    if (listener.enterParenthesizedExpression) {
      listener.enterParenthesizedExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParenthesizedExpression) {
      listener.exitParenthesizedExpression(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitParenthesizedExpression) {
      return visitor.visitParenthesizedExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NegativeExpressionContext = class extends ExpressionContext {
  static {
    __name(this, "NegativeExpressionContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener.enterNegativeExpression) {
      listener.enterNegativeExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNegativeExpression) {
      listener.exitNegativeExpression(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitNegativeExpression) {
      return visitor.visitNegativeExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ComparisonExpressionContext = class extends ExpressionContext {
  static {
    __name(this, "ComparisonExpressionContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  comparisonLeft() {
    return this.getTypedRuleContext(ComparisonLeftContext, 0);
  }
  comparisonOperator() {
    return this.getTypedRuleContext(ComparisonOperatorContext, 0);
  }
  comparisonRight() {
    return this.getTypedRuleContext(ComparisonRightContext, 0);
  }
  enterRule(listener) {
    if (listener.enterComparisonExpression) {
      listener.enterComparisonExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitComparisonExpression) {
      listener.exitComparisonExpression(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitComparisonExpression) {
      return visitor.visitComparisonExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var LogicalExpressionContext = class extends ExpressionContext {
  static {
    __name(this, "LogicalExpressionContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  expression_list() {
    return this.getTypedRuleContexts(ExpressionContext);
  }
  expression(i) {
    return this.getTypedRuleContext(ExpressionContext, i);
  }
  logicalOperator() {
    return this.getTypedRuleContext(LogicalOperatorContext, 0);
  }
  enterRule(listener) {
    if (listener.enterLogicalExpression) {
      listener.enterLogicalExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitLogicalExpression) {
      listener.exitLogicalExpression(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitLogicalExpression) {
      return visitor.visitLogicalExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ComparisonLeftContext = class extends ParserRuleContext {
  static {
    __name(this, "ComparisonLeftContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  qualifiedIdentifier() {
    return this.getTypedRuleContext(QualifiedIdentifierContext, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_comparisonLeft;
  }
  enterRule(listener) {
    if (listener.enterComparisonLeft) {
      listener.enterComparisonLeft(this);
    }
  }
  exitRule(listener) {
    if (listener.exitComparisonLeft) {
      listener.exitComparisonLeft(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitComparisonLeft) {
      return visitor.visitComparisonLeft(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ComparisonRightContext = class extends ParserRuleContext {
  static {
    __name(this, "ComparisonRightContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  value() {
    return this.getTypedRuleContext(ValueContext, 0);
  }
  qualifiedIdentifier() {
    return this.getTypedRuleContext(QualifiedIdentifierContext, 0);
  }
  externalConstant() {
    return this.getTypedRuleContext(ExternalConstantContext, 0);
  }
  arrayValue() {
    return this.getTypedRuleContext(ArrayValueContext, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_comparisonRight;
  }
  enterRule(listener) {
    if (listener.enterComparisonRight) {
      listener.enterComparisonRight(this);
    }
  }
  exitRule(listener) {
    if (listener.exitComparisonRight) {
      listener.exitComparisonRight(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitComparisonRight) {
      return visitor.visitComparisonRight(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ParenthesizedItemContext = class extends ParserRuleContext {
  static {
    __name(this, "ParenthesizedItemContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_parenthesizedItem;
  }
  enterRule(listener) {
    if (listener.enterParenthesizedItem) {
      listener.enterParenthesizedItem(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParenthesizedItem) {
      listener.exitParenthesizedItem(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitParenthesizedItem) {
      return visitor.visitParenthesizedItem(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ValueContext = class extends ParserRuleContext {
  static {
    __name(this, "ValueContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_value;
  }
  copyFrom(ctx) {
    super.copyFrom(ctx);
  }
};
var TimeLiteralContext = class extends ValueContext {
  static {
    __name(this, "TimeLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  TIME() {
    return this.getToken(OpraFilterParser.TIME, 0);
  }
  enterRule(listener) {
    if (listener.enterTimeLiteral) {
      listener.enterTimeLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitTimeLiteral) {
      listener.exitTimeLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitTimeLiteral) {
      return visitor.visitTimeLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NullLiteralContext = class extends ValueContext {
  static {
    __name(this, "NullLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  null_() {
    return this.getTypedRuleContext(NullContext, 0);
  }
  enterRule(listener) {
    if (listener.enterNullLiteral) {
      listener.enterNullLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNullLiteral) {
      listener.exitNullLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitNullLiteral) {
      return visitor.visitNullLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var DateTimeLiteralContext = class extends ValueContext {
  static {
    __name(this, "DateTimeLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  DATETIME() {
    return this.getToken(OpraFilterParser.DATETIME, 0);
  }
  enterRule(listener) {
    if (listener.enterDateTimeLiteral) {
      listener.enterDateTimeLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitDateTimeLiteral) {
      listener.exitDateTimeLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitDateTimeLiteral) {
      return visitor.visitDateTimeLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StringLiteralContext = class extends ValueContext {
  static {
    __name(this, "StringLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  STRING() {
    return this.getToken(OpraFilterParser.STRING, 0);
  }
  enterRule(listener) {
    if (listener.enterStringLiteral) {
      listener.enterStringLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStringLiteral) {
      listener.exitStringLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitStringLiteral) {
      return visitor.visitStringLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var DateLiteralContext = class extends ValueContext {
  static {
    __name(this, "DateLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  DATE() {
    return this.getToken(OpraFilterParser.DATE, 0);
  }
  enterRule(listener) {
    if (listener.enterDateLiteral) {
      listener.enterDateLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitDateLiteral) {
      listener.exitDateLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitDateLiteral) {
      return visitor.visitDateLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InfinityLiteralContext = class extends ValueContext {
  static {
    __name(this, "InfinityLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  infinity() {
    return this.getTypedRuleContext(InfinityContext, 0);
  }
  enterRule(listener) {
    if (listener.enterInfinityLiteral) {
      listener.enterInfinityLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitInfinityLiteral) {
      listener.exitInfinityLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitInfinityLiteral) {
      return visitor.visitInfinityLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var BooleanLiteralContext = class extends ValueContext {
  static {
    __name(this, "BooleanLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  boolean_() {
    return this.getTypedRuleContext(BooleanContext, 0);
  }
  enterRule(listener) {
    if (listener.enterBooleanLiteral) {
      listener.enterBooleanLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitBooleanLiteral) {
      listener.exitBooleanLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitBooleanLiteral) {
      return visitor.visitBooleanLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NumberLiteralContext = class extends ValueContext {
  static {
    __name(this, "NumberLiteralContext");
  }
  constructor(parser, ctx) {
    super(parser, ctx.parentCtx, ctx.invokingState);
    super.copyFrom(ctx);
  }
  NUMBER() {
    return this.getToken(OpraFilterParser.NUMBER, 0);
  }
  enterRule(listener) {
    if (listener.enterNumberLiteral) {
      listener.enterNumberLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNumberLiteral) {
      listener.exitNumberLiteral(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitNumberLiteral) {
      return visitor.visitNumberLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var QualifiedIdentifierContext = class extends ParserRuleContext {
  static {
    __name(this, "QualifiedIdentifierContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  identifier_list() {
    return this.getTypedRuleContexts(IdentifierContext);
  }
  identifier(i) {
    return this.getTypedRuleContext(IdentifierContext, i);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_qualifiedIdentifier;
  }
  enterRule(listener) {
    if (listener.enterQualifiedIdentifier) {
      listener.enterQualifiedIdentifier(this);
    }
  }
  exitRule(listener) {
    if (listener.exitQualifiedIdentifier) {
      listener.exitQualifiedIdentifier(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitQualifiedIdentifier) {
      return visitor.visitQualifiedIdentifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExternalConstantContext = class extends ParserRuleContext {
  static {
    __name(this, "ExternalConstantContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_externalConstant;
  }
  enterRule(listener) {
    if (listener.enterExternalConstant) {
      listener.enterExternalConstant(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExternalConstant) {
      listener.exitExternalConstant(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitExternalConstant) {
      return visitor.visitExternalConstant(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var IdentifierContext = class extends ParserRuleContext {
  static {
    __name(this, "IdentifierContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  IDENTIFIER() {
    return this.getToken(OpraFilterParser.IDENTIFIER, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_identifier;
  }
  enterRule(listener) {
    if (listener.enterIdentifier) {
      listener.enterIdentifier(this);
    }
  }
  exitRule(listener) {
    if (listener.exitIdentifier) {
      listener.exitIdentifier(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitIdentifier) {
      return visitor.visitIdentifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ArrayValueContext = class extends ParserRuleContext {
  static {
    __name(this, "ArrayValueContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  value_list() {
    return this.getTypedRuleContexts(ValueContext);
  }
  value(i) {
    return this.getTypedRuleContext(ValueContext, i);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_arrayValue;
  }
  enterRule(listener) {
    if (listener.enterArrayValue) {
      listener.enterArrayValue(this);
    }
  }
  exitRule(listener) {
    if (listener.exitArrayValue) {
      listener.exitArrayValue(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitArrayValue) {
      return visitor.visitArrayValue(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var BooleanContext = class extends ParserRuleContext {
  static {
    __name(this, "BooleanContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_boolean;
  }
  enterRule(listener) {
    if (listener.enterBoolean) {
      listener.enterBoolean(this);
    }
  }
  exitRule(listener) {
    if (listener.exitBoolean) {
      listener.exitBoolean(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitBoolean) {
      return visitor.visitBoolean(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NullContext = class extends ParserRuleContext {
  static {
    __name(this, "NullContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_null;
  }
  enterRule(listener) {
    if (listener.enterNull) {
      listener.enterNull(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNull) {
      listener.exitNull(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitNull) {
      return visitor.visitNull(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InfinityContext = class extends ParserRuleContext {
  static {
    __name(this, "InfinityContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_infinity;
  }
  enterRule(listener) {
    if (listener.enterInfinity) {
      listener.enterInfinity(this);
    }
  }
  exitRule(listener) {
    if (listener.exitInfinity) {
      listener.exitInfinity(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitInfinity) {
      return visitor.visitInfinity(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ArithmeticOperatorContext = class extends ParserRuleContext {
  static {
    __name(this, "ArithmeticOperatorContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_arithmeticOperator;
  }
  enterRule(listener) {
    if (listener.enterArithmeticOperator) {
      listener.enterArithmeticOperator(this);
    }
  }
  exitRule(listener) {
    if (listener.exitArithmeticOperator) {
      listener.exitArithmeticOperator(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitArithmeticOperator) {
      return visitor.visitArithmeticOperator(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ComparisonOperatorContext = class extends ParserRuleContext {
  static {
    __name(this, "ComparisonOperatorContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_comparisonOperator;
  }
  enterRule(listener) {
    if (listener.enterComparisonOperator) {
      listener.enterComparisonOperator(this);
    }
  }
  exitRule(listener) {
    if (listener.exitComparisonOperator) {
      listener.exitComparisonOperator(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitComparisonOperator) {
      return visitor.visitComparisonOperator(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var LogicalOperatorContext = class extends ParserRuleContext {
  static {
    __name(this, "LogicalOperatorContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_logicalOperator;
  }
  enterRule(listener) {
    if (listener.enterLogicalOperator) {
      listener.enterLogicalOperator(this);
    }
  }
  exitRule(listener) {
    if (listener.exitLogicalOperator) {
      listener.exitLogicalOperator(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitLogicalOperator) {
      return visitor.visitLogicalOperator(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PolarityOperatorContext = class extends ParserRuleContext {
  static {
    __name(this, "PolarityOperatorContext");
  }
  constructor(parser, parent, invokingState) {
    super(parent, invokingState);
    this.parser = parser;
  }
  POLAR_OP() {
    return this.getToken(OpraFilterParser.POLAR_OP, 0);
  }
  get ruleIndex() {
    return OpraFilterParser.RULE_polarityOperator;
  }
  enterRule(listener) {
    if (listener.enterPolarityOperator) {
      listener.enterPolarityOperator(this);
    }
  }
  exitRule(listener) {
    if (listener.exitPolarityOperator) {
      listener.exitPolarityOperator(this);
    }
  }
  // @Override
  accept(visitor) {
    if (visitor.visitPolarityOperator) {
      return visitor.visitPolarityOperator(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};

// ../../build/common/esm/filter/filter-tree-visitor.js
import antlr4 from "@browsery/antlr4";

// ../../build/common/esm/filter/ast/terms/external-constant.js
var ExternalConstant = class extends Literal {
  static {
    __name(this, "ExternalConstant");
  }
  constructor(value) {
    super("" + value);
  }
  toString() {
    return "@" + super.toString();
  }
};

// ../../build/common/esm/filter/filter-tree-visitor.js
var ParseTreeVisitor = antlr4.tree.ParseTreeVisitor;
var FilterTreeVisitor = class extends ParseTreeVisitor {
  static {
    __name(this, "FilterTreeVisitor");
  }
  constructor(options) {
    super();
    this._timeZone = options?.timeZone;
  }
  visitChildren(node) {
    const result = super.visitChildren(node);
    if (Array.isArray(result) && result.length < 2)
      return result[0];
    return result ?? node.getText();
  }
  defaultResult() {
    return void 0;
  }
  visitRoot(ctx) {
    return this.visit(ctx.expression());
  }
  visitParenthesizedExpression(ctx) {
    const expression = this.visit(ctx.parenthesizedItem());
    return new ParenthesizedExpression(expression);
  }
  visitParenthesizedItem(ctx) {
    return this.visit(ctx.expression());
  }
  visitNegativeExpression(ctx) {
    const expression = this.visit(ctx.expression());
    return new NegativeExpression(expression);
  }
  visitComparisonExpression(ctx) {
    return new ComparisonExpression({
      op: ctx.comparisonOperator().getText(),
      left: this.visit(ctx.comparisonLeft()),
      right: this.visit(ctx.comparisonRight())
    });
  }
  visitLogicalExpression(ctx) {
    const items = [];
    const wrapChildren = /* @__PURE__ */ __name((arr, op) => {
      for (const c of arr) {
        if (c instanceof LogicalExpressionContext && c.logicalOperator().getText() === op) {
          wrapChildren(c.expression_list(), c.logicalOperator().getText());
          continue;
        }
        const o = this.visit(c);
        items.push(o);
      }
    }, "wrapChildren");
    wrapChildren(ctx.expression_list(), ctx.logicalOperator().getText());
    return new LogicalExpression({
      op: ctx.logicalOperator().getText(),
      items
    });
  }
  visitQualifiedIdentifier(ctx) {
    return new QualifiedIdentifier(ctx.getText());
  }
  visitExternalConstant(ctx) {
    return new ExternalConstant(ctx.identifier().getText());
  }
  visitNullLiteral() {
    return new NullLiteral();
  }
  visitBooleanLiteral(ctx) {
    return new BooleanLiteral(ctx.getText() === "true");
  }
  visitNumberLiteral(ctx) {
    return new NumberLiteral(ctx.getText());
  }
  visitStringLiteral(ctx) {
    return new StringLiteral(unquoteFilterString(ctx.getText()));
  }
  visitInfinityLiteral() {
    return new NumberLiteral(Infinity);
  }
  visitDateLiteral(ctx) {
    return new DateLiteral(unquoteFilterString(ctx.getText()));
  }
  visitDateTimeLiteral(ctx) {
    return new DateLiteral(unquoteFilterString(ctx.getText()));
  }
  visitTimeLiteral(ctx) {
    return new TimeLiteral(unquoteFilterString(ctx.getText()));
  }
  visitArrayValue(ctx) {
    return new ArrayExpression(ctx.value_list().map((child) => this.visit(child)));
  }
};

// ../../build/common/esm/filter/opra-error-listener.js
import { ErrorListener } from "@browsery/antlr4";
var OpraErrorListener = class extends ErrorListener {
  static {
    __name(this, "OpraErrorListener");
  }
  constructor(errors) {
    super();
    this.errors = errors;
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    this.errors.push(new FilterParseError(msg, { recognizer, offendingSymbol, line, column, e }));
  }
};

// ../../build/common/esm/filter/parse.js
function parse(text, visitor) {
  const chars = new CharStream(text);
  const lexer = new OpraFilterLexer_default(chars);
  const tokenStream = new CommonTokenStream(lexer);
  const parser = new OpraFilterParser_default(tokenStream);
  parser.buildParseTrees = true;
  const errors = [];
  const errorListener = new OpraErrorListener(errors);
  lexer.removeErrorListeners();
  lexer.addErrorListener(errorListener);
  parser.removeErrorListeners();
  parser.addErrorListener(errorListener);
  const tree = parser.root();
  if (errors.length) {
    const errMsgs = [];
    for (const err of errors) {
      errMsgs.push(err.message + (text.includes("\n") ? " at line: " + err.line + " column: " + err.column : " at  column: " + err.column));
    }
    const e = new SyntaxError(errMsgs.join("\n"));
    e.errors = errors;
    throw e;
  }
  visitor = visitor || new FilterTreeVisitor();
  return visitor.visit(tree);
}
__name(parse, "parse");

// ../../build/common/esm/filter/build.js
function $or(...items) {
  return new LogicalExpression({ op: "or", items });
}
__name($or, "$or");
function $and(...items) {
  return new LogicalExpression({ op: "and", items });
}
__name($and, "$and");
function $date(v) {
  return new DateLiteral(v);
}
__name($date, "$date");
function $time(v) {
  return new TimeLiteral(v);
}
__name($time, "$time");
function $number(v) {
  return new NumberLiteral(v);
}
__name($number, "$number");
function $array(...items) {
  return new ArrayExpression(items.map(wrapEntryValue));
}
__name($array, "$array");
function $field(v) {
  return new QualifiedIdentifier(v);
}
__name($field, "$field");
function $eq(left, right) {
  return comparisonExpression("=", left, right);
}
__name($eq, "$eq");
function $ne(left, right) {
  return comparisonExpression("!=", left, right);
}
__name($ne, "$ne");
function $gt(left, right) {
  return comparisonExpression(">", left, right);
}
__name($gt, "$gt");
function $gte(left, right) {
  return comparisonExpression(">=", left, right);
}
__name($gte, "$gte");
function $lt(left, right) {
  return comparisonExpression("<", left, right);
}
__name($lt, "$lt");
function $lte(left, right) {
  return comparisonExpression("<=", left, right);
}
__name($lte, "$lte");
function $in(left, right) {
  return comparisonExpression("in", left, right);
}
__name($in, "$in");
function $notIn(left, right) {
  return comparisonExpression("!in", left, right);
}
__name($notIn, "$notIn");
function $like(left, right) {
  return comparisonExpression("like", left, right);
}
__name($like, "$like");
function $notLike(left, right) {
  return comparisonExpression("!like", left, right);
}
__name($notLike, "$notLike");
function $ilike(left, right) {
  return comparisonExpression("ilike", left, right);
}
__name($ilike, "$ilike");
function $notILike(left, right) {
  return comparisonExpression("!ilike", left, right);
}
__name($notILike, "$notILike");
function $paren(expression) {
  return new ParenthesizedExpression(expression);
}
__name($paren, "$paren");
function $arithmetic(n) {
  const exp = new ArithmeticExpression();
  exp.add = (expression) => {
    exp.append("+", _wrapEntryValue(expression));
    return exp;
  };
  exp.sub = (expression) => {
    exp.append("-", _wrapEntryValue(expression));
    return exp;
  };
  exp.mul = (expression) => {
    exp.append("*", _wrapEntryValue(expression));
    return exp;
  };
  exp.div = (expression) => {
    exp.append("/", _wrapEntryValue(expression));
    return exp;
  };
  exp.append("+", wrapEntryValue(n));
  return exp;
}
__name($arithmetic, "$arithmetic");
function comparisonExpression(op, left, right) {
  const lex = wrapEntryValue(left);
  const rex = wrapEntryValue(right);
  return new ComparisonExpression({ op, left: lex, right: rex });
}
__name(comparisonExpression, "comparisonExpression");
var wrapEntryValue = /* @__PURE__ */ __name((v) => {
  return Array.isArray(v) ? $array(...v.map(_wrapEntryValue)) : _wrapEntryValue(v);
}, "wrapEntryValue");
var _wrapEntryValue = /* @__PURE__ */ __name((v) => {
  if (v instanceof Expression)
    return v;
  if (typeof v === "boolean")
    return new BooleanLiteral(v);
  if (typeof v === "number" || typeof v === "bigint")
    return new NumberLiteral(v);
  if (v == null)
    return new NullLiteral();
  if (v instanceof Date)
    return new DateLiteral(v);
  return new StringLiteral("" + v);
}, "_wrapEntryValue");

// ../../build/common/esm/document/resource/crud-operation.js
import { vg as vg12 } from "valgen";
var CrudOperation = class extends Endpoint {
  static {
    __name(this, "CrudOperation");
  }
  constructor(resource, name, init) {
    super(resource, name, init);
    this.resource = resource;
    this.name = name;
    this.kind = "operation";
    this.decodeInput = vg12.isAny();
    this.encodeReturning = vg12.isAny();
    if (init.returnType)
      this.returnType = init.returnType instanceof DataType ? init.returnType : this.resource.document.getDataType(init.returnType);
    this.encodeReturning = this.returnType?.generateCodec("encode", { operation: "read", partial: true }) || vg12.isAny();
    this.inputOverwriteFields = init.options?.inputOverwriteFields;
    this.outputOverwriteFields = init.options?.outputOverwriteFields;
  }
  exportSchema(options) {
    const schema = super.exportSchema(options);
    if (this.returnType)
      schema.returnType = this.returnType.name && !this.returnType.isEmbedded ? this.returnType.name : this.returnType.exportSchema(options);
    if (this.inputOverwriteFields) {
      const trg = schema.options.inputOverwriteFields = {};
      Object.keys(this.inputOverwriteFields).forEach(([k, o]) => {
        trg[k] = ApiField.prototype.exportSchema.call(o, options);
      });
    }
    if (this.outputOverwriteFields) {
      const trg = schema.options.outputOverwriteFields = {};
      Object.keys(this.outputOverwriteFields).forEach(([k, o]) => {
        trg[k] = ApiField.prototype.exportSchema.call(o, options);
      });
    }
    return schema;
  }
};

// ../../build/common/esm/document/resource/crud-resource.js
var CrudResource = class extends Resource {
  static {
    __name(this, "CrudResource");
  }
  constructor(parent, init) {
    super(parent, init);
    this.operations = new ResponsiveMap();
    if (init.operations) {
      for (const [name, meta] of Object.entries(init.operations)) {
        this.operations.set(name, new CrudOperation(this, name, meta));
      }
    }
  }
  getOperation(operation) {
    const op = this.operations.get(operation);
    if (!op)
      throw new Error(`${this.name} resource does not support "${operation}" operations`);
    return op;
  }
  exportSchema(options) {
    const schema = super.exportSchema(options);
    if (this.operations.size) {
      schema.operations = {};
      for (const operation of this.operations.values()) {
        schema.operations[operation.name] = operation.exportSchema(options);
      }
    }
    return schema;
  }
};

// ../../build/common/esm/document/resource/collection-class.js
var CollectionClass = class extends CrudResource {
  static {
    __name(this, "CollectionClass");
  }
  constructor(parent, init) {
    super(parent, init);
    this.kind = opra_schema_ns_exports.Collection.Kind;
    const dataType = this.type = init.type;
    this.primaryKey = init.primaryKey ? Array.isArray(init.primaryKey) ? init.primaryKey : [init.primaryKey] : [];
    if (!this.primaryKey.length)
      throw new TypeError(`You must provide primaryKey for Collection resource ("${this.name}")`);
    this.primaryKey.forEach((f) => {
      const field = dataType.getField(f);
      if (!(field?.type instanceof SimpleType2))
        throw new TypeError(`Only Simple type allowed for primary keys but "${f}" is a ${field.type.kind}`);
    });
    let endpoint = this.operations.get("create");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.decodeInput = this.type.generateCodec("decode", {
        partial: false,
        pick: endpoint.options.inputPickFields,
        omit: endpoint.options.inputOmitFields,
        operation: "write",
        overwriteFields: endpoint.inputOverwriteFields
      });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = endpoint.returnType.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      });
    }
    endpoint = this.operations.get("deleteMany");
    if (endpoint) {
      endpoint.defineParameter("filter", { type: "string", isBuiltin: true });
    }
    endpoint = this.operations.get("get");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = endpoint.returnType.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      });
    }
    endpoint = this.operations.get("findMany");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("sort", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("filter", { type: "string", isBuiltin: true });
      endpoint.defineParameter("limit", { type: "integer", isBuiltin: true });
      endpoint.defineParameter("skip", { type: "integer", isBuiltin: true });
      endpoint.defineParameter("distinct", { type: "boolean", isBuiltin: true });
      endpoint.defineParameter("count", { type: "boolean", isBuiltin: true });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = vg13.isArray(this.type.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      }));
    }
    endpoint = this.operations.get("update");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.decodeInput = this.type.generateCodec("decode", {
        partial: true,
        pick: endpoint.options.inputPickFields,
        omit: endpoint.options.inputOmitFields,
        operation: "write",
        overwriteFields: endpoint.inputOverwriteFields
      });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = endpoint.returnType.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      });
    }
    endpoint = this.operations.get("updateMany");
    if (endpoint) {
      endpoint.defineParameter("filter", { type: "string", isBuiltin: true });
      endpoint.decodeInput = this.type.generateCodec("decode", {
        partial: true,
        pick: endpoint.options.inputPickFields,
        omit: endpoint.options.inputOmitFields,
        operation: "write",
        overwriteFields: endpoint.inputOverwriteFields
      });
    }
  }
  exportSchema(options) {
    return {
      ...super.exportSchema(options),
      type: this.type.name || "object",
      ...{
        primaryKey: this.primaryKey
      }
    };
  }
  parseKeyValue(value) {
    if (!this.primaryKey?.length)
      return;
    const dataType = this.type;
    if (this.primaryKey.length > 1) {
      const obj = Array.isArray(value) ? this.primaryKey.reduce((o, k, i) => {
        o[k] = value[i];
        return obj;
      }, {}) : value;
      for (const [k, v] of Object.entries(obj)) {
        const el = dataType.getField(k);
        if (el.type instanceof SimpleType2) {
          try {
            obj[k] = el.type.decode(v, { coerce: true });
          } catch (e) {
            e.message = `The key value for field "${el.name}" is not valid. ` + e.message;
          }
        }
        if (obj[k] == null)
          throw new TypeError(`You must provide value of primary field(s) (${k})`);
      }
    } else {
      const primaryKey = this.primaryKey[0];
      if (typeof value === "object")
        value = value[primaryKey];
      const el = dataType.getField(primaryKey);
      let result;
      if (value != null && el.type instanceof SimpleType2) {
        try {
          result = el.type.decode(value, { coerce: true });
        } catch (e) {
          e.message = `The key value is not valid. ` + e.message;
        }
      }
      if (result == null)
        throw new TypeError(`You must provide value of primary field(s) (${primaryKey})`);
      return result;
    }
  }
  normalizeFieldNames(fields, allowSortSigns) {
    return this.type.normalizeFieldNames(fields, allowSortSigns);
  }
  normalizeSortFields(fields) {
    const normalized = this.type.normalizeFieldNames(fields, true);
    if (!normalized)
      return;
    const findManyOp = this.getOperation("findMany");
    const sortFields = findManyOp && findManyOp.options.sortFields;
    (Array.isArray(normalized) ? normalized : [normalized]).forEach((field) => {
      const m = SORT_FIELD_PATTERN.exec(field);
      if (m && !sortFields?.find((x) => x === m[2]))
        throw new BadRequestError({
          message: translate("error:UNACCEPTED_SORT_FIELD", { field })
        });
    });
    return normalized;
  }
  normalizeFilter(filter) {
    if (!filter)
      return;
    const ast = typeof filter === "string" ? opra_filter_ns_exports.parse(filter) : filter;
    if (ast instanceof opra_filter_ns_exports.ComparisonExpression) {
      this.normalizeFilter(ast.left);
      if (!(ast.left instanceof opra_filter_ns_exports.QualifiedIdentifier && ast.left.field))
        throw new TypeError(`Invalid filter query. Left side should be a data field.`);
      const findManyOp = this.getOperation("findMany");
      const fieldLower = ast.left.value.toLowerCase();
      const filterDef = (findManyOp && findManyOp.options.filters || []).find((f) => f.field.toLowerCase() === fieldLower);
      if (!filterDef) {
        throw new BadRequestError({
          message: translate("error:UNACCEPTED_FILTER_FIELD", { field: ast.left.value })
        });
      }
      if (filterDef.operators && !filterDef.operators.includes(ast.op))
        throw new BadRequestError({
          message: translate("error:UNACCEPTED_FILTER_OPERATION", { field: ast.left.value })
        });
      this.normalizeFilter(ast.right);
      return ast;
    }
    if (ast instanceof opra_filter_ns_exports.LogicalExpression) {
      ast.items.forEach((item) => this.normalizeFilter(item));
      return ast;
    }
    if (ast instanceof opra_filter_ns_exports.ArithmeticExpression) {
      ast.items.forEach((item) => this.normalizeFilter(item.expression));
      return ast;
    }
    if (ast instanceof opra_filter_ns_exports.ArrayExpression) {
      ast.items.forEach((item) => this.normalizeFilter(item));
      return ast;
    }
    if (ast instanceof opra_filter_ns_exports.ParenthesizedExpression) {
      this.normalizeFilter(ast.expression);
      return ast;
    }
    if (ast instanceof opra_filter_ns_exports.QualifiedIdentifier) {
      const normalizedFieldPath = this.type.normalizeFieldNames(ast.value)?.join(".");
      ast.field = this.type.getField(normalizedFieldPath);
      ast.dataType = ast.field?.type || this.document.getDataType("any");
      ast.value = normalizedFieldPath;
      return ast;
    }
    return ast;
  }
};

// ../../build/common/esm/document/resource/crud-operation-decorator.js
function createOperationDecorator(operation, init, list) {
  const decorator = /* @__PURE__ */ __name((target, propertyKey) => {
    if (propertyKey !== operation)
      throw new TypeError(`Name of the handler name should be '${operation}'`);
    const resourceMetadata = Reflect.getOwnMetadata(RESOURCE_METADATA, target.constructor) || {};
    resourceMetadata.operations = resourceMetadata.operations || {};
    const operationMeta = { ...init };
    operationMeta.options = operationMeta.options || {};
    resourceMetadata.operations[operation] = operationMeta;
    for (const fn of list)
      fn(operationMeta, target, propertyKey);
    Reflect.defineMetadata(RESOURCE_METADATA, resourceMetadata, target.constructor);
  }, "decorator");
  decorator.Parameter = (name, arg0) => {
    const parameterOptions = typeof arg0 === "string" || typeof arg0 === "function" ? { type: arg0 } : { ...arg0 };
    list.push((operationMeta) => {
      operationMeta.parameters = operationMeta.parameters || {};
      operationMeta.parameters[name] = { ...parameterOptions };
    });
    return decorator;
  };
  return decorator;
}
__name(createOperationDecorator, "createOperationDecorator");

// ../../build/common/esm/document/resource/collection-decorator.js
var operationProperties = ["create", "delete", "deleteMany", "get", "findMany", "update", "updateMany"];
function CollectionDecorator(type, options) {
  return ResourceDecorator(opra_schema_ns_exports.Collection.Kind, { ...options, type });
}
__name(CollectionDecorator, "CollectionDecorator");
Object.assign(CollectionDecorator, ResourceDecorator);
(function(CollectionDecorator2) {
  function Action2(options) {
    const list = [];
    return createActionDecorator(options, operationProperties, list);
  }
  __name(Action2, "Action");
  CollectionDecorator2.Action = Action2;
  function Create(options) {
    const list = [];
    const decorator = createOperationDecorator("create", options, list);
    decorator.InputMaxContentSize = (sizeInBytes) => {
      list.push((operationMeta) => operationMeta.options.inputMaxContentSize = sizeInBytes);
      return decorator;
    };
    decorator.InputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.inputPickFields = fields);
      return decorator;
    };
    decorator.InputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.inputOmitFields = fields);
      return decorator;
    };
    decorator.InputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.inputOverwriteFields = fields);
      return decorator;
    };
    decorator.OutputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputPickFields = fields);
      return decorator;
    };
    decorator.OutputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputOmitFields = fields);
      return decorator;
    };
    decorator.OutputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.outputOverwriteFields = fields);
      return decorator;
    };
    return decorator;
  }
  __name(Create, "Create");
  CollectionDecorator2.Create = Create;
  function Delete(options) {
    const list = [];
    return createOperationDecorator("delete", options, list);
  }
  __name(Delete, "Delete");
  CollectionDecorator2.Delete = Delete;
  function DeleteMany(options) {
    const list = [];
    const decorator = createOperationDecorator("deleteMany", options, list);
    decorator.Filter = (field, operators, notes) => {
      if (typeof operators === "string")
        operators = operators.split(/\s*[,| ]\s*/).filter((s) => s);
      list.push((operationMeta) => {
        operationMeta.options.filters = operationMeta.options.filters || [];
        operationMeta.options.filters.push(omitUndefined({ field, operators, notes }));
      });
      return decorator;
    };
    return decorator;
  }
  __name(DeleteMany, "DeleteMany");
  CollectionDecorator2.DeleteMany = DeleteMany;
  function Get(options) {
    const list = [];
    const decorator = createOperationDecorator("get", options, list);
    decorator.OutputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputPickFields = fields);
      return decorator;
    };
    decorator.OutputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputOmitFields = fields);
      return decorator;
    };
    decorator.OutputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.outputOverwriteFields = fields);
      return decorator;
    };
    return decorator;
  }
  __name(Get, "Get");
  CollectionDecorator2.Get = Get;
  function FindMany(options) {
    const list = [];
    const decorator = createOperationDecorator("findMany", options, list);
    decorator.SortFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.sortFields = fields);
      return decorator;
    };
    decorator.DefaultSort = (...fields) => {
      list.push((operationMeta) => operationMeta.options.defaultSort = fields);
      return decorator;
    };
    decorator.Filter = (field, operators, notes) => {
      if (typeof operators === "string")
        operators = operators.split(/\s*[,| ]\s*/);
      list.push((operationMeta) => {
        operationMeta.options.filters = operationMeta.options.filters || [];
        operationMeta.options.filters.push(omitUndefined({ field, operators, notes }));
      });
      return decorator;
    };
    decorator.OutputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputPickFields = fields);
      return decorator;
    };
    decorator.OutputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputOmitFields = fields);
      return decorator;
    };
    decorator.OutputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.outputOverwriteFields = fields);
      return decorator;
    };
    return decorator;
  }
  __name(FindMany, "FindMany");
  CollectionDecorator2.FindMany = FindMany;
})(CollectionDecorator || (CollectionDecorator = {}));
(function(CollectionDecorator2) {
  function Update(options) {
    const list = [];
    const decorator = createOperationDecorator("update", options, list);
    decorator.InputMaxContentSize = (sizeInBytes) => {
      list.push((operationMeta) => operationMeta.options.inputMaxContentSize = sizeInBytes);
      return decorator;
    };
    decorator.InputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.inputPickFields = fields);
      return decorator;
    };
    decorator.InputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.inputOmitFields = fields);
      return decorator;
    };
    decorator.InputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.inputOverwriteFields = fields);
      return decorator;
    };
    decorator.OutputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputPickFields = fields);
      return decorator;
    };
    decorator.OutputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.outputOmitFields = fields);
      return decorator;
    };
    decorator.OutputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.outputOverwriteFields = fields);
      return decorator;
    };
    return decorator;
  }
  __name(Update, "Update");
  CollectionDecorator2.Update = Update;
})(CollectionDecorator || (CollectionDecorator = {}));
(function(CollectionDecorator2) {
  function UpdateMany(arg0) {
    const list = [];
    const options = typeof arg0 === "string" ? { description: arg0 } : { ...arg0 };
    const decorator = createOperationDecorator("updateMany", options, list);
    decorator.InputMaxContentSize = (sizeInBytes) => {
      list.push((operationMeta) => operationMeta.options.inputMaxContentSize = sizeInBytes);
      return decorator;
    };
    decorator.InputPickFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.inputPickFields = fields);
      return decorator;
    };
    decorator.InputOmitFields = (...fields) => {
      list.push((operationMeta) => operationMeta.options.inputOmitFields = fields);
      return decorator;
    };
    decorator.InputOverwriteFields = (fields) => {
      list.push((operationMeta) => operationMeta.options.inputOverwriteFields = fields);
      return decorator;
    };
    decorator.Filter = (field, operators, notes) => {
      if (typeof operators === "string")
        operators = operators.split(/\s*[,| ]\s*/);
      list.push((operationMeta) => {
        operationMeta.options.filters = operationMeta.options.filters || [];
        operationMeta.options.filters.push(omitUndefined({ field, operators, notes }));
      });
      return decorator;
    };
    return decorator;
  }
  __name(UpdateMany, "UpdateMany");
  CollectionDecorator2.UpdateMany = UpdateMany;
})(CollectionDecorator || (CollectionDecorator = {}));

// ../../build/common/esm/document/resource/collection.js
var Collection2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [type, options] = args;
    return Collection2[DECORATOR].call(void 0, type, options);
  }
  const [parent, init] = args;
  merge10(this, new CollectionClass(parent, init), { descriptor: true });
}, "Collection");
Collection2.prototype = CollectionClass.prototype;
Object.assign(Collection2, CollectionDecorator);
Collection2[DECORATOR] = CollectionDecorator;

// ../../build/common/esm/document/resource/singleton.js
import merge11 from "putil-merge";

// ../../build/common/esm/document/resource/singleton-class.js
var SingletonClass = class extends CrudResource {
  static {
    __name(this, "SingletonClass");
  }
  constructor(parent, init) {
    super(parent, init);
    this.kind = opra_schema_ns_exports.Singleton.Kind;
    this.type = init.type;
    let endpoint = this.operations.get("create");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.decodeInput = this.type.generateCodec("decode", {
        partial: true,
        pick: endpoint.options.inputPickFields,
        omit: endpoint.options.inputOmitFields,
        operation: "write",
        overwriteFields: endpoint.inputOverwriteFields
      });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = endpoint.returnType.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      });
    }
    endpoint = this.operations.get("get");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = endpoint.returnType.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      });
    }
    endpoint = this.operations.get("update");
    if (endpoint) {
      endpoint.defineParameter("pick", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("omit", { type: "string", isArray: true, isBuiltin: true });
      endpoint.defineParameter("include", { type: "string", isArray: true, isBuiltin: true });
      endpoint.decodeInput = this.type.generateCodec("decode", {
        pick: endpoint.options.inputPickFields,
        omit: endpoint.options.inputOmitFields,
        operation: "write",
        overwriteFields: endpoint.inputOverwriteFields
      });
      endpoint.returnType = this.type;
      endpoint.encodeReturning = endpoint.returnType.generateCodec("encode", {
        partial: true,
        pick: endpoint.options.outputPickFields,
        omit: endpoint.options.outputOmitFields,
        operation: "read",
        overwriteFields: endpoint.outputOverwriteFields
      });
    }
  }
  getOperation(name) {
    return super.getOperation(name);
  }
  exportSchema(options) {
    return {
      ...super.exportSchema(options),
      type: this.type.name || "any"
    };
  }
  normalizeFieldNames(path) {
    return this.type.normalizeFieldNames(path);
  }
};

// ../../build/common/esm/document/resource/singleton-decorator.js
var operationProperties2 = ["create", "delete", "get", "update"];
function SingletonDecorator(type, options) {
  return ResourceDecorator(opra_schema_ns_exports.Singleton.Kind, { ...options, type });
}
__name(SingletonDecorator, "SingletonDecorator");
Object.assign(SingletonDecorator, ResourceDecorator);
(function(SingletonDecorator2) {
  function Action2(options) {
    const list = [];
    return createActionDecorator(options, operationProperties2, list);
  }
  __name(Action2, "Action");
  SingletonDecorator2.Action = Action2;
  function Create(options) {
    return CollectionDecorator.Create(options);
  }
  __name(Create, "Create");
  SingletonDecorator2.Create = Create;
})(SingletonDecorator || (SingletonDecorator = {}));
(function(SingletonDecorator2) {
  function Get(options) {
    return CollectionDecorator.Get(options);
  }
  __name(Get, "Get");
  SingletonDecorator2.Get = Get;
})(SingletonDecorator || (SingletonDecorator = {}));
(function(SingletonDecorator2) {
  function Delete(options) {
    return CollectionDecorator.Delete(options);
  }
  __name(Delete, "Delete");
  SingletonDecorator2.Delete = Delete;
})(SingletonDecorator || (SingletonDecorator = {}));
(function(SingletonDecorator2) {
  function Update(options) {
    return CollectionDecorator.Update(options);
  }
  __name(Update, "Update");
  SingletonDecorator2.Update = Update;
})(SingletonDecorator || (SingletonDecorator = {}));

// ../../build/common/esm/document/resource/singleton.js
var Singleton2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [type, options] = args;
    return Singleton2[DECORATOR].call(void 0, type, options);
  }
  const [parent, init] = args;
  merge11(this, new SingletonClass(parent, init), { descriptor: true });
}, "Singleton");
Singleton2.prototype = SingletonClass.prototype;
Object.assign(Singleton2, SingletonDecorator);
Singleton2[DECORATOR] = SingletonDecorator;

// ../../build/common/esm/document/resource/storage.js
import merge12 from "putil-merge";

// ../../build/common/esm/document/resource/storage-class.js
var StorageClass = class extends CrudResource {
  static {
    __name(this, "StorageClass");
  }
  constructor(parent, init) {
    super(parent, init);
    this.kind = opra_schema_ns_exports.Storage.Kind;
  }
  getOperation(name) {
    return super.getOperation(name);
  }
  exportSchema(options) {
    return super.exportSchema(options);
  }
};

// ../../build/common/esm/document/resource/storage-decorator.js
var operationProperties3 = ["delete", "get", "post"];
function StorageDecorator(options) {
  return ResourceDecorator(opra_schema_ns_exports.Storage.Kind, options);
}
__name(StorageDecorator, "StorageDecorator");
Object.assign(StorageDecorator, ResourceDecorator);
(function(StorageDecorator2) {
  function Action2(options) {
    const list = [];
    return createActionDecorator(options, operationProperties3, list);
  }
  __name(Action2, "Action");
  StorageDecorator2.Action = Action2;
  function Delete(options) {
    const list = [];
    return createOperationDecorator("delete", options, list);
  }
  __name(Delete, "Delete");
  StorageDecorator2.Delete = Delete;
  function Get(options) {
    const list = [];
    return createOperationDecorator("get", options, list);
  }
  __name(Get, "Get");
  StorageDecorator2.Get = Get;
  function Post(options) {
    const list = [];
    const decorator = createOperationDecorator("post", options, list);
    decorator.MaxFields = (amount) => {
      list.push((operationMeta) => operationMeta.options.maxFields = amount);
      return decorator;
    };
    decorator.MaxFieldSize = (amount) => {
      list.push((operationMeta) => operationMeta.options.maxFieldsSize = amount);
      return decorator;
    };
    decorator.MaxFiles = (amount) => {
      list.push((operationMeta) => operationMeta.options.maxFiles = amount);
      return decorator;
    };
    decorator.MaxFileSize = (sizeInBytes) => {
      list.push((operationMeta) => operationMeta.options.maxFileSize = sizeInBytes);
      return decorator;
    };
    decorator.MaxTotalFileSize = (sizeInBytes) => {
      list.push((operationMeta) => operationMeta.options.maxTotalFileSize = sizeInBytes);
      return decorator;
    };
    decorator.MinFileSize = (sizeInBytes) => {
      list.push((operationMeta) => operationMeta.options.minFileSize = sizeInBytes);
      return decorator;
    };
    decorator.Returns = (t) => {
      list.push((operationMeta) => operationMeta.returnType = t);
      return decorator;
    };
    return decorator;
  }
  __name(Post, "Post");
  StorageDecorator2.Post = Post;
})(StorageDecorator || (StorageDecorator = {}));

// ../../build/common/esm/document/resource/storage.js
var Storage2 = /* @__PURE__ */ __name(function(...args) {
  if (!this) {
    const [options] = args;
    return Storage2[DECORATOR].call(void 0, options);
  }
  const [parent, init] = args;
  merge12(this, new StorageClass(parent, init), { descriptor: true });
}, "Storage");
Storage2.prototype = StorageClass.prototype;
Object.assign(Storage2, StorageDecorator);
Storage2[DECORATOR] = StorageDecorator;

// ../../build/common/esm/document/factory/api-document-factory.js
var ApiDocumentFactory = class _ApiDocumentFactory extends TypeDocumentFactory {
  static {
    __name(this, "ApiDocumentFactory");
  }
  constructor() {
    super(...arguments);
    this.resourceQueue = new ResponsiveMap();
  }
  /**
   * Creates ApiDocument instance from given schema object
   * @param init
   */
  static async createDocument(init) {
    const factory = new _ApiDocumentFactory();
    const document = factory.document = new ApiDocument();
    await factory.initDocument(init);
    return document;
  }
  /**
   * Downloads schema from the given URL and creates the document instance   * @param url
   */
  static async createDocumentFromUrl(url) {
    const factory = new _ApiDocumentFactory();
    const document = factory.document = new ApiDocument();
    await factory.initDocumentFromUrl(url);
    return document;
  }
  async initDocument(init) {
    await super.initDocument(init);
    const processContainer = /* @__PURE__ */ __name(async (container, containerInit) => {
      if (!containerInit.resources)
        return;
      if (Array.isArray(containerInit.resources)) {
        for (const thunk of containerInit.resources) {
          const initArguments = await this.importResourceInstance(thunk);
          container.resources.set(initArguments.name, await this.createResource(container, initArguments));
        }
      } else
        for (const [name, schema] of Object.entries(containerInit.resources)) {
          const initArguments = await this.importResourceSchema(name, schema);
          container.resources.set(initArguments.name, await this.createResource(container, initArguments));
        }
      container.resources.sort();
    }, "processContainer");
    if (init.root) {
      this.curPath.push("/root");
      await processContainer(this.document.root, init.root);
      this.curPath.pop();
      this.document.invalidate();
    }
    return this.document;
  }
  async importResourceSchema(name, schema) {
    const convertEndpoints = /* @__PURE__ */ __name(async (source) => {
      if (!source)
        return;
      const output = {};
      for (const [endpointName, endpointSchema] of Object.entries(source)) {
        if (!endpointSchema)
          continue;
        const outputEndpoint = output[endpointName] = { ...endpointSchema };
        let parameters;
        if (endpointSchema.returnType) {
          outputEndpoint.returnType = await this.importDataType(endpointSchema.returnType);
        }
        if (endpointSchema.parameters) {
          parameters = outputEndpoint.parameters = {};
          for (const [kP, oP] of Object.entries(endpointSchema.parameters)) {
            if (oP.enum) {
              oP.type = EnumType2(oP.enum, { name: kP + "Enum" });
            }
            parameters[kP] = {
              ...oP,
              type: await this.importDataType(oP.type || "any")
            };
          }
        }
      }
      return output;
    }, "convertEndpoints");
    if (schema.kind === "Collection") {
      return {
        ...schema,
        kind: schema.kind,
        name,
        type: await this.importDataType(schema.type),
        actions: await convertEndpoints(schema.actions),
        operations: await convertEndpoints(schema.operations)
      };
    } else if (schema.kind === "Singleton") {
      return {
        ...schema,
        kind: schema.kind,
        name,
        type: await this.importDataType(schema.type),
        actions: await convertEndpoints(schema.actions),
        operations: await convertEndpoints(schema.operations)
      };
    } else if (schema.kind === "Storage") {
      return {
        ...schema,
        name,
        actions: await convertEndpoints(schema.actions),
        operations: await convertEndpoints(schema.operations)
      };
    } else if (schema.kind === "Container") {
      const resources = [];
      if (schema.resources) {
        for (const [k, o] of Object.entries(schema.resources)) {
          const rinit = await this.importResourceSchema(k, o);
          resources.push(rinit);
        }
      }
      return {
        ...schema,
        name,
        resources,
        actions: await convertEndpoints(schema.actions)
      };
    }
    throw new TypeError(`Can not import resource schema (${schema.kind})`);
  }
  async importResourceInstance(thunk) {
    thunk = await resolveThunk(thunk);
    let ctor;
    let metadata;
    let instance;
    if (typeof thunk === "function") {
      ctor = thunk;
    } else {
      ctor = Object.getPrototypeOf(thunk).constructor;
      instance = thunk;
      if (!Reflect.hasMetadata(RESOURCE_METADATA, ctor) && opra_schema_ns_exports.isResource(thunk) && typeof thunk.controller === "object") {
        ctor = Object.getPrototypeOf(thunk.controller).constructor;
        metadata = thunk;
        instance = thunk.controller;
      }
    }
    metadata = metadata || Reflect.getMetadata(RESOURCE_METADATA, ctor);
    if (!metadata && opra_schema_ns_exports.isResource(metadata))
      throw new TypeError(`Class "${ctor.name}" doesn't have a valid Resource metadata`);
    const convertEndpoints = /* @__PURE__ */ __name(async (source) => {
      if (!source)
        return;
      const output = {};
      for (const [kA, oA] of Object.entries(source)) {
        const o = output[kA] = { ...oA };
        if (oA.returnType) {
          o.returnType = await this.importDataType(oA.returnType);
        }
        if (oA.parameters) {
          const parameters = o.parameters = {};
          for (const [kP, oP] of Object.entries(oA.parameters)) {
            if (oP.enum) {
              oP.type = EnumType2(oP.enum, { name: kP + "Enum" });
            }
            parameters[kP] = {
              ...oP,
              type: await this.importDataType(oP.type || "any")
            };
          }
        }
        if (oA.options?.inputOverwriteFields) {
          const inputOverwriteFields = {};
          for (const [kP, oP] of Object.entries(oA.options.inputOverwriteFields)) {
            if (oP.enum) {
              oP.type = EnumType2(oP.enum, { name: kP + "Enum" });
            }
            inputOverwriteFields[kP] = { ...oP };
            if (oP.type)
              inputOverwriteFields[kP].type = await this.importDataType(oP.type);
          }
          o.options.inputOverwriteFields = inputOverwriteFields;
        }
        if (oA.options?.outputOverwriteFields) {
          const outputOverwriteFields = {};
          for (const [kP, oP] of Object.entries(oA.options.outputOverwriteFields)) {
            if (oP.enum) {
              oP.type = EnumType2(oP.enum, { name: kP + "Enum" });
            }
            outputOverwriteFields[kP] = { ...oP };
            if (oP.type)
              outputOverwriteFields[kP].type = await this.importDataType(oP.type);
          }
          o.options.outputOverwriteFields = outputOverwriteFields;
        }
      }
      return output;
    }, "convertEndpoints");
    const initArguments = cloneObject(metadata);
    initArguments.controller = instance;
    initArguments.ctor = ctor;
    if (initArguments.actions)
      initArguments.actions = await convertEndpoints(initArguments.actions);
    if (initArguments.kind === "Collection" || initArguments.kind === "Singleton") {
      const dataType = await this.importDataType(metadata.type);
      if (!dataType)
        throw new TypeError(`Unable to determine data type of "${initArguments.name}" resource`);
      if (!(dataType instanceof ComplexType2))
        throw new TypeError(`Data type of "${initArguments.name}" resource is not a ComplexType`);
      initArguments.type = dataType;
      if (initArguments.operations)
        initArguments.operations = await convertEndpoints(initArguments.operations);
    } else if (initArguments.kind === "Container") {
      const oldResources = initArguments.resources;
      if (Array.isArray(oldResources)) {
        initArguments.resources = [];
        for (const t of oldResources) {
          const rinit = await this.importResourceInstance(t);
          initArguments.resources.push(rinit);
        }
      }
    }
    return initArguments;
  }
  async createResource(container, initArguments) {
    if (initArguments.kind === "Collection")
      return new Collection2(container, initArguments);
    if (initArguments.kind === "Singleton")
      return new Singleton2(container, initArguments);
    if (initArguments.kind === "Storage")
      return new Storage2(container, initArguments);
    if (initArguments.kind === "Container") {
      const newContainer = new Container2(container, { ...initArguments, resources: void 0 });
      if (initArguments.resources) {
        for (const r of initArguments.resources) {
          const res = await this.createResource(newContainer, r);
          newContainer.resources.set(res.name, res);
        }
      }
      return newContainer;
    } else
      throw new Error(`Unknown resource type ${initArguments.kind}`);
  }
};

// ../../build/common/esm/document/resource/enums/metadata-mode.enum.js
var MetadataMode;
(function(MetadataMode2) {
  MetadataMode2["none"] = "none";
  MetadataMode2["minimal"] = "minimal";
  MetadataMode2["full"] = "full";
})(MetadataMode || (MetadataMode = {}));
EnumType2(MetadataMode, {
  name: "MetadataMode",
  description: 'Parameter "enumeration" that controls how metadata information sent',
  meanings: {
    "none": "Specifies that the service will include NO metadata information in the response",
    "minimal": "Specifies that the service will include ALL metadata information in the response",
    "full": "Specifies that the service will include MINIMAL metadata information in the response"
  }
});

// ../../build/common/esm/document/resource/types/operation-result.type.js
var OperationResult = class OperationResult2 {
  static {
    __name(this, "OperationResult");
  }
  constructor(init) {
    if (init)
      Object.assign(this, init);
  }
};
__decorate([
  ApiField()
], OperationResult.prototype, "context", void 0);
__decorate([
  ApiField()
], OperationResult.prototype, "contextUrl", void 0);
__decorate([
  ApiField()
], OperationResult.prototype, "type", void 0);
__decorate([
  ApiField()
], OperationResult.prototype, "typeUrl", void 0);
__decorate([
  ApiField()
], OperationResult.prototype, "affected", void 0);
__decorate([
  ApiField()
], OperationResult.prototype, "count", void 0);
__decorate([
  ApiField()
], OperationResult.prototype, "totalMatches", void 0);
__decorate([
  ApiField({ type: "any" })
], OperationResult.prototype, "payload", void 0);
__decorate([
  ApiField({ type: "object" })
], OperationResult.prototype, "errors", void 0);
OperationResult = __decorate([
  ComplexType2({
    description: "Operation result"
  })
], OperationResult);

// ../../build/common/esm/index.js
import { uid } from "uid";
export {
  Action,
  ApiDocument,
  ApiDocumentFactory,
  ApiField,
  BadRequestError,
  BaseI18n,
  Collection2 as Collection,
  ComplexType2 as ComplexType,
  ConflictError,
  Container2 as Container,
  CrudOperation,
  CrudResource,
  DATATYPE_METADATA,
  DECORATOR,
  DataType,
  Endpoint,
  EnumType2 as EnumType,
  FailedDependencyError,
  ForbiddenError,
  HttpHeaderCodes,
  HttpStatusCode,
  HttpStatusMessages,
  I18n,
  InternalServerError,
  IssueSeverity,
  MappedType2 as MappedType,
  MetadataMode,
  MethodNotAllowedError,
  MixinType2 as MixinType,
  NAMESPACE_PATTERN,
  NotAcceptableError,
  NotFoundError,
  OmitType,
  OperationResult,
  OpraException,
  opra_filter_ns_exports as OpraFilter,
  opra_schema_ns_exports as OpraSchema,
  OpraURL,
  OpraURLPath,
  OpraURLPathComponent,
  Parameter,
  PartialType,
  PermissionError,
  PickType,
  RESOURCE_METADATA,
  Resource,
  ResourceConflictError,
  ResourceNotAvailableError,
  ResponsiveMap,
  SORT_FIELD_PATTERN,
  SimpleType2 as SimpleType,
  Singleton2 as Singleton,
  Storage2 as Storage,
  TYPENAME_PATTERN,
  TypeDocument,
  TypeDocumentFactory,
  UnauthorizedError,
  UnprocessableEntityError,
  cloneObject,
  getStackFileName,
  i18n,
  inheritPropertyInitializers,
  isAbsoluteUrl,
  isAsyncIterable,
  isBlob,
  isConstructor,
  isFormData,
  isIterable,
  isReadable,
  isReadableStream,
  isStream,
  isURL,
  isUrlString,
  isWritable,
  mergePrototype,
  omitNullish,
  omitUndefined,
  pathToObjectTree,
  resolveClass,
  resolveThunk,
  translate,
  uid,
  wrapException
};
